<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2020%2F02%2F28%2F%E7%96%AB%E6%83%85%E4%B9%8B%E4%B8%8B%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%A7%E8%83%86%E8%B7%B3%E6%A7%BD%E7%9A%84%2F</url>
    <content type="text"><![CDATA[一、前言一场突如其来的疫情打乱了很多人的计划，起初没有人在意，直到这场灾难和每个人息息相关。 企业停工，招聘也随之缩减，别说招聘，有些企业甚至开始了裁员；这个时候。很多人并不愿意冒险离职去寻求新的工作机会，这也会导致招聘市场上放出的岗位很少。从二月初开始关注招聘市场，在java工程师这块的深圳招聘数目并不多。但逆境中总有机遇，就像巴菲特所说“众人贪婪时我恐惧，众人恐惧时我贪婪”。二月初开始准备，历时近一个月，面试十余家公司，历经数十轮面试。最终收到6个offer，综合对比，去了最满意的公司。写这篇文章一来是这么多次面试算是一个总结，二来正值金三银四也给有需要找java开发岗位的朋友复习的思路。 二、我的备战不打无准备的仗，一旦准备跳槽，就要着手开始复习，万事开头难，列出合理的复习计划又是最为重要的环节，我的整体规划如下：1、优化简历，并在各大平台更新简历2、java基础的复习3、数据结构和算法复习4、框架复习5、高并发和分布式6、已做项目的总结归纳下面会就具体环境详细讲解注意的地方。贴出一些复习时做的笔记，以及面试的题目总结，都是公司实战面试题目（ps：笔记过多，不全贴出，需要的可以加我vx，或者后台私信我，给发压缩包，包括面试的视频、简历模板以及复习的pdf文档） 三、优化并更新简历在准备复习之前，需要对简历做一个优化，简历可以大概分为以下七个部分：1、个人信息这个必须放在第一位或者最显眼的地方，hr筛选简历第一眼看的是个人信息是否符合，比如学历信息，工作年限等，也方便面试官联系到你。个人信息应至少包含以下方面： 姓名 性别 年龄 学历 籍贯 联系电话 目前城市 大学 电子邮件 工作经验2、求职意向工作性质、目标地点、目标职能、目标薪资3、博客技术网站这块是非必须的，但是可以作为一个加分项，很多面试官看到我这块的时候，都有去看我的博客，并就博客和开源网站问一些问题，这也可以表明你平时业余的时间有很大一部分是在技术博客开源网站论坛上面，侧面反应了你对技术的热爱，仅是一个加分项，主要还是要看技术栈和项目经验。这里我主要写了我的csdn博客，个人网站，GitHub开源项目，微信公众号（苍何之旅）4、工作经历工作经历按照就近的一份工作在前，按照时间倒序的原则。写一下公司名称，职位名称，任职年限以及工作职责即可5、专业技能这部分是很重要的一部分内容，需按实填写，因为面试官拿到你简历问题的很大一部分来源都是根据你写的来的，有很多人把眼下最火的技术全部都写了，不得不说在HR简历筛选时有更大的机会能进入面试，但是面试官一问，没做过的确实很难能答的很好，建议按实写。6、项目经历这部分主要针对社招生，社招需要你有一定的项目经验，而且面试官很大程度上就围绕你写的项目来问，所以这是最为重要的环节，其中有几个必须项需要优化表述： 项目名称 项目所用技术 开发时间/开发周期： 项目描述 责任描述 技术描述 一定要对自己项目很熟悉很熟悉，这里需要花点时间好好总结一下你的开发项目，用到哪些技术，遇到哪些问题以及是怎么解决的，有没有进行优化等等等。 优化完了简历在各大招聘网站可以更新自己的简历，比如boss和拉勾网等，我主要在boss上找。接下来就可以边挂着简历边进行技术面试的准备环节了。 四、面试之自我介绍准备不得不说，我之前恐惧面试的很大一部分原因是因为我害怕去自我介绍，总觉得自己没什么可介绍的，一两句话就说完了，经过女朋友的一番鼓励以及方法支持，我不但克服了恐惧，在自我介绍时不仅自信从容还能随机应变就不同的面试官进行不同的介绍。1、HR关心的是你这个人整体的个人素质，小伙子能不能吃苦，能不能有自己的规划，对技术是不是热爱这些，这个就要多展示一下你的个人优秀品质，少或者不加技术或者项目经验在里面。2、技术面试官关心的是你的技术水平，很多公司技术分两轮，分为技术初面和复面，初面是你能不能进入接下来面试的重要一环，技术水平必须到位，所以自我介绍必须多讲一些项目和技术栈的东西，技术复面除了技术初面的介绍外，要让面试官觉得你对一项技术除了会用还要有自己的理解，当然这个平时的时候一定要注意，不要停留在仅仅会用的程度，对底层代码逻辑要很熟悉。3、boss终极面试，有些公司会最后一轮老板面试，自我介绍时一定要带上对公司的一个了解，老板希望看到积极阳光、很大意向想进这家公司并且愿意和公司共同进步的人。 五、面试之技术准备技术准备不用说，必然是重中之重。我在面试中常被问到的问题，我做了一个总结，但是没有列出答案，我在笔记上写了答案，如果有需要我笔记的可以私信发你。1、hashmap相关 JDK8中的hashmap有哪些改动 为何JDK8中的hashmap要使用红黑树 hashmap的扩容机制以及JDK7和JDK8的区别 hashmap是线程安全的嘛 使用hashmap的注意点 2、volatile的理解3、JDK7和8JVM的变化4、Linux常用命令5、zookeeper的理解 是什么 zookeeper提供了什么 ZAB协议 如何保证事务一致性的 zk的宕机如何处理zk负载均衡和Nginx区别 zk应用场景 6、Mysql碎银 索引底层实现原理和优化 什么情况下索引无法使用 7、SQL优化结合项目谈一下你是怎么进行sql优化的8、数据库引擎有什么区别9、数据库锁10、反射11、java读取数据库时如何保证同一时刻只有一个线程修改数据库的某一条记录12、union和union all的区别13、具体的sql模拟测试14、动态代理15、java常见的设计模式16、HTTP协17、TCP协议18、map的几个实现类以及区别19、讲一下栈20、如何让多个域名对应同一个IP21、spring的AOP原理22、java中动态代理的两种方式23、mysql分页查询500万条数据，limit查最后一页很慢怎么优化24、分布式事务25、事务的隔离级别26、多线程的状态，阻塞和非阻塞的区别27、共享锁、互斥锁、读写锁28、IO和NIO的区别29、java垃圾回收机制（GC） JAVA内存 GC主要任务 如何鉴别一个对象是垃圾对象并被GC处理以及用到的算法 垃圾回收算法 开发中容易造成内存泄露的操作 JVM内存优化 30、java基本数据类型31、方法重载和重写的区别32、==和equals的区别33、stringbuffer和stringbuilder的区别34、java常见的异常35、mybatis中的#和$的区别以及什么时候使用36、mybatis索引失效怎么办37、如何创建索引38、笛卡尔积39、Redis相关问题 什么是redis有什么用 redis的五种数据类型 redis持久化机制 缓存redis如何扩容 redis key的过期时间和永久有效分别怎么设置 过期数据怎么处理 redis如何做内存优化 redi事务 redis哨兵模式 redis分布式锁 缓存雪崩 缓存穿透 缓存击穿 缓存预热 缓存降级 redis用到的算法 40、JVM相关 说一下JVM主要组成部分以及作用 说一下JVM运行时数据区 深拷贝和浅拷贝，以及具体你项目中怎么使用 堆栈区别说一下 队列和栈是什么，有什么区别 保证线程安全的两种方式 java的内存泄露 如何判断对象是否可悲回收jvm垃圾回收算法 垃圾收集器 内存分配策略描述JVM加载class文件原理机制 双亲委证模型 41、springmvc相关 描述springmvc工作流程 mvc是什么 springmvc怎么设置重定向和转发 42、为什么需要预编译43、动态sql常用标签 六、offer筛选，去到心仪公司面试本身就是一个双向选择的过程，手头有一个offer不要立马就去入职这家公司，拒绝也是一种选择，有些公司可能会给你多加钱，这个时候就要各种对比，薪资是一方面，最重要的是个人的发展和公司的前景。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Maven依赖管理]]></title>
    <url>%2F2019%2F11%2F10%2FMaven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、什么是Mavenmaven是一个管理依赖的工具，我们项目中常用maven来管理jar包，并且可以管理jar包的依赖，有了maven，无论是引用别人的jar包还是自己项目需要打 包都变得极其简单。maven仓库就是存放jar包的仓库，分为本地库、远程库和私有库。本地库是本地计算机存放jar包的地方，本地仓库需要到私有库去拉取jar包，私有库一般是公司自己存放jar的仓库，会有专门的人员进行维护，远程库就是公有库，里面涵盖了很多的jar包，可以直接下载，但是需要外网权限。 二、Maven安装超级简单，直接百度，或者访问这个博客：https://blog.csdn.net/m1234ilu/article/details/84261888 三、坐标pom.xml里，使用下面三个向量，在仓库中唯一定位一个Maven工程，每一个坐标代表这个工程所在的位置。groupId 公司或者组织的域名倒序+项目名 com.dfr.TestMavenartifactId 模块名 Helloversion 版本 0.0.1-SNAPSHOT 四、仓库管理本地仓库：当前电脑上部署的 仓库目录私服：架设在局域网环境中，为局域网范围内 的所有Maven工程服务中央仓库：架设在Internet上，为全世界的Maven工程服务中央仓库镜像：架设在各大洲，为了分担中央仓库的流量，更快响应用户 五、生命周期生命周期定义：一套生命周期，就是把许多的构建过程，有序的排列。形成一套有序的构建过程集合。生命周期特性：无论执行该生命周期的哪个阶段，它前面的所有阶段都会被按顺序执行。Maven有三套独立的生命周期：Clean LifeCycle 真正构建前，先清理Default LifeCycle 核心的构建部分：编译，测试，打包，安装，部署等Site LifeCycle 生成项目报告，站点，发布站点以Default 生命周期为例，并列举部分常用的的阶段：compile -&gt; test-compile -&gt; test -&gt; package -&gt; install -&gt; deploy 若执行 test-compile阶段，则真正被执行的有 compile -&gt; test-compi 六、插件和目标Maven核心程序只是定义了生命周期的各个阶段，以及每个阶段需要去执行哪个插件的哪个模块。 所以真正去执行时，会依赖本地仓库中的插件。Maven核心程序中并没有这些插件。 生命周期阶段 调用插件 调用插件的目标（模块）compile maven-compiler-plugin compiletest-compile maven-compiler-plugin testCompile 七、依赖的排除定义：工程A依赖工程B，工程B依赖b.jar。若工程A中不想要b.jar，则需要配置依赖的排除信息。配置信息123456&lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;/exclusion&gt;&lt;/exclusions&gt;]]></content>
      <categories>
        <category>常用工具和环境</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux操作系统]]></title>
    <url>%2F2019%2F11%2F10%2FLinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[一、Linux概述Linux和Windows均属于操作系统的范畴，和windows不同的是，他没有像Windows有图形化界面，可以鼠标点点点，Linux所有操作都是命令行操作，Linux不同于Windows，是个开源的操作系统，全世界有很多的开发者都参与到Linux的建设中。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、台式计算机。Linux是由芬兰赫尔辛基大学学生Linus Torvalds和后来加入的众多爱好者共同开发完成，Linux之父Linus Torvalds于19年宣布退休。 二、Linux目录结构bin (binaries)存放二进制可执行文件sbin (super user binaries)存放二进制可执行文件，只有root才能访问etc (etcetera)存放系统配置文件usr (unix shared resources)用于存放共享的系统资源home 存放用户文件的根目录root 超级用户目录dev (devices)用于存放设备文件lib (library)存放跟文件系统中的程序运行所需要的共享库及内核模块mnt (mount)系统管理员安装临时文件系统的安装点boot 存放用于系统引导时使用的各种文件tmp (temporary)用于存放各种临时文件var (variable)用于存放运行时需要改变数据的文件 三、java开发用到的Linux命令操作文件或目录常用命令1234567891011121314151617pwd 显示当前工作目录（print working directory）touch 创建空文件 mkdir 创建目录（make directoriy）-p 父目录不存在情况下先生成父目录 （parents） cp 复制文件或目录（copy）-r 递归处理，将指定目录下的文件与子目录一并拷贝（recursive） mv 移动文件或目录、文件或目录改名（move）rm 删除文件（remove）-r 同时删除该目录下的所有文件（recursive）-f 强制删除文件或目录（force）rmdir 删除空目录（remove directoriy）cat显示文本文件内容 （catenate）more、less 分页显示文本文件内容head、tail查看文本中开头或结尾部分的内容haed -n 5 a.log 查看a.log文件的前5行tail -F b.log 循环读取（follow） 常用命令123456789101112131415161718192021222324252627282930313233wc 统计文本的行数、字数、字符数（word count）-m 统计文本字符数-w 统计文本字数-l 统计文本行数find 在文件系统中查找指定的文件find /etc/ -name &quot;aaa&quot;grep 在指定的文本文件中查找指定的字符串ln 建立链接文件（link）-s 对源文件建立符号连接，而非硬连接（symbolic）top 显示当前系统中耗费资源最多的进程 ps 显示瞬间的进程状态-e /-A 显示所有进程，环境变量-f 全格式-a 显示所有用户的所有进程（包括其它用户）-u 按用户名和启动时间的顺序来显示进程-x 显示无控制终端的进程kill 杀死一个进程kill -9 piddf 显示文件系统磁盘空间的使用情况du 显示指定的文件（目录）已使用的磁盘空间的总-h文件大小以K，M，G为单位显示（human-readable）-s只显示各档案大小的总合（summarize）free 显示当前内存和交换空间的使用情况 netstat 显示网络状态信息-a 显示所有连接和监听端口-t (tcp)仅显示tcp相关选项-u (udp)仅显示udp相关选项-n 拒绝显示别名，能显示数字的全部转化成数字。-p 显示建立相关链接的程序名ifconfig 网卡网络配置详解 ping 测试网络的连通性 备份压缩命令123gzip 压缩（解压）文件或目录，压缩文件后缀为gz bzip2 压缩（解压）文件或目录，压缩文件后缀为bz2 tar 文件、目录打（解）包 gzip命令12345命令格式：bzip2 [-cdz] 文档名-c将压缩的过程产生的数据输出到屏幕上-d解压缩的参数（decompress）-z压缩的参数（compress）-num 用指定的数字num调整压缩的速度，-1或--fast表示最快压缩方法（低压缩比），-9或--best表示最慢压缩方法（高压缩比）。系统缺省值为6 tar命令123456-c 建立一个压缩文件的参数指令（create）-x 解开一个压缩文件的参数指令（extract）-z 是否需要用 gzip 压缩-j 是否需要用 bzip2 压缩-v 压缩的过程中显示文件（verbose）-f 使用档名，在 f 之后要立即接档名（file） 关机/重启命令12345shutdown系统关机 -r 关机后立即重启-h 关机后不重新启动halt 关机后关闭电源 shutdown -hreboot 重新启动 shutdown -r 四、Linux文档可以参考这篇文档https://blog.csdn.net/syt8945/article/details/50838679]]></content>
      <categories>
        <category>常用工具和环境</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot与缓存（整合redis）]]></title>
    <url>%2F2019%2F09%2F01%2Fspringboot%E4%B8%8E%E7%BC%93%E5%AD%98%EF%BC%88%E6%95%B4%E5%90%88redis%EF%BC%89%2F</url>
    <content type="text"><![CDATA[springboot与缓存（整合redis） 一、什么是缓存 缓存就是数据交换的缓冲区（称作：Cache），他把一些外存上的数据保存在内存上，为什么保存在内存上，我们运行的所有程序里面的变量都是存放在内存中的，所以如果想将值放入内存上，可以通过变量的方式存储。在JAVA中一些缓存一般都是通过Map集合来实现的。 缓存在不同的场景下，作用是不一样的具体举例说明： ✔ 操作系统磁盘缓存 ——&gt; 减少磁盘机械操作。 ✔ 数据库缓存——&gt;减少文件系统IO。 ✔ 应用程序缓存——&gt;减少对数据库的查询。 ✔ Web服务器缓存——&gt;减少应用服务器请求。 ✔ 客户端浏览器缓存——&gt;减少对网站的访问。 具体关于缓存的详细介绍以及缓存的面试问题可以参考这篇博客 https://blog.csdn.net/zhengzhaoyang122/article/details/82184029 二、Spring缓存抽象Spring从3.1开始定义了org.springframework.cache.Cache和org.springframework.cache.CacheManager接口来统一不同的缓存技术；并支持使用JCache（JSR-107）注解简化我们开发； 每次调用需要缓存功能的方法时，Spring会检查检查指定参数的指定的目标方法是否已经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取。 使用Spring缓存抽象时我们需要关注以下两点； 1、确定方法需要被缓存以及他们的缓存策略 2、从缓存中读取之前缓存存储的数据 三、几个重要概念&amp;缓存注解1、Cache：缓存接口，定义缓存操作。实现有：RedisCache、EhCacheCache、ConcurrentMapCache等 2、CacheManager缓存管理器，管理各种缓存（Cache）组件 3、@Cacheable主要针对方法配置，能够根据方法的请求参数对其结果进行缓存 （后面会细说该注解） 4、@CacheEvict清空缓存 5、@CachePut保证方法被调用，又希望结果被缓存。 6、@EnableCaching开启基于注解的缓存 7、keyGenerator缓存数据时key生成策略 8、serialize缓存数据时value序列化策略 9、@Cacheable/@CachePut/@CacheEvict 主要的参数 四、springboot整合redis实现缓存1、引入依赖在pom.xml中引入spring-boot-starter-data-redis依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 2、配置redis连接地址在application.yml或者application.properties中配置redis连接地址 这里还需要配置一下数据库的地址，方便测试使用 application.properties配置 12345678910111213spring.datasource.url=jdbc:mysql://MySQL的主机地址:3306/数据库名spring.datasource.username=rootspring.datasource.password=密码spring.datasource.driver-class-name=com.mysql.jdbc.Driver# 启用mybatis的命名策略（即驼峰命名法）mybatis.configuration.map-underscore-to-camel-case=truelogging.level.com.atguigu.cache.mapper=debugdebug=truespring.redis.host=redis主机地址 application.yml配置： 1234567891011121314151617181920212223242526272829303132333435363738spring: datasource: username: root password: 123456 url: jdbc:mysql://MySQL的主机地址:3306/数据库名 driver-class-name: com.mysql.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource #配置Druid数据源 # 数据源其他配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 redis: host: redis主机地址#mybatis:# config-location: classpath:mybatis/mybatis-config.xml# 开启驼峰命名mybatis: configuration: map-underscore-to-camel-case: truelogging: level: com.canghe.springboot.mapper: debugdebug: true# mapper-locations: classpath:mybatis/mapper/*.xml 3、在虚拟机或者云服务器上安装redis可以直接通过docker安装redis，并配置端口 4、使用RestTemplate操作redis12345@AutowiredStringRedisTemplate stringRedisTemplate;//操作k-v都是字符串@AutowiredRedisTemplate redisTemplate;//操作k-v对象的 Redis常见的五大数据类型 String(字符串) 、list(列表)、set（集合）、hash（散列）、Zset（有序集合） redisTemplate.opsForValue();//操作字符串 redisTemplate.opsForHash();//操作hash redisTemplate.opsForList();//操作list redisTemplate.opsForSet();//操作set redisTemplate.opsForZSet();//操作有序set 测试代码： 12345678 @Test public void test01() &#123;// stringRedisTemplate.opsForValue().append("key","helloword");// String msg = stringRedisTemplate.opsForValue().get("key");// System.out.println("msg:"+msg); stringRedisTemplate.opsForList().leftPush("firstList","1"); stringRedisTemplate.opsForList().leftPush("firstList","2"); &#125; 五、@Cacheable注解1、运行流程1、方法运行之前，先去查询Cache（缓存组件），按照cacheNames指定的名字获取；（CacheManager先获取相应的缓存），第一次获取缓存如果没有Cache组件会自动创建。2、去Cache中查找缓存的内容，使用一个key，默认就是方法的参数； key是按照某种策略生成的；默认是使用keyGenerator生成的，默认使用SimpleKeyGenerator生成key； SimpleKeyGenerator生成key的默认策略； 如果没有参数；key=new SimpleKey()； 如果有一个参数：key=参数的值 如果有多个参数：key=new SimpleKey(params)； 3、没有查到缓存就调用目标方法； 4、将目标方法返回的结果，放进缓存中 @Cacheable标注的方法执行之前先来检查缓存中有没有这个数据，默认按照参数的值作为key去查询缓存， 如果没有就运行方法并将结果放入缓存；以后再来调用就可以直接使用缓存中的数据； 2、核心 1）、使用CacheManager【ConcurrentMapCacheManager】按照名字得到Cache【ConcurrentMapCache】组件 2）、key使用keyGenerator生成的，默认是SimpleKeyGenerator 3、几个属性 cacheNames/value：指定缓存组件的名字;将方法的返回结果放在哪个缓存中，是数组的方式，可以指定多个缓存； key：缓存数据使用的key；可以用它来指定。默认是使用方法参数的值 1-方法的返回值， 编写SpEL； #i d;参数id的值 #a0 #p0 #root.args[0] getEmp[2] keyGenerator：key的生成器；可以自己指定key的生成器的组件id，key/keyGenerator：二选一使用; cacheManager：指定缓存管理器；或者cacheResolver指定获取解析器 condition：指定符合条件的情况下才缓存； condition = “#a0&gt;1”：第一个参数的值》1的时候才进行缓存 unless:否定缓存；当unless指定的条件为true，方法的返回值就不会被缓存；可以获取到结果进行判断 12unless = &quot;#result == null&quot; * unless = &quot;#a0==2&quot;:如果第一个参数的值是2，结果不缓存； sync：是否使用异步模式 @Cacheable例子： 123456@Cacheable(value = &#123;"emp"&#125;/*,keyGenerator = "myKeyGenerator",condition = "#a0&gt;1",unless = "#a0==2"*/) public Employee getEmp(Integer id)&#123; System.out.println("查询"+id+"号员工"); Employee emp = employeeMapper.getEmpById(id); return emp; &#125; 六、@CachePut1、启用场景既调用方法，又更新缓存数据；同步更新缓存，修改了数据库的某个数据，同时更新缓存； 2、运行时机 先调用目标方法 将目标方法的结果缓存起来 3、测试步骤 1、查询1号员工；查到的结果会放在缓存中； key：1 value：lastName：张三 2、以后查询还是之前的结果 3、更新1号员工；【lastName:zhangsan；gender:0】 将方法的返回值也放进缓存了； key：传入的employee对象 值：返回的employee对象； 4、查询1号员工？ 应该是更新后的员工； key = “#employee.id”:使用传入的参数的员工id； key = “#result.id”：使用返回后的id @Cacheable的key是不能用#result 为什么是没更新前的？【1号员工没有在缓存中更新】 123456@CachePut(/*value = "emp",*/key = "#result.id") public Employee updateEmp(Employee employee)&#123; System.out.println("updateEmp:"+employee); employeeMapper.updateEmp(employee); return employee; &#125; 七、@CacheEvict缓存清除123456789101112131415161718/** * @CacheEvict：缓存清除 * key：指定要清除的数据 * allEntries = true：指定清除这个缓存中所有的数据 * beforeInvocation = false：缓存的清除是否在方法之前执行 * 默认代表缓存清除操作是在方法执行之后执行;如果出现异常缓存就不会清除 * * beforeInvocation = true： * 代表清除缓存操作是在方法运行之前执行，无论方法是否出现异常，缓存都清除 * * */@CacheEvict(value="emp",beforeInvocation = true/*key = "#id",*/)public void deleteEmp(Integer id)&#123; System.out.println("deleteEmp:"+id); //employeeMapper.deleteEmpById(id); int i = 10/0;&#125; 八、@Caching定义复杂的缓存规则 123456789@Caching( cacheable = &#123; @Cacheable(/*value="emp",*/key = "#lastName") &#125;, put = &#123; @CachePut(/*value="emp",*/key = "#result.id"), @CachePut(/*value="emp",*/key = "#result.email") &#125; ) The more effort，the more luckyGitHub项目 https://github.com/freestylefly/javaStudy 我的CSDN博客 https://blog.csdn.net/qq_43270074 个人博客 http://canghe.top/ 微信公众号]]></content>
      <categories>
        <category>JavaEE框架</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker入门到精通]]></title>
    <url>%2F2019%2F08%2F31%2FDocker%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%2F</url>
    <content type="text"><![CDATA[学习docker 一、前言在计算机技术日新月异的今天， Docker 在国内发展的如火如荼。特别是在一线互联网公司 Docker 的使用是十分普遍的，甚至成为了一些企业面试的加分项，不信的话看看下面这张图。 这是在某招聘网站上看到的招聘 Java 开发工程师的招聘要求，其中有一条熟悉 Docker 成为了你快速入职的加分项，由此可见熟悉 Docker 在互联网公司的地位之重要。 Docker相关视频教程下载： http://www.jsdaima.com/video/490.htmlhttp://www.jsdaima.com/video/459.htmlhttp://www.jsdaima.com/video/384.htmlhttp://www.jsdaima.com/video/371.htmlhttp://www.jsdaima.com/video/363.html 二、Docker简介 1、概念当把环境从一个服务器迁移到另一个服务器，当你新买了电脑，会遇上要重新安装一系列的软件，比如JDK、Tomcat、maven、redis等，而安装完之后每一次都需要再去配置环境，但是这些都是重复性的工作，有什么办法可以解决呢？ 玩过云服务器的听说过有镜像一说，将所有的软件和需要的配置都打包好做成镜像，下次需要的时候只需要安装镜像就可以。 类似的，Docker就是解决这种问题的，将所有的软件程序都放在docker仓库中，我们只需要在电脑上下载docker即可，不需要再去进行繁琐的安装和配置了，只需要几个命令就可以将我们的环境搭建好，这就是docker。 总结： Docker是一个开源的应用容器引擎；是一个轻量级容器技术；Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；运行中的这个镜像称为容器，容器启动是非常快速的。 2、Docker 的优势 Docker 启动快速（比虚拟机快多了） Docker 需要的资源更少。Docker 在操作系统级别进行虚拟化，Docker 容器和内核交互，几乎没有性能损耗，性能优于通过 Hypervisor 层与内核层的虚拟化。 Docker 更轻量。Docker 的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境，Docker 运行的镜像数远多于虚拟机数量，对系统的利用率非常高。 与虚拟机相比，Docker 隔离性更弱。Docker 属于进程之间的隔离，虚拟机可实现系统级别隔离。 安全性。Docker 的安全性也更弱，Docker 的租户 Root 和宿主机 Root 等同，一旦容器内的用户从普通用户权限提升为 Root 权限，它就直接具备了宿主机的 Root 权限，进而可进行无限制的操作 可管理性。Docker 的集中化管理工具还不算成熟。各种虚拟化技术都有成熟的管理工具，例如 VMware vCenter 提供完备的虚拟机管理能力。 高可用和可恢复性。Docker 对业务的高可用支持是通过快速重新部署实现的。 虚拟化具备负载均衡，高可用，容错，迁移和数据保护等经过生产实践检验的成熟保障机制， VMware 可承诺虚拟机 99.999% 高可用，保证业务连续性。 快速创建、删除。虚拟化创建是分钟级别的，Docker 容器创建是秒级别的，Docker 的快速迭代性，决定了无论是开发、测试、部署都可以节约大量时间 3、核心概念docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）； docker客户端(Client)：连接docker主机进行操作； docker仓库(Registry)：用来保存各种打包好的软件镜像； docker镜像(Images)：软件打包好的镜像；放在docker仓库中； docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用 三、安装docker1、安装linux虚拟机​ 1）、VMWare、VirtualBox（安装）； ​ 2）、导入虚拟机文件centos7-atguigu.ova； ​ 3）、双击启动linux虚拟机;使用 root/ 123456登陆 ​ 4）、使用客户端连接linux服务器进行命令操作； ​ 5）、设置虚拟机网络； ​ 桥接网络===选好网卡====接入网线； ​ 6）、设置好网络以后使用命令重启虚拟机的网络 1service network restart ​ 7）、查看linux的ip地址 1ip addr ​ 8）、使用客户端连接linux； 2、在linux虚拟机上安装docker步骤： 1234567891011121314151617181、检查内核版本，必须是3.10及以上uname -r2、安装依赖包sudo yum install -y yum-utils device-mapper-persistent-data lvm2 3、设置阿里云镜像源sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo2、安装dockersudo yum install docker3、输入y确认安装4、启动docker[root@localhost ~]# systemctl start docker[root@localhost ~]# docker -vDocker version 1.12.6, build 3e8e77d/1.12.65、开机启动docker[root@localhost ~]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.6、停止dockersystemctl stop docker 四、Docker常用命令和操作1）、镜像操作 操作 命令 说明 检索 docker search 关键字 eg：docker search redis 我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。 拉取 docker pull 镜像名:tag :tag是可选的，tag表示标签，多为软件的版本，默认是latest 列表 docker images 查看所有本地镜像 删除 docker rmi image-id 删除指定的本地镜像 https://hub.docker.com/ 2）、容器操作软件镜像（QQ安装程序）——运行镜像——产生一个容器（正在运行的软件，运行的QQ）； 步骤： 1234567891011121314151617181920212223242526272829301、搜索镜像[root@localhost ~]# docker search tomcat2、拉取镜像[root@localhost ~]# docker pull tomcat3、根据镜像启动容器docker run --name mytomcat -d tomcat:latest4、docker ps 查看运行中的容器5、 停止运行中的容器docker stop 容器的id6、查看所有的容器docker ps -a7、启动容器docker start 容器id8、删除一个容器 docker rm 容器id9、启动一个做了端口映射的tomcat[root@localhost ~]# docker run -d -p 8888:8080 tomcat-d：后台运行-p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口10、为了演示简单关闭了linux的防火墙service firewalld status ；查看防火墙状态service firewalld stop：关闭防火墙11、查看容器的日志docker logs container-name/container-id更多命令参看https://docs.docker.com/engine/reference/commandline/docker/可以参考每一个镜像的文档 3）、安装MySQL示例1docker pull mysql 错误的启动 1234567891011121314151617[root@localhost ~]# docker run --name mysql01 -d mysql42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846mysql退出了[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES42f09819908b mysql "docker-entrypoint.sh" 34 seconds ago Exited (1) 33 seconds ago mysql01538bde63e500 tomcat "catalina.sh run" About an hour ago Exited (143) About an hour ago compassionate_goldstinec4f1ac60b3fc tomcat "catalina.sh run" About an hour ago Exited (143) About an hour ago lonely_fermi81ec743a5271 tomcat "catalina.sh run" About an hour ago Exited (143) About an hour ago sick_ramanujan//错误日志[root@localhost ~]# docker logs 42f09819908berror: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个 正确的启动 12345[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb874c56bec49 mysql "docker-entrypoint.sh" 4 seconds ago Up 3 seconds 3306/tcp mysql01 做了端口映射 12345[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESad10e4bc5c6a mysql "docker-entrypoint.sh" 4 seconds ago Up 2 seconds 0.0.0.0:3306-&gt;3306/tcp mysql02 几个其他的高级操作 123456docker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci指定mysql的一些配置参数]]></content>
      <categories>
        <category>互联网架构新技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java在过滤器中为http请求加请求头header]]></title>
    <url>%2F2019%2F08%2F13%2Fjava%E5%9C%A8%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%AD%E4%B8%BAhttp%E8%AF%B7%E6%B1%82%E5%8A%A0%E8%AF%B7%E6%B1%82%E5%A4%B4header%2F</url>
    <content type="text"><![CDATA[前言现在有一个需求场景是，每一个请求我都需要在请求头里面加上token这个请求头，作为一种校验机制，传统的接口可以通过设置一个全局的变量，然后通过页面携带过来（大概就是先将我们的token放在session中，写一个服务用来获取session中的token，然后主页面用ajax调用接口，将token放在隐藏域中，然后将请求头放进来，用ajax方法，这里不想洗说了），但是有一种情况是通过页面传递的并不一定都会适用所有接口，比如上传和下载的接口有时候头里面就没有token参数，可能是上传和下载是用表单提交的这个时候如何将请求头通过后台的方法加进来？想到用过滤器，用后台方法强制加入请求头。 HTTP请求头关于http请求头的相关信息可以参考这票博客，这里就不画蛇添足了https://blog.csdn.net/alexshi5/article/details/80379086下面直接上如何通过filter为请求添加请求头参数： 新建请求控制类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.bitplan.smartCRM.web;import java.io.IOException;import java.util.Collections;import java.util.Enumeration;import java.util.HashMap;import java.util.List;import java.util.Map;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper; public class HeaderMapRequestWrapper extends HttpServletRequestWrapper &#123; /** * construct a wrapper for this request * * @param request */ public HeaderMapRequestWrapper(HttpServletRequest request) &#123; super(request); &#125; private Map&lt;String, String&gt; headerMap = new HashMap&lt;String, String&gt;(); /** * add a header with given name and value * * @param name * @param value */ public void addHeader(String name, String value) &#123; headerMap.put(name, value); &#125; @Override public String getHeader(String name) &#123; String headerValue = super.getHeader(name); if (headerMap.containsKey(name)) &#123; headerValue = headerMap.get(name); &#125; return headerValue; &#125; /** * get the Header names */ @Override public Enumeration&lt;String&gt; getHeaderNames() &#123; List&lt;String&gt; names = Collections.list(super.getHeaderNames()); for (String name : headerMap.keySet()) &#123; names.add(name); &#125; return Collections.enumeration(names); &#125; @Override public Enumeration&lt;String&gt; getHeaders(String name) &#123; List&lt;String&gt; values = Collections.list(super.getHeaders(name)); if (headerMap.containsKey(name)) &#123; values.add(headerMap.get(name)); &#125; return Collections.enumeration(values); &#125; &#125; 新建过滤器注意：需要将请求头里面没有token的接口后面带上token参数，参数名是“”token“”123456789101112131415161718192021222324252627public class RemoteAddrFilter implements Filter &#123; @Override public void destroy() &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest req = (HttpServletRequest) request; HeaderMapRequestWrapper requestWrapper = new HeaderMapRequestWrapper(req); //获得请求参数中的token值 String token = request.getParamter("token"); if（!StringUtils.isEntry(token)）&#123; //如果请求中带有这个参数，则进行过滤加一个header头 requestWrapper.addHeader("tokenr", token); chain.doFilter(requestWrapper, response); // Goes to default servlet. &#125; chain.doFilter(request, response); // Goes to default servlet. &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; 这个时候请求头中是会带有这个token，但是你可能用右键F12看不到这个头，相当于是一层伪代理，我们的接口是已经加上token校验。 总结查找了很多资料，百度找到的和其他博客上说的感觉都是大同小异，并没有达到想要的效果。我觉得写博客就得一针见血，什么问题必须标书清楚，不要为了写而写，你可能不知道当人看了半天你的博客但是却没有得到问题的解决是一件多么痛苦的过程。最后是在https://stackoverflow.com上面找到的答案，当百度找不到答案时尝试谷歌，谷歌找不到时尝试下stackoverflow。查找问题的搜索词也很重要，这些都需要有相关的经验才可以快速的定位问题，快速的找到解决办法，这才是一个资深程序眼必须会的一项技能。]]></content>
      <categories>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>请求头</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot系列知识]]></title>
    <url>%2F2019%2F08%2F11%2Fspringboot%E7%B3%BB%E5%88%97%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[前言Spring Boot都很熟悉了，再重新认识学习一遍。此为知识整理 一、Spring Boot 入门 Build Anything with Spring Boot：Spring Boot is the starting point for building all Spring-based applications. Spring Boot is designed to get you up and running as quickly as possible, with minimal upfront configuration of Spring. 上面是引自官网的一段话，大概是说： Spring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件 1、Spring Boot 简介简化Spring应用开发的一个框架； 整个Spring技术栈的一个大整合； J2EE开发的一站式解决方案； 2、微服务微服务是一种架构风格，简单理解就是服务微化，一个应用应该是一组小型服务，可以通过HTTP的方式进行互通，和微服务相反的是单体应用，微服务是每一个功能元素最终都是一个可独立替换和独立升级的软件单元；详细参照微服务文档 3、启动器Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器，而且版本由springboot自动控制 4、启动器用 @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用，编写一个main方法，如下： 123456789@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; @SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们；J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar； 5、使用Spring Initializer快速创建Spring Boot项目需要前面说明的是使用Spring Initializer的方式有可能你的idea会没有这个选项，那是因为那是社区版的，你需要下载非社区版的idea才可以使用Spring Initializer想要用什么功能直接勾选相应的starter即可 创建好后的目录结构如下：默认生成的Spring Boot项目； 主程序已经生成好了，我们只需要我们自己的逻辑 resources文件夹中目录结构 static：保存所有的静态资源； js css images； templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot应用的配置文件；可以修改一些默认设置；二、配置文件1、配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的；叫application.properties或者application.yml，配置文件的作用是修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好； 2、YAML简介以前的配置文件，大多都使用的是 xxxx.xml文件，YAML文件则是以数据为中心，比json、xml等更适合做配置文件，YAML：配置例子 12server: port: 8081 ​ XML： 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 基本语法：k:(空格)v：表示一对键值对（空格必须有）以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path: /hello 属性和值也是大小写敏感值的写法：字面量：普通的值（数字，字符串，布尔）k: v：字面直接来写；字符串默认不用加上单引号或者双引号，如果机上有特殊转移如下： 1234567​ &quot;&quot;：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思​ name: &quot;zhangsan \n lisi&quot;：输出；zhangsan 换行 lisi​ &apos;&apos;：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据​ name: ‘zhangsan \n lisi’：输出；zhangsan \n lisi 对象、Map（属性和值）（键值对）： 12345678910​ k: v：在下一行来写对象的属性和值的关系；注意缩进​ 对象还是k: v的方式friends: lastName: zhangsan age: 20行内写法：friends: &#123;lastName: zhangsan,age: 18&#125; 数组（List、Set）： 12345678用- 值表示数组中的一个元素pets: - cat - dog - pig - 行内写法 pets: [cat,dog,pig] 3、配置文件值注入配置文件：123456789101112person: lastName: hello age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1,k2: 12&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 12 javaBean： 1234567891011121314151617181920/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * */@Component@ConfigurationProperties(prefix = "person")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 可以导入配置文件处理器，以后编写配置就有提示了 org.springframework.boot spring-boot-configuration-processor true @Value获取值和@ConfigurationProperties获取值比较| | @ConfigurationProperties | @Value || —————————— | ———————————— | ————— || 功能 | 批量注入配置文件中的属性 | 一个个指定 || 松散绑定（松散语法） | 支持 | 不支持 || SpEL | 不支持 | 支持 || JSR303数据校验 | 支持 | 不支持 || 复杂类型封装 | 支持 | 不支持 | 配置文件yml还是properties他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties；如何定义配置文件呢？1、配置类@Configuration———&gt;Spring配置文件 2、使用@Bean给容器中添加组件 12345678910111213141516/** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件 * */@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02()&#123; System.out.println("配置类@Bean给容器中添加组件了..."); return new HelloService(); &#125;&#125; 4、配置文件占位符 1、随机数 12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125; 2、占位符获取之前配置的值，如果没有可以是用:指定默认值 123456789person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 5、Profile 1、多Profile文件 我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 默认使用application.properties的配置； 2、yml支持多文档块方式 12345678910111213141516171819server: port: 8081spring: profiles: active: prod---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于哪个环境 3、激活指定profile ​ 1、在配置文件中指定 spring.profiles.active=dev ​ 2、命令行： ​ java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar —spring.profiles.active=dev； ​ 可以直接在测试的时候，配置传入命令行参数 ​ 3、虚拟机参数； ​ -Dspring.profiles.active=dev 6、配置文件加载位置springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件 –file:./config/ –file:./ –classpath:/config/ –classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； ==我们还可以通过spring.config.location来改变默认的配置文件位置== 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置； java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar —spring.config.location=G:/application.properties 7、外部配置加载顺序==SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置== 1.命令行参数 所有的配置都可以在命令行上进行指定 java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar —server.port=8087 —server.context-path=/abc 多个配置用空格分开； —配置项=值 2.来自java:comp/env的JNDI属性 3.Java系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource配置的random.*属性值 ==由jar包外向jar包内进行寻找；== ==优先加载带profile== 6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 ==再来加载不带profile== 8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件 9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件 10.@Configuration注解类上的@PropertySource 11.通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源； 参考官方文档 8、自动配置原理SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration，SpringBoot启动会加载大量的自动配置类 我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxxAutoConfigurartion：自动配置类； 给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 三、日志1、SpringBoot采用的日志框架SpringBoot选用 SLF4j和logback作为日志框架 2、统一日志框架当我们用到其他框架如mybatis等有自己的日志框架，这个时候需要进行日志框架的 统一，步骤很简单： ==1、将系统中其他日志框架先排除出去；== ==2、用中间包来替换原有的日志框架；== ==3、我们导入slf4j其他的实现== ==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；== 3、日志配置文件123456789101112131415161718//记录器Logger logger = LoggerFactory.getLogger(getClass());@Testpublic void contextLoads() &#123; //System.out.println(); //日志的级别； //由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 logger.trace("这是trace日志..."); logger.debug("这是debug日志..."); //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别 logger.info("这是info日志..."); logger.warn("这是warn日志..."); logger.error("这是error日志...");&#125; 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger{50} 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n 123456789101112131415logging.level.com.atguigu=trace#logging.path=# 不指定路径在当前项目下生成springboot.log日志# 可以指定完整的路径；#logging.file=G:/springboot.log# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件logging.path=/spring/log# 在控制台输出的日志的格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n# 指定文件中日志输出的格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n 四、springboot之web开发1、简介创建SpringBoot应用，选中我们需要的模块，SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来， 自己编写业务代码即可快速搭建web项目 2、如何看是否已自动配置这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？ xxxxAutoConfiguration：帮我们给容器中自动配置组件； xxxxProperties:配置类来封装配置文件的内容； 3、SpringBoot对静态资源的映射规则1、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；以jar包的方式引入静态资源，webjar的方式（webjar官网） 123456&lt;!--引入jquery-webjar--&gt;在访问的时候只需要写webjars下面资源的名称即可 &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; 2、”/**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射 12345&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;,&quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &quot;/&quot;：当前项目的根路径 3、欢迎页； 静态资源文件夹下的所有index.html页面；被”/“映射；4、网站的图标：所有的 /favicon.ico 都是在静态资源文件下找 4、模板引擎模板引擎就是类似我们鼠疫的jsp页面可以嵌入动态的java代码，常见的模板引擎有JSP、Velocity、Freemarker、Thymeleaf，而SpringBoot推荐的Thymeleaf，语法更简单，功能更强大1、引入thymeleaf 123456789101112 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; 2.1.6 &lt;/dependency&gt;切换thymeleaf版本&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;!-- thymeleaf2 layout1--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; 2、Thymeleaf使用只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染使用： 1、导入thymeleaf的名称空间 1&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt; 2、使用thymeleaf语法； 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为 --&gt; &lt;div th:text="$&#123;hello&#125;"&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、语法规则 5、扩展SpringMVC自动配置1234567&lt;mvc:view-controller path=&quot;/hello&quot; view-name=&quot;success&quot;/&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/hello&quot;/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; ==编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc==;既保留了所有的自动配置，也能用我们扩展的配置； 1234567891011//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125;&#125; 6、如何修改SpringBoot的默认配置模式： ​ 1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来； ​ 2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置 ​ 3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置]]></content>
      <categories>
        <category>搭建个人博客</category>
      </categories>
      <tags>
        <tag>语音</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客结合百度语音合成为你的博客添加欢迎语音]]></title>
    <url>%2F2019%2F07%2F14%2Fhexo%E5%8D%9A%E5%AE%A2%E7%BB%93%E5%90%88%E7%99%BE%E5%BA%A6%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90%E4%B8%BA%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E6%AC%A2%E8%BF%8E%E8%AF%AD%E9%9F%B3%2F</url>
    <content type="text"><![CDATA[前言今晚在知乎和CSDN看文章时都发现了文章有点击即可朗读，将文字转换成语音，虽然机器音很严重，但可以将这个用来做个人博客的一个欢迎语。也就是别人点击你博客进入的时候会自动播放这个欢迎语，有点像是你去商店买东西，迎接你的小姐姐说的“欢迎您光临本店”。是不是很炫酷？当有人访问你博客的时候，欢迎提示语。具体效果请点击（在PC端才会自动播放，客户端目前不支持自动播放，但是可以手动点击左下角的播放按钮即可体验） 为hexo博客添加APlayerAPlayer就是支持在网页播放音乐的一个库，具体怎么添加可以稍微百度下很简单，如果想省事，就复制我的博客，在主题下的source的dist下找到music.js四个参数代表的含义分别是 1234name：歌曲的名字artist：作者名字url：歌曲的外链cover：歌曲封面图片的外链 歌曲和图片外链可以在这里进行获取，这里我们做的是欢迎语，所以欢迎语的外链得从百度AI开放平台那边获取，具体怎么操作呢/ 在百度AI开放平台注册账号并获取相应的key1、注册：最好直接用自己百度账号注册2、创建应用这里我已经创建了一个应用 创建应用没什么需要注意的，按照默认的选择复选框即可。这个时候回到应用列表点开你的应用会看到标红的这两个值是接下来要用的 拼接欢迎语URL1、先获取access_token由于百度做的加密防护，先要获取access_token才可以去请求URL并且access_token（30天）后过期。需要手动刷新获取token地址： https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=这里填你的API Key(刚才获得的)&amp;client_secret=这里填你的Secret Key 返回值中就有access_token，可以用postman调用接口2、拼接URL欢迎语的URL为： 1https://tsn.baidu.com/text2audio?tex=你好呀，欢迎您光临我的博客，有问题您可以点击右下角的在线客服，我会第一时间联系您，您也可以在留言区留言或者文章底部留言&amp;lan=zh&amp;cuid=123456&amp;ctp=1&amp;tok=替换成你刚获取的access_token txt后面替换为你的欢迎语即可。赶紧试一下吧。]]></content>
      <categories>
        <category>搭建个人博客</category>
      </categories>
      <tags>
        <tag>语音</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机学习资料（含视频资料）]]></title>
    <url>%2F2019%2F07%2F14%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%EF%BC%88%E5%90%AB%E8%A7%86%E9%A2%91%E8%B5%84%E6%96%99%EF%BC%89%2F</url>
    <content type="text"><![CDATA[内容涵盖开发所需工具如eclipse、idea、maven、MySQL等、Java开发学习视频，包含多家培训机构内部视频，以及网络直播视频等，整理不易，还请点个赞再走吧！ 所有资源均为到互联网以及其他途径获取，如有侵权， 请联系作者删除，谢谢！ 一、前言内容涵盖开发所需工具如eclipse、idea、maven、MySQL等、Java开发学习视频，包含多家培训机构内部视频，以及网络直播视频等，整理不易，还请点个赞再走吧！ 所有资源均为到互联网以及其他途径获取，如有侵权， 请联系作者删除，谢谢！ 二、第一部分——工具大全篇1、eclipse123链接：https://pan.baidu.com/s/1mtV14JxYAqr_l0EDtI8QMg 提取码：ju7u 复制这段内容后打开百度网盘手机App，操作更方便哦 2、JDK8123链接：https://pan.baidu.com/s/1HVnGGgKPGUN5UVcRkhaHZQ 提取码：os0z 复制这段内容后打开百度网盘手机App，操作更方便哦 3、win-xp操作系统123链接：https://pan.baidu.com/s/1MfHJJfJchPx2lby2CyPOeA 提取码：8foc 复制这段内容后打开百度网盘手机App，操作更方便哦 4、win7操作系统123链接：https://pan.baidu.com/s/1D_uI2X4QJ0jEaRpkuAFgvA 提取码：9dhp 复制这段内容后打开百度网盘手机App，操作更方便哦 5、win10操作系统123链接：https://pan.baidu.com/s/1S7gdNQy2Q4Mt6BRmd7cbUQ 提取码：yy7q 复制这段内容后打开百度网盘手机App，操作更方便哦 6、office2016123链接：https://pan.baidu.com/s/1mbco4bQlnf_x5j4dNzPciA 提取码：tqq8 复制这段内容后打开百度网盘手机App，操作更方便哦 7、Tomcat7123链接：https://pan.baidu.com/s/1a891g8UPjDPnM5pvs7zPww 提取码：8jzt 复制这段内容后打开百度网盘手机App，操作更方便哦 8、MyEclipse123链接：https://pan.baidu.com/s/14aLA5SAGZyhzf4FoCYjDMQ 提取码：wytp 复制这段内容后打开百度网盘手机App，操作更方便哦 9、虚拟机vmware12123链接：https://pan.baidu.com/s/1WN9HKL75wpsPZZ1ZKdPcqg 提取码：gkn1 复制这段内容后打开百度网盘手机App，操作更方便哦 10、测试工具junit4.6123链接：https://pan.baidu.com/s/10eiQJJRU1V6uSjeoK56jOQ 提取码：bjaz 复制这段内容后打开百度网盘手机App，操作更方便哦 11、测试工具postman123链接：https://pan.baidu.com/s/1I_5VptOlP4-UBO0QrfBjKw 提取码：c45f 复制这段内容后打开百度网盘手机App，操作更方便哦 12、MySQL5.5.4—64位123链接：https://pan.baidu.com/s/1IaBOa9xeBNUXAuVNMmS1SQ 提取码：gip9 复制这段内容后打开百度网盘手机App，操作更方便哦 13、数据库连接工具——sqlyog123链接：https://pan.baidu.com/s/1_UWwkB2NPy0kbcEp-XMOlA 提取码：mob9 复制这段内容后打开百度网盘手机App，操作更方便哦 14、数据库连接工具——Navicat123链接：https://pan.baidu.com/s/17FMeKzJmnXXKrNF1VN6h9Q 提取码：erqv 复制这段内容后打开百度网盘手机App，操作更方便哦 15、数据库——oracle11g123链接：https://pan.baidu.com/s/1fnsAhm-uVQ6QUB3OA4H5Hw 提取码：lsiz 复制这段内容后打开百度网盘手机App，操作更方便哦 16、远程服务器连接工具SecureCAT绿色版123链接：https://pan.baidu.com/s/1p5NfFkja-BfJ5T7pWU9hbw 提取码：bc1h 复制这段内容后打开百度网盘手机App，操作更方便哦 17、版本控制工具——git123链接：https://pan.baidu.com/s/1b4pFEAtZFYVi0IMX36_h2w 提取码：v9rf 复制这段内容后打开百度网盘手机App，操作更方便哦 18、Notepad++123链接：https://pan.baidu.com/s/17DUQcS9Gkxb_viAa3yDRkQ 提取码：iwbl 复制这段内容后打开百度网盘手机App，操作更方便哦 19、免费的PDF转换器123链接：https://pan.baidu.com/s/1US5R_rPLxS1sHGqRztKVJQ 提取码：7bj3 复制这段内容后打开百度网盘手机App，操作更方便哦 20、GitHub客户端工具GitHubDesktop123链接：https://pan.baidu.com/s/1xnKr2tReAdUR-B7VOEEfFg 提取码：b7w7 复制这段内容后打开百度网盘手机App，操作更方便哦 21、Markdown编辑工具typora123链接：https://pan.baidu.com/s/1rgPtYJrbs8XwcLnXNTYTTg 提取码：8mdc 复制这段内容后打开百度网盘手机App，操作更方便哦 22、webstorm10123链接：https://pan.baidu.com/s/1dQBm4LjSbPqCc2QTYlf_pw 提取码：8cat 复制这段内容后打开百度网盘手机App，操作更方便哦 23、xftp-6123链接：https://pan.baidu.com/s/10zyGC6A8gxJW0t5g_4E3Vg 提取码：syp6 复制这段内容后打开百度网盘手机App，操作更方便哦 24、反编译工具——FrontEndPlus123链接：https://pan.baidu.com/s/1r30sBRliPlklAYoIZTMUKw 提取码：l09g 复制这段内容后打开百度网盘手机App，操作更方便哦 25、反编译工具——jsd1.5.8123链接：https://pan.baidu.com/s/10XAXohJEHNjRKL-KbdGORA 提取码：bvny 复制这段内容后打开百度网盘手机App，操作更方便哦 二、第二部分——学习视频资料篇1、黑马视频（含资料）2018年完整版 123链接：https://pan.baidu.com/s/1cNV6dwsD4bpV5Q4d17izog 提取码：9a8i 复制这段内容后打开百度网盘手机App，操作更方便哦 2016完整版 123链接：https://pan.baidu.com/s/1vyUmPkxB5iMxGt8uppYljg 提取码：0dvb 复制这段内容后打开百度网盘手机App，操作更方便哦 2、北大青鸟视频（课工场视频）（含资料）123链接：https://pan.baidu.com/s/1uFyOFySqBB9vkNdP86u7FA 提取码：wfgb 复制这段内容后打开百度网盘手机App，操作更方便哦 3、达内学习视频（含资料）123链接：https://pan.baidu.com/s/146Q9ey_08KS4axCORKbpmg 提取码：675d 复制这段内容后打开百度网盘手机App，操作更方便哦 4、尚硅谷学习视频（含资料）全套下载： 123链接：https://pan.baidu.com/s/1ngT-LSOtYxONqEZp7KVAlQ 提取码：1qjg 复制这段内容后打开百度网盘手机App，操作更方便哦 5、十次方微服务视频资料123链接：https://pan.baidu.com/s/1Tlnsp0p9uEo1phw7dOfFow 提取码：h6aw 复制这段内容后打开百度网盘手机App，操作更方便哦 6、Java高并发问题解决方案123链接：https://pan.baidu.com/s/1XWQahB-c7FQRwDZV1gfPMA 提取码：v8tq 复制这段内容后打开百度网盘手机App，操作更方便哦 三、第三部分——计算机学习资料篇1、计算机考研专业复习指导视频123链接：https://pan.baidu.com/s/1EYkT2a5_pUaiptdIHpDZ2A 提取码：8wsz 复制这段内容后打开百度网盘手机App，操作更方便哦 2、计算机领先一步基础123链接：https://pan.baidu.com/s/1trvguZkBTnnTlLZUBtO1Aw 提取码：eu1c 复制这段内容后打开百度网盘手机App，操作更方便哦 3、计算机基础课程（大学）123链接：https://pan.baidu.com/s/1iAh-KQooE3qISNMWkaS4_A 提取码：hmut 复制这段内容后打开百度网盘手机App，操作更方便哦 4、计算机强化课程123链接：https://pan.baidu.com/s/1M9fzARo8Kj6VMwmfffANSg 提取码：qvpi 复制这段内容后打开百度网盘手机App，操作更方便哦 四、第四部分——互联网面试篇1、剑指offer-java面试123链接：https://pan.baidu.com/s/1jen4Z3JTGQ2zH-ZFlZPnIQ 提取码：t3c1 复制这段内容后打开百度网盘手机App，操作更方便哦]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo在GitHub上搭建个人博客]]></title>
    <url>%2F2019%2F07%2F10%2Fhexo%E5%9C%A8GitHub%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[搭建免费个人博客并进行自定义配置，打造属于自己的个人世界。本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(入)中，欢迎有兴趣的童鞋们关注。 一、前言1、欢迎访问最新版博客：https://freestylefly.github.io// 2、主要含：搭建个人博客详细步骤，hexo的next的个性化设置目前我的博客含有的效果：标签、分类、留言、评论，在线24小时客服，卡通动漫人物、音乐自动播放、赞赏、字数统计、访问统计，自动更换背景图片、阅读量统计、linkes、归档、搜索、自定义动画、公益404、RSS、个人信息栏展示、文章目录、自定义菜单栏。。。等等，更多精彩等你发现。 3、使用github pages服务搭建博客的好处有： 123456全是静态文件，访问速度快；免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；博客内容可以轻松打包、转移、发布到其它平台；等等； 二、准备工作在开始一切之前，你必须已经： 有一个github账号，没有的话去注册一个； 安装了node.js、npm，并了解相关基础知识； 安装了git for windows（或者其它git客户端） 本文所使用的环境： Windows10 node.js@10.16.0 git@1.9.2 hexo@6.4.0 2.1、安装Node.js1node -v 2.2、安装Git和配置好Git环境安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择Git GUI Here和Git Bash Here。查看git是否安装成功，在cmd命令行中输入： 1git --version 三、在GitHub上搭建博客3.1、创建仓库新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io 了，是不是很方便？ 由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。 几个注意的地方： 123注册的邮箱一定要验证，否则不会成功；仓库名字必须是：username.github.io，其中username是你的用户名；仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效； 3.2、绑定域名当然，你不绑定域名肯定也是可以的，就用默认的 xxx.github.io 来访问，如果你想更个性一点，想拥有一个属于自己的域名，那也是OK的。 首先你要注册一个域名，域名注册以前总是推荐去godaddy，现在觉得其实国内的阿里云也挺不错的，价格也不贵，毕竟是大公司，放心！ 绑定域名分2种情况：带www和不带www的。 域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP，由于不带www方式只能采用A记录，所以必须先ping一下你的用户名.github.io的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP，将CNAME指向你的用户名.github.io，这样可以保证无论是否添加www都可以访问，如下： 然后到你的github项目根目录新建一个名为CNAME的文件（无后缀），里面填写你的域名，加不加www看你自己喜好，因为经测试： 如果你填写的是没有www的，比如 mygit.me，那么无论是访问 http://www.mygit.me 还是 http://mygit.me ，都会自动跳转到 http://mygit.me 如果你填写的是带www的，比如 www.mygit.me ，那么无论是访问 http://www.mygit.me 还是 http://mygit.me ，都会自动跳转到 http://www.mygit.me 如果你填写的是其它子域名，比如 abc.mygit.me，那么访问 http://abc.mygit.me 没问题，但是访问 http://mygit.me ，不会自动跳转到 http://abc.mygit.me 另外说一句，在你绑定了新域名之后，原来的你的用户名.github.io并没有失效，而是会自动跳转到你的新域名。 3.3 、配置SSH key为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。 1$ cd ~/. ssh #检查本机已存在的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git。 1ssh-keygen -t rsa -C &quot;邮件地址&quot; 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key： 将刚复制的内容粘贴到key那里，title随便填，保存。 3.4、测试是否成功1$ ssh -T git@github.com # 注意邮箱地址不用改 如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到： Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access. 看到这个信息说明SSH已配置成功！ 此时你还需要配置： 在博客blog目录下，右键选Git Baes Here,命令行中输入，其中的name和email替换成你自己的用户名和邮箱 12$ git config --global user.name &quot;liuxianan&quot;// 你的github用户名，非昵称$ git config --global user.email &quot;xxx@qq.com&quot;// 填写你的github注册邮箱 设置全局的签名，每次提交的时候都会有对应签名 四、使用hexo写博客4.1. hexo简介Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。 官网： http://hexo.iogithub: https://github.com/hexojs/hexo 4.2. 原理由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 4.3. 注意事项安装之前先来说几个注意事项： 很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行； hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导； hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的； 4.4、安装Hexo在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面 1$ npm install -g hexo 4.5. 初始化在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是F:\Workspaces\hexo，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。 12$ cd /f/Workspaces/hexo/$ hexo init hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图： 12$ hexo g # 生成$ hexo s # 启动服务 执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的： hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考这篇文章： http://blog.liuxianan.com/windows-port-bind.html 4.6. 修改主题既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。这是 官方主题。 个人比较喜欢的2个主题：hexo-theme-jekyll 和 hexo-theme-yilia。 首先下载这个主题： 12$ cd /f/Workspaces/hexo/$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 下载后的主题都在这里： 修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。 如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。 4.7. 上传之前在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。 4.8. 上传到github如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。 首先，ssh key肯定要配置好。 其次，配置_config.yml中有关deploy的部分： 正确写法： 1234deploy: type: git repository: git@github.com:liuxianan/liuxianan.github.io.git branch: master 错误写法： 1234deploy: type: github repository: https://github.com/liuxianan/liuxianan.github.io.git branch: master 后面一种写法是hexo2.x的写法，现在已经不行了，无论是哪种写法，此时直接执行hexo d的话一般会报如下错误： 1Deployer not found: github 或者 Deployer not found: git 原因是还需要安装一个插件： 1npm install hexo-deployer-git --save 其它命令不确定，部署这个命令一定要用git bash，否则会提示Permission denied (publickey). 打开你的git bash，输入hexo d就会将本次有改动的代码全部提交，没有改动的不会： 4.9. 保留CNAME、README.md等文件提交之后网页上一看，发现以前其它代码都没了，此时不要慌，一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的： 由于hexo默认会把所有md文件都转换成html，包括README.md，所有需要每次生成之后、上传之前，手动将README.md复制到public目录，并删除README.html。 4.10. 常用hexo命令常见命令 1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 缩写： 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 组合命令： 12hexo s -g #生成并本地预览hexo d -g #生成并上传 4.11. _config.yml这里面都是一些全局配置，每个参数的意思都比较简单明了，所以就不作详细介绍了。 需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。 4.12. 写博客定位到我们的hexo根目录，执行命令： 1hexo new &apos;my-first-blog&apos; hexo会帮我们在_posts下生成相关md文件： 我们只需要打开这个文件就可以开始写博客了，默认生成如下内容： 当然你也可以直接自己新建md文件，用这个命令的好处是帮我们自动生成了时间。 一般完整格式如下： 123456789---title: postName #文章页面上的显示名称，一般是中文date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面---以下是正文 那么hexo new page &#39;postName&#39;命令和hexo new &#39;postName&#39;有什么区别呢？ 1hexo new page &quot;my-second-blog&quot; 生成如下： 最终部署时生成：hexo\public\my-second-blog\index.html，但是它不会作为文章出现在博文目录。 4.12.1. 写博客工具可以用typora来进行博客的编写或者用CSDN的编辑器也是很不错的选择，用VScode的Markdown-toc插件来为我们的文章自动生成目录。 五、利用hexo的next主题搭建博客next主题搭建博客很帅，可以看我博客效果。 5.1 、next主题安装12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 5.2、启用主题与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。 5.3、 验证主题首先启动 Hexo 本地站点，并开启调试模式（即加上 —debug），整个命令是 hexo s —debug。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出： INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。 5.4、主题的配置在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。你可以访问 Hexo 的文档 了解如何安装 Hexo病进行 站点配置文件的配置简单的设置可以参考：NEXT中文文档NEXT主题详细配置 5.5、添加博客评论功能采用leancloud进行博客评论，具体怎么设置往下看 5.6、 添加阅读量统计请看此文 5.7、为博客添加音乐并自动播放APlayer可以实现，其中音乐外链可以在这里找到：http://www.ytmp3.cn/在这里可以找到很多歌曲的外链，然后替换成自己喜欢的歌就可以了。 5.8、添加在线联系功能当有用户在网页上给你留言后会通过邮件或者微信通知你，可以及时的解答用户的疑问。最终的效果可以参考我博客的右下角,有个聊天的按钮,效果如下所示:配置方法如下:首先到DaoVoice上注册一个账号,注册完成后会得到一个app_id，获取appid的步骤如下图所示: 以next主题为例,打开/themes/next/layout/_partials/head.swig文件添加如下 123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;) daovoice(&apos;init&apos;, &#123; app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot; &#125;); daovoice(&apos;update&apos;); &lt;/script&gt;&#123;% endif %&#125; 接着打开主题配置文件_config.yml，添加如下代码： 123# Online contact daovoice: truedaovoice_app_id: 这里输入前面获取的app_id 最后执行hexo clean &amp;&amp; hexo g &amp;&amp; hexo s就能看到效果了。 需要注意的是,next主题下聊天的按钮会和其他按钮重叠到一起，可以到聊天设置，修改下按钮的位置: 最后到右上角选择管理员，微信绑定,可以绑定你的微信号，关注公众号后打开小程序，就可以实时收发消息，有新的消息也会通过微信通知，设置页面如下:当有人在你的博客留言，微信和邮箱就可以收到相应的提示 六、参考文章1、next个性化主题配置2、Hexo的Next主题详细配置3、为NexT主题添加文章阅读量统计功能4、Hexo的NexT主题：添加来必力评论5、使用hexo+github搭建免费个人博客详细教程6、Hexo添加不蒜子和LeanCloud统计无标题文章]]></content>
      <categories>
        <category>搭建个人博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10环境下MySql（8.0.16最新版本）安装过程以及遇到的问题]]></title>
    <url>%2F2019%2F06%2F23%2Fwin10%E7%8E%AF%E5%A2%83%E4%B8%8BMySql%EF%BC%888.0.16%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%EF%BC%89%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[安装了好久各种坑，特记录一下！ 本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(ru)中，欢迎有兴趣的童鞋们关注。 目录 目录 一、前言 二、mysql的彻底卸载 三、安装mysql 四、navicat连接mysql报错1251的解决方法 五、正确连接上mysql 一、前言买了新的台式机，装了win10操作系统，打算本地安装mysql，由于之前一直用的win7，且用的mysql版本是比较老的，现在打算安装官网最新的版本8.0.16，记录一下安装过程和遇到的坑。 二、mysql的彻底卸载在安装新版本前，先要彻底卸载本机上安装的其他版本，这个地方由于我没卸载C:\ProgramData\MySQL文件夹在安装新版本的时候会报这个异常1Hostname Port and Username are as shown in figure ,and password is right.When I click Test Connection ,it show as above.But if i use 3307 in place of 3306 as port,it connect sucessfully. What matter lead that and how I fix it? 如果你也遇到安装时候的这个链接问题，那就表明机器上的mysql没有卸载干净。1》停止MySQL服务开始-》所有应用-》Windows管理工具-》服务，将MySQL服务停止。2》卸载mysql server控制面板\所有控制面板项\程序和功能，将mysql server卸载掉。3》将MySQL安装目录下的MySQL文件夹删除（我的安装目录是C:\Program Files (x86)\MySQL）4》运行“regedit”文件，打开注册表。删除HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Application\MySQL文件夹删除HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\Eventlog\Application\MySQL文件夹。删除HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Eventlog\Application\MySQL的文件夹。如果没有相应的文件夹，就不用删除了。5》删除C盘下的“C:\ProgramData\MySQL ”文件夹，如果删除不了则用360粉碎掉即可，该programData文件默认是隐藏的，设置显示后即可见，或者直接复制 C:\ProgramData 到地址栏回车即可进入！将整个MySQL文件夹删除掉。。。6》开始-》所有应用-》Windows管理工具-》服务如果已经将MySQL卸载，但通过“开始-》所有应用-》Windows管理工具-》服务”查看到MySQL服务仍然残留在系统服务里。又不想改服务名，改怎么办呢。只要在CMD里输入一条命令就可以将服务删除：sc delete mysql //这里的mysql是你要删除的服务名这样一来服务就被删除了。 然后，就可以重装MySQL数据库了！！！ 三、安装mysql这里可以参考这个博主写的，我认为已经很详细了。在开始前请看补充点https://blog.csdn.net/believesoul/article/details/79323530补充点：上面的安装步骤第九步，注意看你mysql服务的名字，可以改成mysql。所以你按照默认安装好了之后服务的名称是你默认的名称，在cmd中启动服务就要实际的服务名。查看mysql服务名方法win+R——services.msc——找到mysql服务可以看到我按照默认的服务名是mysql80，右键属性按照这个修改，否则你会连接不上win10系统下本地的mysql服务 看完这些才能去对照着安装。 四、navicat连接mysql报错1251的解决方法1、新安装的mysql8，使用破解版的navicat连接的时候一直报错，如图所示： 2、网上查找原因发现是mysql8 之前的版本中加密规则是mysql_native_password,而在mysql8之后,加密规则是caching_sha2_password, 解决问题方法有两种,一种是升级navicat驱动,一种是把mysql用户登录密码加密规则还原成mysql_native_password. 由于用的是破解版的navicat，所以只能用第二种方法解决了； 3、首先以管理员身份运行cmd，然后使用命令进入mysql。 然后输入你安装mysql是设置的root密码即可进入。进入后界面如下 注意：如果你在输入mysql -u root -p后，cmd提示mysql 不是内部或外部命令,也不是可运行的程序 或批处理文件，说明你之前安装mysql后没有在环境变量PATH中将mysql的路径添加进去。该方法在文章最后有提示； 4、然后在mysql中先更改加密方式，指令如下： ALTER USER ‘root’@’localhost’ IDENTIFIED BY ‘password’ PASSWORD EXPIRE NEVER;5、然后再更改密码，由于加密规则更改，所以需要重新设置密码； ALTER USER ‘root’@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘新密码’; 6、最后在刷新一下数据库； FLUSH PRIVILEGES;最后，写一下怎么在环境变量PATH中将mysql的路径添加进去； 1、win+r—&gt;services.msc—&gt;右击mysql服务—&gt;属性—&gt;找到可执行路径并复制出来； 2、右击“我的电脑”—&gt;属性—&gt;高级系统设置—&gt;环境变量—&gt;系统变量—&gt;PATH—&gt;编辑—&gt;新建—&gt;上面的“可执行路径”，如下图所示； 五、正确连接上mysql 六、总结 1、一定要确保本机mysql完全删除干净，否则会让你怀疑人生的，相信我 2、一定确保自己的服务名是啥 3、新版本的mysql可能并没有老版本的稳定，使用还请注意。 七、关于我-——- # 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: # 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush:]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>win10</tag>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python制作微信聊天机器人]]></title>
    <url>%2F2019%2F06%2F15%2F%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[python制作微信聊天机器人 周末心情不好搞了一个微信陪聊机器人陪我聊天。 本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(ru)中，欢迎有兴趣的童鞋们关注。 目录 目录 一、前言 二、itchat库详解 三、Python下载与安装 四、itchat库下载 五、简单示例 六、群聊 七、定时发送消息 八、集成图灵API制作聊天机器人 九、监控接收到的数据 十、验证不同信息类型和对应处理方式 十一、监控撤回信息和数据提取 十二、定时清理缓存 十三、部署到云服务器实现24小时在线陪聊 十五、成果展示 十六、关于我 一、前言由于在抖音上刷到微信机器人自动陪聊，心血来潮，自己利用itchat和图灵机器人实现了微信自动回复，监听消息，消息防撤回等。周末心情不好搞了一个微信陪聊机器人陪我聊天。 注意： 1、图灵机器人更新，对于新注册的号未认证每个号仅有2次请求，请注册后尽快完成身份认证。 2、用到了python的部分知识（不会也无关紧要），会安装即可。 3、有很多人想用自己的微信小号进行玩耍，但不幸的是，微信官方已经禁止这种行为，其实自动回复机器人本质是基于微信网页版原理实现的，也就是说很多微信小号，连微信网页版都被限制了不能登录，那么这个机器人是不会成功的。所以，首先确保微信能登上网页版。 4、关于安全问题，由于itchat是别人开发的开源库，有没有安全风险暂时不得而知。在开始测试前请确保你已知悉相应的风险。 二、itchat库详解itchat的仓库地址：https://github.com/littlecodersh/ItChat itchat是一个开源的微信个人号接口，使用python调用微信从未如此简单 使用不到三十行的代码，你就可以完成一个能够处理所有信息的微信机器人。 。。。。。 三、Python下载与安装下载地址：https://www.python.org/downloads/windows/（官网地址）下载最新版本3.7.3 点击download windows x86-64 executable installer下载windows64位exe可执行性文件 详细 下载安装步骤参考：https://blog.csdn.net/mingzhuo_126/article/details/81239156 下载完后，键盘按下win，输入python，可以看到Python3.7和IDLE Python 四、itchat库下载打开cmd或者Python3.7 1pip install itchat 查看下载成功与否 1python -c &quot;import itchat&quot; 如果没有报错信息说明你已经将实验环境安装完成。 五、简单示例通过一个简单的例子来让读者体会下通过itchat编写一个微信机器人有多简单，代码功能：扫码登录后给文件助手发送一条信息，监听接收到的文件信息，打印出来，具体代码如下。 注意：接下来的代码均在Python3.7客户端运行 12345678910111213import itchatimport time@itchat.msg_register(itchat.content.TEXT)def reply_msg(msg): print("收到一条信息：",msg.text)if __name__ == '__main__': itchat.auto_login() time.sleep(5) itchat.send("文件助手你好哦", toUserName="filehelper") itchat.run() 代码执行结果 先会弹出一个二维码图片，扫描后会登陆网页端微信，间隔一会儿后文件助手收到相关的信息 文件助手你好哦 然后用另一个账号发送一条信息给这个账号，控制台会把接收到的信息打印出来 123456789Getting uuid of QR code.Downloading QR code.Please scan the QR code to log in.Please press confirm on your phone.Loading the contact, this may take a little while.TERM environment variable not set.Login successfully as Robot PigStart auto replying.收到一条信息： 你好 通过上面8行有效代码就实现了一个简单的技巧人，酷不酷，带着这样的思路，我们可以进行扩展，比如添加一个自动回复的功能，比如在忙的时候，别人给你发信息，自动回复：”在忙，晚点给你回复信息”等。 六、群聊在微信网页端改版后，创建群聊、拉人进群和删除群聊这几个接口都用不了，现在利用itchat能做的有：查找群聊，往群聊发送信息，以及监控群聊信息，使用代码示例如下： 123456789101112131415161718192021222324import itchatimport time@itchat.msg_register(itchat.content.TEXT, isGroupChat=True)def reply_msg(msg): print("收到一条群信息：", msg['ActualNickName'], msg['Content'])def after_login(): # 获得完整的群聊列表 print("完整的群聊列表如下：") print(itchat.get_chatrooms()) # 查找特定群聊 time.sleep(10) # 通过群聊名查找 chat_rooms = itchat.search_chatrooms(name='小猪的Python学习交流群') if len(chat_rooms) &gt; 0: itchat.send_msg('测试', chat_rooms[0]['UserName'])if __name__ == '__main__': itchat.auto_login(loginCallback=after_login) itchat.run() 代码执行结果如下： 12345完整的群聊列表如下：[&lt;Chatroom: &#123;'MemberList': &lt;ContactList: []&gt;, 'Uin': 0, 'UserName': '@@60dc5027bbbb83d532aa633b8d126szcf497a98ceea5c098d2c65f0932139b88', 'NickName': '湖北人在深圳90后', 'HeadImgUrl': '/cgi-bin/mmwebwx-bin/webwxgetheadimg?seq=625714901&amp;username=@@60dc502769a783d532aa633b8d126190f497a98ceea5c098d2c65f0932139b88&amp;skey=@crypt_2d4a1972_ea00536c8ac4e35fae1c2a1c48dfe40d', 'ContactFlag': 3, 'MemberCount': 82, 'RemarkName': '', 'HideInputBarFlag': 0, 'Sex': 0, 'Signature': '', 'VerifyFlag': 0, 'OwnerUin': 0, 'PYInitial': 'HBRZSZ90H', 'PYQuanPin': 'hubeirenzaishenzhen90hou', 'RemarkPYInitial': '', 'RemarkPYQuanPin': '', 'StarFriend': 0, 'AppAccountFlag': 0, 'Statues': 0, 'AttrStatus': 0, 'Province': '', 'City': '', 'Alias': '', 'SnsFlag': 0, 'UniFriend': 0, 'DisplayName': '', 'ChatRoomId': 0, 'KeyWord': '', 'EncryChatRoomId': '', 'IsOwner': 0, 'IsAdmin': None, 'Self': &lt;User: &#123;'MemberList': &lt;ContactList: []&gt;, 'UserName': '@29b9cb6386352503319f411754e7424e383ae09e50a224feca754a4516db6a13', 'City': '', 'DisplayName': '', 'PYQuanPin': '', 'RemarkPYInitial': '', 'Province': '', 'KeyWord': '', 'RemarkName': '', 'PYInitial': '', 'EncryChatRoomId': '', 'Alias': '', 'Signature': '(´v｀o)♡', 'NickName': 'Robot Pig', 'RemarkPYQuanPin': '', 'HeadImgUrl': '/cgi-bin/mmwebwx-bin/webwxgeticon?seq=275167114&amp;username=@29b9cb6386352503319f411754e7424e383ae09e50a224feca754a4516db6a13&amp;skey=@crypt_2d4a1972_ea00536c8ac4e35fae1c2a1c48dfe40d', 'UniFriend': 0, 'Sex': 2, 'AppAccountFlag': 0, 'VerifyFlag': 0, 'ChatRoomId': 0, 'HideInputBarFlag': 0, 'AttrStatus': 0, 'SnsFlag': 1, 'MemberCount': 0, 'OwnerUin': 0, 'ContactFlag': 0, 'Uin': 3454488193, 'StarFriend': 0, 'Statues': 0, 'WebWxPluginSwitch': 0, 'HeadImgFlag': 1&#125;&gt;&#125;&gt; 内容过多省略... ]收到一条群信息： 培杰 123收到一条群信息： 培杰 你好 另外，群聊除了通过群名搜索外还可以通过username来查找，或者两者搭配使用；在msg里有一个isAt字段，可用于判断是否被人@了 使用方式和群聊的非常类似，搜索公众号方法search_mps，监听公众号信息添加isMpChat=True元素，使用代码示例如下： 123456789101112131415161718import itchat@itchat.msg_register(itchat.content.TEXT, isMpChat=True)def reply_msg(msg): print("收到一条公众号信息：", msg['User']['NickName'], msg['Content'])def login_after(): mps = itchat.search_mps(name='CoderPig') if len(mps) &gt; 0: print(mps) itchat.send_msg('人生苦短', toUserName=mps[0]['UserName'])if __name__ == '__main__': itchat.auto_login(loginCallback=login_after) itchat.run() 代码执行结果如下： 123[&lt;MassivePlatform: &#123;'MemberList': &lt;ContactList: []&gt;, 'Uin': 0, 'UserName': '@07585e92f75be7320e49627cf0c3ad43', 'NickName': 'CoderPig', 'HeadImgUrl': '/cgi-bin/mmwebwx-bin/webwxgeticon?seq=610904174&amp;username=@07585e92f75be7320e49627cf0c3ad43&amp;skey=@crypt_2d4a1972_bc443bf966f94fa11f2db8f812e456cf', 'ContactFlag': 3, 'MemberCount': 0, 'RemarkName': '', 'HideInputBarFlag': 0, 'Sex': 0, 'Signature': '一枚咸鱼Android开发，会点Python，分享点学习经验，总结，鸡汤，读书笔记，生活技巧', 'VerifyFlag': 8, 'OwnerUin': 0, 'PYInitial': 'CODERPIG', 'PYQuanPin': 'CoderPig', 'RemarkPYInitial': '', 'RemarkPYQuanPin': '', 'StarFriend': 0, 'AppAccountFlag': 0, 'Statues': 0, 'AttrStatus': 0, 'Province': '广东', 'City': '深圳', 'Alias': '', 'SnsFlag': 0, 'UniFriend': 0, 'DisplayName': '', 'ChatRoomId': 0, 'KeyWord': 'gh_', 'EncryChatRoomId': '', 'IsOwner': 0&#125;&gt;]收到一条公众号信息： CoderPig 我用Python 七、定时发送消息定时发送信息这个操作在日常生活中非常实用，比如给别人发生日或者节日祝福，晚上12点准时发，如果有早睡习惯的要熬到12点就很难受了，我们可以利用itchat编写一个简单的定时发送信息脚本。这里我们用到一个apscheduler定时调度任务模块，在命令行键入pip install apscheduler即可完成安装。这里并不会详细讲解，有兴趣的可移步到官方文档自行查阅：http://apscheduler.readthedocs.io/en/latest/userguide.html 1234567891011121314151617181920212223242526import itchatfrom apscheduler.schedulers.blocking import BlockingSchedulerimport time# 发送信息def send_msg(): user_info = itchat.search_friends(name='培杰') if len(user_info) &gt; 0: user_name = user_info[0]['UserName'] itchat.send_msg('生日快乐哦！', toUserName=user_name)def after_login(): sched.add_job(send_msg, 'cron', year=2018, month=7, day=28, hour=16, minute=5, second=30) sched.start()def after_logout(): sched.shutdown()if __name__ == '__main__': sched = BlockingScheduler() itchat.auto_login(loginCallback=after_login, exitCallback=after_login) itchat.run() 这个可以用来撩妹最不错了，每天定时的早安晚安，绝对一秒都不会落 八、集成图灵API制作聊天机器人图灵机器人官网：http://www.tuling123.com/member/robot/index.jhtml 注册一个账号后，点击创建机器人，由于最近刚刚整改，必须经过实名认证才可以调用 在调用前可以在postman里面测试一下图灵机器人的魔力。测试可以参考官方文档： https://www.kancloud.cn/turing/www-tuling123-com/718227 注册一个账号后，点击创建机器人，会弹出如图所示的面板，按需配置下即可。 这里记下apikey调用接口用的秘钥。 具体代码实现如下： 12345678910111213141516171819202122import itchatimport requestsdef get_response(_info): print(_info) # 从好友发过来的消息 api_url = 'http://www.tuling123.com/openapi/api' # 图灵机器人网址 data = &#123; 'key': '这里写apiKey', # 如果这个 apiKey 如不能用，那就注册一次 'info': _info, # 这是我们从好友接收到的消息 然后转发给图灵机器人 'userid': 'wechat-robot', # 这里你想改什么都可以 &#125; r = requests.post(api_url, data=data).json() # 把data数据发 print(r.get('text')) # 机器人回复给好友的消息 return r @itchat.msg_register(itchat.content.TEXT)def text_reply(msg): return "【我是天才^_^】" + get_response(msg["Text"])["text"] if __name__ == '__main__': itchat.auto_login(hotReload=True,enableCmdQR=2) # hotReload = True, 保持在线，下次运行代码可自动登录,可以添加enableCmdQR=True参数，让二维码显示到命令行上，另外部分系统可能字符宽度有出入，可以通过把enableCmdQR赋值为特定的倍数进行调整。如设置值为2 itchat.run() 九、监控接收到的数据先是监控信息，信息又分为好友聊天和群聊，我们编写代码来监控下收到的数据是怎么样的？ 12345678910111213141516171819import itchatfrom itchat.content import *# 好友信息监听@itchat.msg_register([TEXT, PICTURE, RECORDING, ATTACHMENT, VIDEO], isFriendChat=True)def handle_friend_msg(msg): print("好友信息: ", msg)# 群聊信息监听@itchat.msg_register([TEXT, PICTURE, RECORDING, ATTACHMENT, VIDEO], isGroupChat=True)def information(msg): print("群聊信息: ", msg)if __name__ == '__main__': itchat.auto_login() itchat.run() 给机器人发送一条信息，还有往群聊里发送一条信息，查看打印的信息内容，先是好友信息 1好友信息: &#123;'MsgId': '5500935424291030814', 'FromUserName': '@8fd8b5b2bd0862ed5d0d573bc6c08362', 'ToUserName': '@913c3124d973db6ae25924bd0598b48a0028e0c2d01e18d8095cc6fd58db116b', 'MsgType': 1, 'Content': '123', 'Status': 3, 'ImgStatus': 1, 'CreateTime': 1533010285, 'VoiceLength': 0, 'PlayLength': 0, 'FileName': '', 'FileSize': '', 'MediaId': '', 'Url': '', 'AppMsgType': 0, 'StatusNotifyCode': 0, 'StatusNotifyUserName': '', 'RecommendInfo': &#123;'UserName': '', 'NickName': '', 'QQNum': 0, 'Province': '', 'City': '', 'Content': '', 'Signature': '', 'Alias': '', 'Scene': 0, 'VerifyFlag': 0, 'AttrStatus': 0, 'Sex': 0, 'Ticket': '', 'OpCode': 0&#125;, 'ForwardFlag': 0, 'AppInfo': &#123;'AppID': '', 'Type': 0&#125;, 'HasProductId': 0, 'Ticket': '', 'ImgHeight': 0, 'ImgWidth': 0, 'SubMsgType': 0, 'NewMsgId': 5500935424291030814, 'OriContent': '', 'EncryFileName': '', 'User': &lt;User: &#123;'MemberList': &lt;ContactList: []&gt;, 'Uin': 0, 'UserName': '@8fd8b5b2bd0862ed5d0d573bc6c08362', 'NickName': 'CoderPig', 'HeadImgUrl': '/cgi-bin/mmwebwx-bin/webwxgeticon?seq=625711027&amp;username=@8fd8b5b2bd0862ed5d0d573bc6c08362&amp;skey=@crypt_2d4a1972_26dc3be99a177455b82518b3ca6e6cc5', 'ContactFlag': 3, 'MemberCount': 0, 'RemarkName': '', 'HideInputBarFlag': 0, 'Sex': 1, 'Signature': '不服气，就用行动去证明，少说多做...2018.7.29', 'VerifyFlag': 0, 'OwnerUin': 0, 'PYInitial': 'CODERPIG', 'PYQuanPin': 'CoderPig', 'RemarkPYInitial': '', 'RemarkPYQuanPin': '', 'StarFriend': 0, 'AppAccountFlag': 0, 'Statues': 0, 'AttrStatus': 33783847, 'Province': '广东', 'City': '江门', 'Alias': '', 'SnsFlag': 17, 'UniFriend': 0, 'DisplayName': '', 'ChatRoomId': 0, 'KeyWord': 'zpj', 'EncryChatRoomId': '', 'IsOwner': 0&#125;&gt;, 'Type': 'Text', 'Text': '123'&#125; 分析下要采集的数据，MsgId（微信信息的标识，用来作为键），NickName（发送者的用户名），Content（信息内容），CreateTime（创建时间）， Type（信息类型）。接着是群聊信息： 1群聊信息: &#123;'MsgId': '3177606925001563512', 'FromUserName': '@@16521484d35b2fe9c953282d98ec4f11456607924b3a7cc6d7fb671fe7e3081c', 'ToUserName': '@913c3124d973db6ae25924bd0598b48a0028e0c2d01e18d8095cc6fd58db116b', 'MsgType': 1, 'Content': '嘿嘿', 'Status': 3, 'ImgStatus': 1, 'CreateTime': 1533010298, 'VoiceLength': 0, 'PlayLength': 0, 'FileName': '', 'FileSize': '', 'MediaId': '', 'Url': '', 'AppMsgType': 0, 'StatusNotifyCode': 0, 'StatusNotifyUserName': '', 'RecommendInfo': &#123;'UserName': '', 'NickName': '', 'QQNum': 0, 'Province': '', 'City': '', 'Content': '', 'Signature': '', 'Alias': '', 'Scene': 0, 'VerifyFlag': 0, 'AttrStatus': 0, 'Sex': 0, 'Ticket': '', 'OpCode': 0&#125;, 'ForwardFlag': 0, 'AppInfo': &#123;'AppID': '', 'Type': 0&#125;, 'HasProductId': 0, 'Ticket': '', 'ImgHeight': 0, 'ImgWidth': 0, 'SubMsgType': 0, 'NewMsgId': 3177606925001563512, 'OriContent': '', 'EncryFileName': '', 'ActualNickName': '易♂建♂联', 'IsAt': False, 'ActualUserName': '@8fd8b5b2bd0862ed5d0d573bc6c08362', 'User': 同样分析下要采集的数据，MsgId（微信信息的标识），ActualNickName（发送者群名称），Content（信息内容），CreateTime（创建时间）， Type（信息类型）。改下我们的程序，把这些都提取打印出来。 1234567891011121314151617181920212223242526272829import itchatfrom itchat.content import *# 好友信息监听@itchat.msg_register([TEXT, PICTURE, RECORDING, ATTACHMENT, VIDEO], isFriendChat=True)def handle_friend_msg(msg): msg_id = msg['MsgId'] msg_from_user = msg['User']['NickName'] msg_content = msg['Content'] msg_create_time = msg['CreateTime'] msg_type = msg['Type'] print("收到信息: ", msg_id, msg_from_user, msg_content, msg_create_time,msg_type)# 群聊信息监听@itchat.msg_register([TEXT, PICTURE, RECORDING, ATTACHMENT, VIDEO], isGroupChat=True)def information(msg): msg_id = msg['MsgId'] msg_from_user = msg['ActualNickName'] msg_content = msg['Content'] msg_create_time = msg['CreateTime'] msg_type = msg['Type'] print("群聊信息: ",msg_id, msg_from_user, msg_content, msg_create_time,msg_type)if __name__ == '__main__': itchat.auto_login() itchat.run() 代码执行结果如下： 1234群聊信息: 2254622820807367335 胡小韬 对手公司 1533023277 Text群聊信息: 1765614482944449471 xia_ang 还有自干五 1533023285 Text好友信息: 615083621872361432 CoderPig 哈哈 1533023293 Text好友信息: 7292909308782687092 CoderPig 你好哦 1533023302 Text 十、验证不同信息类型和对应处理方式嗯，信息提取成功，接下来要验证的是不同的信息类型和对应的处理方式，文字，图片(表情)，音频，视频，文件五种，后面四种都需要下载到本地，itchat中提供了一个下载文件的方法msg‘Text’，调用这个方法即可完成文件下载，修改后的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import itchatfrom itchat.content import *import osimport time# 文件临时存储页rec_tmp_dir = os.path.join(os.getcwd(), 'tmp/')# 存储数据的字典rec_msg_dict = &#123;&#125;# 好友信息监听@itchat.msg_register([TEXT, PICTURE, RECORDING, ATTACHMENT, VIDEO], isFriendChat=True)def handle_friend_msg(msg): msg_id = msg['MsgId'] msg_from_user = msg['User']['NickName'] msg_content = '' # 收到信息的时间 msg_time_rec = time.strftime("%Y-%m-%d %H:%M%S", time.localtime()) msg_create_time = msg['CreateTime'] msg_type = msg['Type'] if msg['Type'] == 'Text': msg_content = msg['Content'] elif msg['Type'] == 'Picture' \ or msg['Type'] == 'Recording' \ or msg['Type'] == 'Video' \ or msg['Type'] == 'Attachment': msg_content = r"" + msg['FileName'] msg['Text'](rec_tmp_dir + msg['FileName']) rec_msg_dict.update(&#123; msg_id: &#123; 'msg_from_user': msg_from_user, 'msg_time_rec': msg_time_rec, 'msg_create_time': msg_create_time, 'msg_type': msg_type, 'msg_content': msg_content &#125; &#125;) print(msg)# 群聊信息监听@itchat.msg_register([TEXT, PICTURE, RECORDING, ATTACHMENT, VIDEO], isGroupChat=True)def information(msg): msg_id = msg['MsgId'] msg_from_user = msg['ActualNickName'] msg_content = '' # 收到信息的时间 msg_time_rec = time.strftime("%Y-%m-%d %H:%M%S", time.localtime()) msg_create_time = msg['CreateTime'] msg_type = msg['Type'] if msg['Type'] == 'Text': msg_content = msg['Content'] elif msg['Type'] == 'Picture' \ or msg['Type'] == 'Recording' \ or msg['Type'] == 'Video' \ or msg['Type'] == 'Attachment': msg_content = r"" + msg['FileName'] msg['Text'](rec_tmp_dir + msg['FileName']) rec_msg_dict.update(&#123; msg_id: &#123; 'msg_from_user': msg_from_user, 'msg_time_rec': msg_time_rec, 'msg_create_time': msg_create_time, 'msg_type': msg_type, 'msg_content': msg_content &#125; &#125;) print(msg)if __name__ == '__main__': if not os.path.exists(rec_tmp_dir): os.mkdir(rec_tmp_dir) itchat.auto_login() itchat.run() 十一、监控撤回信息和数据提取接着到撤回信息的监控，撤回的信息类型是NOTE，我们监听下看看，看看撤回的信息具体内容。 1&#123;'MsgId': '7399110162640182490', 'FromUserName': '@9c1a8bf4e28771a6b3ab635991dea2a1', 'ToUserName': '@49d1d90b90371099297a08da1009f3cdd042f21194239ef47b60e8f0b52e4553', 'MsgType': 10002, 'Content': '&lt;sysmsg type="revokemsg"&gt;&lt;revokemsg&gt;&lt;session&gt;zpj779878443&lt;/session&gt;&lt;oldmsgid&gt;1625723544&lt;/oldmsgid&gt;&lt;msgid&gt;3154925139554625499&lt;/msgid&gt;&lt;replacemsg&gt;&lt;![CDATA["CoderPig" 撤回了一条消息]]&gt;&lt;/replacemsg&gt;&lt;/revokemsg&gt;&lt;/sysmsg&gt;', 'Status': 4, 'ImgStatus': 1, 'CreateTime': 1533103679, 'VoiceLength': 0, 'PlayLength': 0, 'FileName': '', 'FileSize': '', 'MediaId': '', 'Url': '', 'AppMsgType': 0, 'StatusNotifyCode': 0, 'StatusNotifyUserName': '', 'RecommendInfo': &#123;'UserName': '', 'NickName': '', 'QQNum': 0, 'Province': '', 'City': '', 'Content': '', 'Signature': '', 'Alias': '', 'Scene': 0, 'VerifyFlag': 0, 'AttrStatus': 0, 'Sex': 0, 'Ticket': '', 'OpCode': 0&#125;, 'ForwardFlag': 0, 'AppInfo': &#123;'AppID': '', 'Type': 0&#125;, 'HasProductId': 0, 'Ticket': '', 'ImgHeight': 0, 'ImgWidth': 0, 'SubMsgType': 0, 'NewMsgId': 7399110162640182490, 'OriContent': '', 'EncryFileName': '', 'User': &lt;User: &#123;'MemberList': &lt;ContactList: []&gt;, 'Uin': 0, 'UserName': '@9c1a8bf4e28771a6b3ab635991dea2a1', 'NickName': 'CoderPig', 'HeadImgUrl': '/cgi-bin/mmwebwx-bin/webwxgeticon?seq=625711027&amp;username=@9c1a8bf4e28771a6b3ab635991dea2a1&amp;skey=@crypt_2d4a1972_e0963a9b961045c2e06293043f1c98a8', 'ContactFlag': 3, 'MemberCount': 0, 'RemarkName': '', 'HideInputBarFlag': 0, 'Sex': 1, 'Signature': '不服气，就用行动去证明，少说多做...2018.7.29', 'VerifyFlag': 0, 'OwnerUin': 0, 'PYInitial': 'CODERPIG', 'PYQuanPin': 'CoderPig', 'RemarkPYInitial': '', 'RemarkPYQuanPin': '', 'StarFriend': 0, 'AppAccountFlag': 0, 'Statues': 0, 'AttrStatus': 33783847, 'Province': '广东', 'City': '江门', 'Alias': '', 'SnsFlag': 17, 'UniFriend': 0, 'DisplayName': '', 'ChatRoomId': 0, 'KeyWord': 'zpj', 'EncryChatRoomId': '', 'IsOwner': 0&#125;&gt;, 'Type': 'Note', 'Text': '"CoderPig" 撤回了一条消息'&#125; 首先是判断系统信息是默认撤回了一条信息，内容是： 显示判断是否是撤回的信息，从上面可以看到这样的串字符串：&lt;![CDATA[“CoderPig” 撤回了一条消息]]&gt;，我们只需要写个正则判断是否有这样的内容，有说明是撤回的信息提醒，接着找撤回的信息MsgId，在上面这串信息的前面就是了：3154925139554625499，同样用正则提取。接着要做的就是拿着MsgId去查存消息的字典，根据信息类型拼接文字或文字加文件，然后发送给文件传输助手。具体代码如下：！ 1234567891011121314151617181920@itchat.msg_register([NOTE], isFriendChat=True, isGroupChat=True)def revoke_msg(msg): if revoke_msg_compile.search(msg['Content']) is not None: old_msg_id = extract_msgid_compile.search(msg['Content']).group(1) old_msg = rec_msg_dict.get(old_msg_id, &#123;&#125;) # 先发送一条文字信息 itchat.send_msg(str(old_msg.get('msg_from_user') + "撤回了一条信息：" + old_msg.get('msg_content')), toUserName="filehelper") # 判断文msg_content是否存在，不存在说明可能是 if os.path.exists(os.path.join(rec_tmp_dir, old_msg.get('msg_content'))): if old_msg.get('msg_type') == 'Picture': itchat.send_image(os.path.join(rec_tmp_dir, old_msg.get('msg_content')), toUserName="filehelper") elif old_msg.get('msg_type') == 'Video': itchat.send_video(os.path.join(rec_tmp_dir, old_msg.get('msg_content')), toUserName="filehelper") elif old_msg.get('msg_type') == 'Attachment' \ or old_msg.get('msg_type') == 'Recording': itchat.send_file(os.path.join(rec_tmp_dir, old_msg.get('msg_content')), toUserName="filehelper") 十二、定时清理缓存另外，我们的信息都是用一个字典存着的，时间长了的话，数据会很多，而且图片文件这些会越攒越多，我们可以添加一个定时任务，比如每隔五分钟清理一下创建时长超过2分钟的信息和对应的文件。相关代码如下： 1234567891011121314151617181920212223242526272829303132# 每隔五种分钟执行一次清理任务def clear_cache(): # 当前时间 cur_time = time.time() # 遍历字典，如果有创建时间超过2分钟(120s)的记录，删除，非文本的话，连文件也删除 for key in list(rec_msg_dict.keys()): if int(cur_time) - int(rec_msg_dict.get(key).get('msg_create_time')) &gt; 120: if not rec_msg_dict.get(key).get('msg_type') == 'Text': file_path = os.path.join(rec_tmp_dir, rec_msg_dict.get(key).get('msg_content')) print(file_path) if os.path.exists(file_path): os.remove(file_path) rec_msg_dict.pop(key)# 开始轮询任务def start_schedule(): sched.add_job(clear_cache, 'interval', minutes=2) sched.start()# 退出停止所有任务并清空缓存文件夹def after_logout(): sched.shutdown() shutil.rmtree(rec_tmp_dir)if __name__ == '__main__': sched = BlockingScheduler() if not os.path.exists(rec_tmp_dir): os.mkdir(rec_tmp_dir) itchat.auto_login(exitCallback=after_logout) itchat.run(blockThread=False) start_schedule() 感谢： https://blog.csdn.net/fxbin123/article/details/80428216 https://www.kancloud.cn/turing/www-tuling123-com/718227 https://www.cnblogs.com/sunshine-long/p/8522175.html https://www.shiyanlou.com/courses/684/labs/2237/document/#%E4%B8%80%E3%80%81%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D https://github.com/littlecodersh/ItChat https://blog.csdn.net/coder_pig/article/details/81357810#commentsedit 十三、部署到云服务器实现24小时在线陪聊以上都是在本地进行测试，电脑不可能24小时开着，浪费电浪费钱。故讲本脚本上云。即上云服务器。1、百度云服务器我购买的是百度云服务器，采用新注册的账号，有折扣活动，三个月五十几，配置1核1G，已经完全够用，系统是CentOs7，里面自带的python版本是2.7（如非特殊需要，可以暂时不用下载最新版的python，我就是因为想下载最新版本的python，结果搞来搞去，把服务器搞坏了，打电话给了百度云客服，工程师很快给我解决了，我重新安装了下系统后决定用系统自带的python版本，几步轻松搞定）。 2、服务器默认是没有安装pip的，所以先要安装pip 123$ wget https://bootstrap.pypa.io/get-pip.py$ python get-pip.py$ pip -V #查看pip版本 接下来就可以随便pip安装东西了按照上面的步骤安装itchat，登录的时候，可以添加enableCmdQR=True参数，让二维码显示到命令行上，另外部分系统可能字符宽度有出入，可以通过把enableCmdQR赋值为特定的倍数进行调整（我设置的是2）。 3、讲脚本保存为.py文件下载资源：评论留“我要资源” ，即可，我会发给你或者直接点击：下载资源PS：资源理论上是可以直接运行的，如果有不能运行的情况欢迎咨询我。 十五、成果展示 十六、关于我-——- # 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: # 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush:]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>聊天</tag>
        <tag>机器人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解忧杂货店]]></title>
    <url>%2F2019%2F05%2F04%2F%E8%A7%A3%E5%BF%A7%E6%9D%82%E8%B4%A7%E5%BA%97%2F</url>
    <content type="text"><![CDATA[我衷心祈祷你可以相信自己，无悔的燃烧自己的人生。 本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(ru)中，欢迎有兴趣的童鞋们关注。 前言现在是公元2019年的五月四日，距离五四革命运动刚好一百年。…… 每一次都以时间作为开场白似乎已成了惯用的手法，没有别的原因，实则是因为想记录一下时间尔尔。 正文今年的五一格外不同，有整整四天的假期，据说是国家领导人为了响应民众的号召而特意多了一天的假。对于那些迫切归家之人亦或是有远行游玩计划或者有伴侣相约之人，这着实是个好消息。 假期到来的前一个月，我想了很久，也没有找到四天该去哪里，该如何度过。想过远游，却被一个人出游的种种原因给打败。我是什么时候开始，竟会如此的害怕孤独？ 16年的国庆，背起背包，来到北京，见了天安门，爬了长城。。。 却再也找不回当初那种冲动和感觉，或许，人越长大就越怕孤独吧。 五月一日，下午一点多从睡梦中醒来，昨晚估计玩王者玩到了三四点，并不是游戏有多好玩，只是觉得每一次死亡后又可以指定时间复活，好像是生命经过重生一样。两点出门，去门店随便买了一个背包，吃了一碗酸辣粉。坐在一个角落看着熙攘的人群，发小群时不时的 蹦出的狗粮，却没有一丝情绪，仍然照常劝好友将女朋友拉进那个昔日只有我们三个单身狗的群，并发了一个大大的红包，在群里窥探着两队情侣们的日常，并时不时给吵架闹小脾气的他们出谋划策，像极了话剧里的小丑，但此时的我却波澜不惊。之后爬了莲花山，山太低，一口气就到了山顶，见了小平爷爷，回走的路上见到了一大片的草坪，里面一群大人小孩在放着风筝，很美， 想当初我也是追风筝的人啊，就像阿米尔一样，充满了弱小和恐惧恐怕永远也追不到那个想要的风筝吧！ 等突然发现，天黑了下来，找了购物公园，却发现高德地图给我导航去了一个所谓的购物公园，这不就是在地下摆的集市吗？和我想象的差距过大，转了一圈，想买条特价皮带，被人说瘦瘦瘦，真想骂人，凭什么对别人的身材外貌进行指指点点，不知为何，当时情绪化超级严重： 感从小就被冠以瘦小的身份出席在大众面前，每一次爸妈带我出去买衣服也好，摆放亲戚也罢，都会被人以为是低自己实际年龄好几岁的孩子，从小的不自信仿佛一下子暴露，去你妈吧，管你什么事，管好你自己吧。 ——当时的想法 晚上回来不知是中了什么疯，为了一个白送的手机，充了三千多的话费，这恐怕是做的嘴傻的一次吧，明明知道是坑，硬是往里跳。… 可能因为心情太糟糕了吧，手机也定好给妈妈用，可是又得背负欠款了。 五月三日，去了深圳湾，一出地铁就见到海，绝对是让人很开心的一刻。 五月四号，看完了《解忧杂货店》，被里面故事魂牵梦绕，很多事冥冥之中自有安排一样，很多的烦扰忧愁其实心中早有了答案，差的只是那个愿意倾听并给你出不了没什么实质性建议的人，一个邻近八旬的老人和三个小偷也能在给别人解忧的过程中找到自己的价值所在，活着，有时候，就是要分享，倾听，才能体会自己的价值。 很多技术的东西看看资料就可以很快明白，但是价值观以及涉及到人文层面的却越来越少人愿意去深究，是的，大家都太忙了，哪有时间。 其实，说实话，这几天真的很孤独，有时候真想有个人在身边，还是没能很好的和自己相处。 最后，引用《解忧杂货店》里的最后一句作为文章的结尾 123我衷心祈祷你可以相信自己，无悔的燃烧自己的人生。 ——东野圭吾《解忧杂货店》]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对生命的感想]]></title>
    <url>%2F2019%2F04%2F21%2F%E5%AF%B9%E7%94%9F%E5%91%BD%E7%9A%84%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[生命是如此的脆弱！ 现在是2019年4月20号晚十一五十九，离明天只剩下半分钟不到，。距离上次更新，又已是一个多月有余。 今天抽出时间追了一部国漫《镇魂街》，惊叹和感动。主人公的话语一直在耳边缠绕，这世界有很多在某一个领域表现很优秀的人，人们习惯称呼这些人为天才，其实哪真有那么多的天才，很多时候只不过在你看不到的地方，那些人在他所在的领域点付出的是无数的时间和努力，一直向着一个目标坚定不移。你总是找借口逃避，却不知道，有多少人，在你选择逃避的时候，已是成倍的努力…… 今天听到一个噩耗，一向很阳光的女孩也会被上帝所抛弃，没想到，这种事发生在自己身边，以前根本感觉不到哪有那么多什么人间不值得，你压根就不知道，有些人光活着就已经是努力的一塌糊涂，压根你替换不到那种绝望。 此刻，坐标在深圳一个小单间出租房的我，并不想用苍白无力的语言去祈祷甚，因为我觉得自己不配。 我们的生命是如此的脆弱，明天和意外哪一个会先来，你根本无法控制，在有限的生命里，可我们并不知道珍惜，！一旦真的快失去的那一天，才后悔很多想去的地方都没去，很多想爱的人没有去爱，很多的梦想还在笔记本上清晰的写着。 记得初次学程序的时候，学的第一个就是“”hello world“，你好，世界！ ” 你好，世界！在失去前，只有不断的付出和分享，将知识、四位、想法、观念分享、输出到全世界，给不同的人看，；去不同的地方，体会不同的生活，感受不同的风景，接触不同的人，去爱身边的人，去爱和保护自己的家人，去经历，去成长，去变老…… 活在当下，莫道轮回，就是对生命最大的尊重。 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea 下新建的 spring boot 项目,无法导入依赖以及 idea 基础回顾]]></title>
    <url>%2F2019%2F04%2F20%2Fidea%E4%B8%8B%E6%96%B0%E5%BB%BA%E7%9A%84spring%20boot%E9%A1%B9%E7%9B%AE%2C%E6%97%A0%E6%B3%95%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96%E4%BB%A5%E5%8F%8Aidea%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[最近在整springboot项目时，依赖在idea中老师无法导入，最终找到问题，并补充idea知识！ 本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(ru)中，欢迎有兴趣的童鞋们关注。 一、问题描述最近在idea中导入spring boot项目的依赖时，无论怎么也无法导入依赖，如图所示：总是显示：Project ‘org.springframework.boot:spring-boot-starter-parent:1.5.9.RELEASE’ not found一开始以为是maven配置的不对，重新修改配置还是不对 二、问题解决原来是因为每次用idea新建项目, 二进制版本都是1.5或1.6。只需要修改settings——build Execution Deploment——Compler——java Compler里面修改，如图：修改成JDK1.8即可，刚开始默认是1.5的，也不知道为啥1.5就不能自动导入项目需要的依赖。反正问题就解决了。 三、补充idea基础1、进入settings，目录结构 2、设置主题这里默认提供了三套主题：IntelliJ，Darcula，Windows。这里可以根据自己的喜好进行选择。 3、设置窗体及菜单的字体及字体大小 4、Ctrl + 鼠标滚轮 快捷键来控制代码字体大小显示 5、设置鼠标悬浮提示 6、设置自动导包功能Add unambiguous imports on the fly：自动导入不明确的结构Optimize imports on the fly：自动帮我们优化导入的包# 7、设置显示行号和方法间的分隔符如上图红圈所示，可以勾选 Show line numbers：显示行数。我建议一般这个要勾选上如上图红圈所示，可以勾选 Show method separators： 显示方法分隔线。这种线有助于我们区分开方法，所以建议勾选上 8、忽略大小写提示 9、设置取消单行显示 tabs 的操作 10、设置默认的字体、字体大小、字体行间距 11、修改类头的文档注释信息 12、设置项目文件编码 四、关于我 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>eclipse</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[倾听我的心声]]></title>
    <url>%2F2019%2F04%2F14%2F%E5%80%BE%E5%90%AC%E6%88%91%E7%9A%84%E5%BF%83%E5%A3%B0%2F</url>
    <content type="text"><![CDATA[记录点滴，记录美好，记录生活！ 回忆我和她互相淡然的说出：“今天已经分手两个月了。”两个月前的今天，也是今年的情人节，我们在电影院看完了《流浪地球》，她哭着和我分了手，因为种种原因，不知是我不值得还是没法反抗，反正就这么戏剧性的开始又戏剧性的结束了。 我深深记得两个月前的夜晚，我哭的像个孩子，或许是我这二十多年第一次流这么多眼泪，三年的感情仿佛在那一瞬间都浮现。我想，我倒现在还是没好的 感想现在是19年的4月14日晚十一点三十，距离上一次写作已有大半年时光，每一次拿起笔又放下，或因无话可说，或因懒惰成疾，生活慢慢稳定下来，却发现，以前有的东西防毒都已不见，生活还是那个生活，但一切又都不一样了！ 我觉得自己一直不够理性，总是感性的容易多愁善感，就像现在，我脑子里蹦出无数个孤独的字眼，其实并不是在大城市的角落才会有这种感觉吧，仿佛自己像是在一个单人的星球。两天的休息，做了什么呢？吃了一只鸡？还是王者上了星耀？ 仿佛这些都是值得高兴的事情，但是发现，分享喜悦的人都走了，仿佛得到了，也没那么开心！ 和朋友们吃虾喝酒，没有醉醺醺的瞬间才会让人没有尽兴。 因为人没醉，心就没死！ &lt;/p&gt;&lt;/p&gt; 生活生活，这种哲学性的问题，我这种人又怎么敢轻易去下结论呢？朋友的朋友查出身体有问题，这个本该能惊醒我要好好珍惜生活，爱惜自己的身体，可是，我却还是在熬着难熬的夜。 我记得去年的flag希望自己女友能搬到身边来，自己也想有个家的感觉，却发现太难了，我一直都相信爱情和美满的家，只是一直不会相信会发生在自己身上罢了。 我不想住着十几平的出租房，走三步就是卫生间，移动不了身体，束缚住灵魂。我不想一个人漂泊不定，我也想有一个能爱我的女孩，不求有多爱我，但是愿意和我一起走下去。 孤独 孤独是，睁开眼就已黄昏迟暮，寒星三两落在元远处 孤独是，海蓝时间鲸，林深时见鹿，却不见你在梦醒之处 孤独是，看一群人的演出，荧光满眼却看不清楚 孤独是，一个人吃饭，一个人失眠，一个人拼岁月拼图 孤独是，骑单车过陌生的马路，在拥挤的人海中踌躇 孤独是，假装很成熟，假装很忙碌，假装擅长一个人独处 孤独是，穿过玩家灯火无数，却无一人等我在归途 孤独是，收到远方一条短信，说照顾自己，累了别忍着不哭 憧憬原自己风尘仆仆，深情不被辜负虽回不到过去，也会不到当初原自己半生漂浮，此生能有归宿原自己风雨落幕，能有人免你孤独 良言 一段时间里，我觉得这个城市里的很多人都长得像蚂蚁，巨大的脑袋装着一个庞大的梦想，用和这个梦想不匹配的瘦小身躯扛着，到处奔走在一个个尝试里，而我也在不知不觉中成为了其中一员！ 我举手向苍穹，并非一定要摘到星月，只是想保持这个永不屈服的姿势！ 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse 调用方法放回值快捷键]]></title>
    <url>%2F2019%2F04%2F13%2FEclipse%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E6%94%BE%E5%9B%9E%E5%80%BC%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[有时候条用某个方法，知道返回值类型，需要用变量接收的时候，要手动去创建变量很麻烦，比如： 当调用getServletContext方法我们鼠标放在方法上可以显示返回值是：ServletContext ，这个时候怎么样快速用一个饮用型变量接收呢？方法很简单 在”;”分号后面按住Ctrl+1，选择第一个即可有变量类型以及自动取好名字： 还可以对变量名选择，一般情况变量名和变量类型一致，只是首字母不要大写即可，如果Ctrl+1后选择第二个，需要你自己手动输入变量名，一般Ctrl+1，然后选第一个就OK； 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>eclipse</category>
      </categories>
      <tags>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webstorm 设置黑色主题及相关的编码和显示设置]]></title>
    <url>%2F2019%2F04%2F13%2Fwebstorm%E8%AE%BE%E7%BD%AE%E9%BB%91%E8%89%B2%E4%B8%BB%E9%A2%98%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%9A%84%E7%BC%96%E7%A0%81%E5%92%8C%E6%98%BE%E7%A4%BA%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(入)中，欢迎有兴趣的童鞋们关注。 设置黑色主题1、file——setting 2、找到Appearance 3、选择黑色主题，注意箭头一定打勾箭头处设置的是在代码编辑区左边项目的字体样式 注意这个一定要save as 设置代码区字体样式 设置编码为UTF-8 都设置成UTF-8 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>JavaWeb前端基础</category>
      </categories>
      <tags>
        <tag>webstorm</tag>
        <tag>主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云服务器安装 oracle 修改 IP 地址监听器报错问题]]></title>
    <url>%2F2019%2F04%2F13%2F%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85oracle%E4%BF%AE%E6%94%B9IP%E5%9C%B0%E5%9D%80%E7%9B%91%E5%90%AC%E5%99%A8%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(ru)中，欢迎有兴趣的童鞋们关注。 当在云服务器中安装oracle时，按照一般的安装步骤安装后，需要修改两个文件的iIP地址才可以在本机进行访问，修改注意点：监听器部分不要改成服务器的公网IP，要改成服务器的计算机名字才可以，两个配置文件夹均要修改tnsnames.ora文件修改：listener.ora：其中host=那里也是改成计算机名而不是公网ip，然后分别重启监听器和orclservice服务就好，然后将tnsnames.ora文件拷贝到本机的E:\Java\Oracle\InstantClient\InstantClient目录下满。 如果监听器设置的是IP地址而不是计算机名字的话监听器会不起作用，甚至会启动不了服务。 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>云服务器</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决两个 Android 模拟器之间无法网络通信的问题]]></title>
    <url>%2F2019%2F04%2F13%2F%E5%85%B3%E4%BA%8EGitHub%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%EF%BC%88%E5%8C%85%E6%8B%ACREADME%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E5%86%99%E7%9B%AE%E5%BD%95%E7%9A%84%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(ru)中，欢迎有兴趣的童鞋们关注。 一、README.md上传图片需要注意的是一定要图片先上传到图床，我这边用的有两个1、图床2、七牛云关于七牛云我会出另外一篇文章细说注意：不管是截图的图片还是本地上传的图片都要上传到图床上，，然后复制URL才可以在GitHub中显示 二、README.md自动生成目录不能用Markdown的【TCG】自动生成目录，在GitHub上是不显示的我的办法是：1、点开网站2、将GitHub的README.md的URL复制，自动生成目录，但是这是不全的3、复制目录到README.md文件，需要在后面的括号处加上#文件名，这个是我能找到的比较简单的办法了，比手动敲简单特别注意：#后面不要加任何特殊字符和数字，目录不要编号，否则不成功，内部跳转不成功的很大部分原因也是因为内部编号了。 &gt;三、我的GitHubhttps://github.com/freestylefly/javaStudy#ajax期待你的加入！，有什么不懂的可以在GitHub上留言问我。 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式版本控制工具——Git]]></title>
    <url>%2F2019%2F04%2F13%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94Git%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(ru)中，欢迎有兴趣的童鞋们关注。 目录 - [目录](#目录) - [一、写在前面](#一写在前面) - [二、Git的优势](#二git的优势) - [三、Git的基本结构](#三git的基本结构) - [四、本地库和远程库](#四本地库和远程库) - [五、本地库初始化](#五本地库初始化) - [六、设置签名](#六设置签名) - [七、常用命令](#七常用命令) - [八、历史记录](#八历史记录) - [九、版本前进后退](#九版本前进后退) 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush: 一、写在前面Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。发明人就是大名鼎鼎的Linus ，发明初衷为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。需要知道的是Git底层文件验证采用的是SHA-1，（SHA-1）哈希算法可以被用来验证文件。哈希算法有如下特点：1、不管输入数据的数据量有多大，输入同一个哈希算法，得到的加密结果长度固定2、哈希算法确定，输入数据确定，输出数据能够保证不变3、哈希算法确定，输入数据有变化，输出数据一定有变化，而且通常变化很大4、哈希算法不可逆 二、Git的优势 大部分在本地完成，不用联网 完整性保证 尽可能添加数据而不是删除和修改数据 分支操作非常快速刘闯 和Linux命令全面兼容三、Git的基本结构工作区：写代码的地方暂存区：Git临时存储的地方本地库：Git存放的历史版本四、本地库和远程库局域网：GitLab外网：GitHub、码云1、团队内部协作：push：本地库提交到远程库pull：拉取远程库代码到本地库，包括两个操作fetch（拉取）+merge（合并）拉取并合并，就是将远程库的代码更新到本地库clone：将远程库所有东西下载到本地，并且建立本地库2、跨团队协作如需要在被人的GitHub仓库提交自己的修改，跨团队协作fork：复制一份别人的代码在自己的远程库pull request：拉取请求，发送自己的修改merge：合并保存五、本地库初始化”命令：git init注意：.git目录不能删除六、设置签名1、作用：在你提交代码的时候作为一个标识，代表这是你提交的代码，这里的签名和远程库上面的账号和密码没有任何关系2、命令123命令git comfig user.name 你的签名git config user.email 你的邮箱 3、注意：签名分两种：项目级别：也叫仓库级别，仅在当前本地库范围内有效，git gonfig命令系统级别：当前操作系统的用户有效，git config —global**优先级:就近原则4、查看签名 1234仓库级别：cat .git/config系统级别：cat `/.gitconfig 七、常用命令123456git status：查看工作区、暂存区状态git add 文件名：添加文件到暂存区git add *：添加所有文件到暂存区git rm --cached 文件名：将暂存区恢复到工作区git commit -m"提交日志" 文件名：提交文件到本地库git commit -a -m"提交日志" ：添加所有文件到本地库 八、历史记录1、查看历史记录git loggit reflog 简洁的查看历史记录，HEAD值简单化2、多层显示控制方式空格向下切换b向上翻页q退出 九、版本前进后退1、基于索引值操作git reset —hard 索引值git help 具体命令：查看帮助 2、reset命令的三个参数对比 —sert:仅仅在本地库移动HEAD指针 —mixed：从本地库移动指针，重置暂存区 —hard：本地库移动指针，重置暂存区，重置工作区 十、删除后找回 一定要明确一点就是，你从本地库或者工作区删除了文件，一定要将删除的操作add和commit 到本地库才可以找回相关文件。 git reset—hard 指针位置 十一、比较文件差异 git diff：工作区和暂存区比较 git diff HEAD 文件名：本地库和历史版本比较，不带文件名是比较多个文件 十二、git的分支 1、什么是分支 版本控制中， 使用多条分支同时推进多个任务 2、查看所有分支 git branch -v 3、创建分支 git branch 分支名 4、切换分支 gitcheckout 分支名 5、合并分支 第一步L切换到被合并分支 第二步：执行git merge 分支名 6、解决分支冲突 删掉相关标记 git add 文件名：标记为已解决 git commit -m“”“”：提交解决冲突 注意：提交的时候不能带文件名 十三、GitHub 1、给远程库URL新建别名 git remote add 别名 远程仓库URL 2、查看远程仓库地址别名 git remote -v 3、推送到远程库 git push 别名 分支名 4、克隆远程仓库内容到本地 git clone 远程地址别名 注意：克隆会晚会智能的把远程库下载到本地，创建origin远程地址的别名，并且会初始化本地库 5、抓取：将远程分支放到本地 git fetch 别名 分支名 6、合并 将远程分支合并到本地库 git merge 悲鸣/分支名 7、抓取并合并 git pull 别名 分支名 十四、ssh免密登录和eclipse下的git操作 这个可以直接访问仓库，对应资源可以下载 https://github.com/freestylefly/javaStudy/tree/master/Git%26GitHub 十五、写在最后 如果有想要学习资源的话欢迎评论咨询！ 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>Git和GitHub</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 数据库基础知识]]></title>
    <url>%2F2019%2F04%2F13%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(入)中，欢迎有兴趣的童鞋们关注。 一、初识数据库1、什么是数据库数据库叫database ，简称DB，是长期存放在计算机内，有组织、可共享的大量数据的集合；数据库就是存放数据的仓库，专业的数据库系统具有较小的数据冗余度，较高的数据安全性，易扩展性。 数据库设计原则： mysql主要优势：一个应用对应一个数据库 2、数据库分类 关系型数据库（保证数据的一致性，能建立关系） 非关系型数据库(放在不同的服务器上) MySQL（中小型企业免费） MongoDB（文档存储） Oracle（大型电商网站） Redis（键值存储） SQL Server（政府网站，大学教育） Memcached（键值存储） maradb（mysql开源版本的一个分支） Hbase（列存储） db2（银行系统） Neo4J（图形） sybase（被淘汰） 补充：ER关系图 实体用 属性 关系 方框 椭圆 菱形 补充：服务器服务器是一台电脑，这台电脑安装了服务器软件，这些软件会监听不同的端口号，根据用户访问的端口号提供不同的服务 3、DBMS、DBS、DBA区别 DBMS是数据库管理系统，是一种系统软件，包括数据库和用于数据库访问管理的接口系统，通常将DBMS直接称为数据库，严格意义上说mysql属于DBMS DBS是一个实际可运行的系统，由软件、数据库、数据库管理员组成 DBA数据库管理员 4、MySQL简介 概念是现行的开源、免费的关系型数据库 特点 运行速度快 使用成本低 容易使用 可移植性强 适用更多用户 mysql语句分类| DDL | DML | DQL | DCL || :————————-: | :———————————: | :—————: | :—————————————————————————: || 数据定义语言 | 数据操纵语言 | 数据查询语言 | ：数据控制语言，定义访问权限、取消访问权限，安全设置 || create、drop、alter | ，insert、update、delete | select | grant | 5、mysql的安装、卸载及启动mysql服务 安装 运行安装程序、在启动配置教程以前，一路下一步直到finish 第一次finish之后启动服务配置教程 第一个induce mysql bin dinctory to windows path 第二个端口号不要去修改，字符集要选择utf-8，默认端口号：3306 卸载 打开控制控制面板删除软件 删除mysql安装目录的所有文件 删除mysql数据存放的文件，C:\ProgramData\MySQL 启动mysql服务方式 任务管理器打开 命令行输入：service(查看本地服务) dos窗口输命令：net start mysql MysqlInsranceConfig:配置向导 programDate：数据文件的保存路径（默认是隐藏的，在C盘下） mysql的安装目录下的my.ini文件：相应的一些配置，可配置编码格式等 mysql -uroot -paaaaa123 进入mysql show databases显示所有的数据库 select version()显示mysql版本号 二、DDL语句创建数据库和数据表1、连接数据库（在dos窗口下） cmd——以管理员身份运行 启动mysql数据库服务：net start mysql 登录mysql：mysql -uroot -paaaaa123（或者：mysql -hlocalhost -uroot -paaaaa123）注意-p以后不能有空格 exit退出mysql show databases;（显示数据库，一定要加分号） use mysql show tables（显示数据库中的表） sql语句select * from user\G;显示user用户列表 修改user用户密码：update user set password=password’（1234’ ） where user=‘root’;,flush privileges;刷新下 ？寻求帮助 查看mysql所支持的引擎类型、表类型：SHOW ENGINES; 查看默认引擎：SHOW VARIABLES LIKE ‘storage_engine’; 显示变量：show variables like’auto%’ 2、数据库操作 创建数据库 CREATE DATABASE [IF NOT EXISTS ]数据库名; 删除数据库 DROP DATABASE [IF EXISTS] 数据库名; 修改数据库字符集 alter database 数据库名 character set 字符集 查看数据库 查看所有数据库：show databases 查看数据库定义：show create databse 数据库名 查看当前正在使用的数据库：select database() 选中数据库 use 数据库名 3、表结构操作 创建表 create table 表名( ​ 列名 列的类型 列的约束, ​ 列名 列的类型 列的约束 ​ )【表类型】【表字符集】【表注释】 代码示例： 12345678910#创建学生表，并设置表类型、字符集CREATE TABLE `student` ( `id` INT(4) NOT NULL AUTO_INCREMENT COMMENT '主键、学号', `psd` VARCHAR(20) COLLATE utf8_estonian_ci NOT NULL DEFAULT '123456' COMMENT '密码', `name` VARCHAR(30) COLLATE utf8_estonian_ci NOT NULL DEFAULT '匿名' COMMENT '学生姓名', `sex` VARCHAR(2) COLLATE utf8_estonian_ci NOT NULL DEFAULT '男' COMMENT '性别', `birsday` DATETIME DEFAULT NULL, `email` VARCHAR(20) COLLATE utf8_estonian_ci DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COLLATE=utf8_estonian_ci 注释 12字段注释： comment'注释的内容'表注释：comment='注释的内容' 列的约束 primary key 主键约束 ​ unique : 唯一约束 ​ not null 非空约束 注意事项 除了最后一个列不用逗号隔开，每一列都要逗号隔开 表名如果变蓝了表明和数据库有冲突，这时候要加上反引号· 字符串类型的要用单引号引起来 有多个属性的时候用空格隔开就好 commend后面加单引号注释内容 代表整个注释 设置严格检查模式 1SET sql_mode='strict_trane_tables'; 数值型 ：非常小的数据 int：标准整数 double：双精度浮点数 decimal【（M,D）】：字符串形式浮点数，M表示总位数，D表示保留小数位数 字符串型 char：固定长度 vachar：可变长度，括号内代表的是字符的个数 text：文本串 日期和时间 datetime：日期和时间，默认是null timestamp：常用于显示当前时间，默认是当前日期和时间 Null值 理解为没有值或未知值 不要用null进行算术运算 表的类型 常见的MyISAM，InnoDB | 名称 | MyISAM | InnoDB || :————: | :——: | :——: || 事务处理 | no | yes || 外键约束 | no | yes || 数据行锁定 | no | yes || 全文索引 | yes | no || 表空间大小 | 较小 | 较大 | 数据表的存储位置 都位于C:\ProgramData\MySQL目录下 | InnoDB | MyISAM || :——————-: | :—————————-: || 只有一个frm文件 | frm、wyd、myi三个文件 | 数据字段属性 unsigned：无符号，声明该数据不允许为负数 zerofill：0填充，不足位数用0填充，如int（3）5则为005 auto_increment：自动增长，常用于设置主键，且为整数，定义起始值和步长： 定义起始值：auto_increment=100(建表时在右括号右边写，影响的是当前表，对整个数据库的其他表没有影响 定义自增步长：set auto_increment_ncrement=5，会对所有数据库受影响 null和not null ：默认为null，若设置为not null则必须有值 default：设置默认值 删除表 drop table 表名 修改表 123456789101112#修改表名ALTER TABLE 表名 RENAME AS test1;#修改表的字符集alter table 表名 character set 字符集#添加列ALTER TABLE 表名 ADD 列名 列类型 属性 ;#修改列alter table 表名 modify 列名 列类型 属性 ;#修改列名alter table 表名 change 旧列名 新列名 列类型 属性 ;#删除列alter table 表名 dop 列名 查看表 123456查看当前数据库所有的表名show tables查看表的定义结构/创建语句show create table 表名查看表的结构desc 表名 4、保存sql文件以及打开sql文件保存Ctrl+s 新建查询编辑器——在同一标签中打开文件（在不同标签中打开） 对于图像声音视频用text、blob存储数据 一般没有必要直接存储图像，而存储的是路径用字符串 三、DML语句对表中数据CRUD操作1、主键&amp;外键 主键咋一个表里面可有也可以没有， 一个表里面的外键既可以有一个也可以有多个， 建立主外键关系的有主键的表为主表，有外键的表成为子表或者从表 能够保证数据的完整性和 正确性 对于有主外键关系的表，数据插入操作要有一定顺序，先放主键数据，再放外键数据 ，先删除子表，再删除主表 主键和外键，列名可以不同，但是数据类型一定要相同 主键和外键建立联系第一种方法在建表的时候就联系，关键词是constraint，外键名一般以FK开头 foreign key代表外键，引用主键用关键词reference 主键&amp;外键相关的SQL语句 123456789101112创建主键&amp;外键1、创建此表的同时就创建外键主键：PRIMARY KEY可写在列后面，也可以字段都写完了在最后一行写明PRIMARY KEY（字段名 ）外键：CONSTRAINT FR_gradeId FOREIGN KEY (要添加主键的字段) REFERENCES 引用表(引用表中的哪个字段)（FR_gradeId字段名）2、创建字表完毕后，修改子表增加外键ALTER TABLE 表名ADD CONSTRAINT 外键名 FOREIGN KEY (要添加主键的字段) REFERENCES 引用表(引用表中的哪个字段);删除外键ALTER TABLE 表名 DROP FOREIGN KEY 外键名;（删除了之所以还能看到外键在表中，是因为外键会默默的创建了一个索引，要想彻底删除还要加上一句话删除索引ALTER TABLE 表名 DROP INDEX 外键名;删除外键要有两句话才能彻底删除） 2、插入数据 insert into 表名（列名1，列名2） values（值1，值2） insert into 表名 values（值1，值2） insert into 表名（列名1，列名2） values（值1，值2），（值1，值2） 批量插入数据 注意点： 批量插入比单条插入效率更高，但是更容易出现问题 插入全部列名可以省略，插入部分列的话就不能省略表名后面的列名。 有默认值的时候在values里面可以写默认值也可以写default 如果不写列名的情况下即使有些列可以为空，但是不能不写要写null，最好都写上列名，如果外键值超过了主表的主键数目，会报错 3、删除数据 delete from 表名 【where条件】 truncate table 表名 delete 和 truncate 的区别 delete 是DML语句 一条一条删除表中数据 truncate是DDL 先删除表再重建表 关于哪条执行效率高，具体要看表中的数据量，如果数据比较少，delete高效，数据多，则truncate效率高 当使用不带where条件的delete from删除数据时，自增当前数值依然从原来基础上进行，会记录日志，不删除表结构，但使用truncate table删除表中全部数据的时候，自增当前数值不从原来基础上进行，从原来自增初始值开始。如下例子：不会记录日志 两种不同村粗引擎，在使用delete from删除全部数据后，自增列初始值表现的不同：同样使用delete from清空数据，重启数据库服务后，对于INNODB的表，自增列从初始值从新开始（比如开始默认初始值是1，那就从1再开始），而对于MYISAM型的表，自增序列从上一个自增数据基础上开始，原因是：INNODB的数据是储存在内容中的，重启数据可服务后，之前的也就都没有了，而MYISAM是储存在文件中，就算重启，数据依然存在。 4、修改数据 update 表名 set 列名=值【where条件】 四、DQL查询语句1、AS为字段取别名AS可省略 2、Dinstinct去重复项select distinct 字段名 from 表名 3、通用格式1234select [distinct] [*] [列名1,列名2] from 表名 where 条件group by...havingorder by 4、基础查询1234567891011121314151617181920212223242526272829303132333435#查询数据用DQL语句#1、核心查询（*代表查询所有列，效率比较低）SELECT * FROM student;#2、查询指定列，查询student的学号和姓名,在mysql中列名不区分大小写SELECT studentno,studentname FROM student;#3、被查出的列取别名（给列取别名as可以省略）SELECT studentno AS 学号,studentname AS 姓名 FROM student;SELECT studentno 学号,studentname 姓名 FROM student;#6、给表取取别名（给表取别名as可以省略），别名不会该表原表的列名，只是为了看的SELECT studentno 学号,studentname 姓名 FROM student AS 学生表;SELECT studentno 学号,studentname 姓名 FROM student 学生表;#7、as为查询结构（如函数）取一个新的名字SELECT CONCAT('姓名：',studentName)AS 新姓名 FROM student;#8、查看那些同学参加了考试（学号）,去除重复项，用关键字distinct，默认为all代表查询所有行SELECT DISTINCT studentno FROM result;注意：distinct一定写前面SELECT DISTINCT NAME NAME,english FROM exam;#9、select中可以出现表达式SELECT @@auto_increment_increment;SELECT VERSION();SELECT 100*3-1 AS 计算结果SELECT studentno,studentresult+1 AS 提分后 FROM result;#10、满足条件的查询(where) 考试成绩95-100SELECT studentno,StudentResultFROM resultWHERE StudentResult&gt;=95 AND StudentResult&lt;=100; 5、模糊查询12345678910111213141516171819202122232425262728293031#13、精确查询SELECT studentno,StudentResultFROM resultWHERE studentno=1000;#15、查询除了1000号这个学生，其他学生的考试成绩！=SELECT studentno,StudentResultFROM resultWHERE studentno !=1000;#16、或者用not和！=一样SELECT studentno,StudentResultFROM resultWHERE NOT studentno =1000;#17、模糊查询between and/ like/in/null#查询姓李的同学的学号和姓名#like及结合使用的通配符，%（0到任意一个字符） _(一个字符)#查询所有姓李的同学SELECT studentno,StudentNameFROM studentWHERE StudentName LIKE '李%';#查询姓李的，名字是三个字的SELECT studentno,StudentNameFROM studentWHERE StudentName LIKE '李__';#查询所有带有“文字的”（不管开头和结尾）常用SELECT studentno,StudentNameFROM studentWHERE StudentName LIKE '%文%'; 123456789101112131415转义字符%——\% _——\_如何不想用\作为转义字符，可以自定义转义字符，使用自己定义的转衣服：escape ‘你定义的转义符’但是%和_是不可以自行设计的#模糊查询之 inSELECT studentName,studentNo FROM studentWHERE studentNo IN(1000,1001,1002,1003);SELECT studentName,studentNo FROM studentWHERE Address IN('北京','南京');#模糊查询之 null注意：只有是显示null的才为空，对于空白什么都没有的并不是空null而是字符串为空，如： 12345678910#查询家庭住址没有写的同学#1、错误用法SELECT studentname FROM studentWHERE Address IS NULL;#2、用空字符串SELECT studentname FROM studentWHERE Address='';#3、一般这种类型的查询用这种写法SELECT studentname FROM studentWHERE Address='' OR Address IS NULL; 1234567#查询出生日期没有填写的同学，=null是错误的，和null比较要用iis nullSELECT studentno FROM studentWHERE BornDate IS NULL;#对于不是空的要用is not nullSELECT studentname FROM studentWHERE BornDate IS NOT NULL; 6、分组查询12345678910111213141516#不同课程的平均分、最高分、最低分SELECT subjectname, AVG(StudentResult) AS 平均分,MAX(StudentResult) AS 最高分,MIN(StudentResult) AS 最低分FROM result rINNER JOIN `subject` subON r.SubjectNo=sub.SubjectNoGROUP BY r.subjectno#分组后再筛选执行的sql语句筛选SELECT subjectname, AVG(StudentResult) AS 平均分,MAX(StudentResult) AS 最高分,MIN(StudentResult) AS 最低分FROM result rINNER JOIN `subject` subON r.SubjectNo=sub.SubjectNoGROUP BY r.subjectnoHAVING 平均分&gt;80ORDER BY 平均分 DESCLIMIT 0,4 7、连接查询 内连接 左连接 右连接 自连接 等值连接 非等值连接 nner join left join right join \ \ \ 查询两个表结果集中的交集 以左表为基准，右边表来一一匹配，匹配不上的返回左表记录，右表以null填充 以右表为基准，右边表来一一匹配，匹配不上的返回左表记录，左表以null填充 自连接的表一定要取别名（AS）子栏目父栏目问题 和内连一样，只是写法不同 区别于等值连接，不加where 1234等值连接：SELECT s.StudentNo,StudentName,subjectno,StudentResultFROM student s,result rWHERE s.StudentNo = r.StudentNo; 12345678910111213141516171819202122232425#自连接代码 CREATE TABLE IF NOT EXISTS category( categoryId INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '当前栏目', pId INT(10) NOT NULL COMMENT '当前栏目的父栏目', categoryName VARCHAR(50) NOT NULL, PRIMARY KEY (categoryId))INSERT INTO categoryVALUES (2,1,'美术设计'),(3,1,'软件开发'),(4,3,'数据库基础'),(5,2,'ps基础'),(7,2,'色彩搭配'),(8,3,'PHP基础'),(9,3,'java基础');SELECT * FROM category;SELECT categoryName '知足上进' FROM category;#将各个栏目的父子栏目显示出来（父栏目名称 子栏目名称）SELECT a.categoryName AS '主栏目',b.categoryName AS '子栏目'FROM category AS a,category AS b;WHERE a.categoryId=b.pId; 一定要先写连接查询再写where 多重嵌套连接： 注意：inner join ,和from以及on后面都不能用,隔开，否则会报1064错误 1234567#参加了参加了考试的同学（学号、学生姓名、科目名、分数）SELECT s.StudentNo,StudentName,subjectname,StudentResultFROM student AS sINNER JOIN result AS rON s.StudentNo = r.StudentNoINNER JOIN `subject` AS subON r.SubjectNo=sub.SubjectNo; 8、排序12345678910#查询《数据库结构—1》的所有考试的同学（学号、学生姓名、科目名、分数）SELECT s.StudentNo,StudentName,subjectname,StudentResultFROM student AS sINNER JOIN result AS rON s.StudentNo = r.StudentNoINNER JOIN `subject` AS subON r.SubjectNo=sub.SubjectNoWHERE SubjectName='数据库结构-1'ORDER BY StudentResult DESC,studentno DESC #1、默认升序asc 2、desc为降序#常见错误：ORDER BY StudentResult ,studentno DESC 这时候StudentResult升序，studentno降序，desc是就近原则 9、分页查询 limit 索引，页容量 当前页码-1）*页容量，页容量 1234567891011121314#分页查询##查询《数据库结构—1》的所有考试的同学（学号、学生姓名、科目名、分数）#每页显示五条数据出来SELECT s.StudentNo,StudentName,subjectname,StudentResultFROM student AS sINNER JOIN result AS rON s.StudentNo = r.StudentNoINNER JOIN `subject` AS subON r.SubjectNo=sub.SubjectNoWHERE SubjectName='数据库结构-1'ORDER BY StudentResult DESC,studentno DESC #limit 0,5 #从哪条记录开始起始行0，要显示几行LIMIT 5,5 #第二页LIMIT 10,5 #第三页 （等于linit 5 offset 0) 10、子查询 定义：子查询就是在查询语句中的where条件子句中，又嵌套了另外一个select查询语句 12345678910#子查询#分部写简单sql语句，然后去嵌套SELECT studentno ,studentname FROM student WHERE studentno IN()SELECT studentno FROM result WHERE StudentResult&gt;=80 AND subjectno=()#1\2\3\4SELECT subjectno FROM `subject` WHERE SubjectName='高等数学-2' #2SELECT studentno, studentname FROM student WHERE studentno IN(SELECT studentno FROM result WHERE StudentResult&gt;=80 AND subjectno=(SELECT subjectno FROM `subject` WHERE SubjectName='高等数学-2' )) 当from后面跟子查询时，一定要取别名 五、mysql函数1、数学函数 ABS（) CEILING() FLOOR() RAND() RAND() 绝对值 大于等于我的最小的整数 小于等于我的最大的整数 返回0-1之间的随机数 每次生成固定的0-1之间的随机数(以某个数作为种子) SELECT ABS(-8) ‘-8的绝对值’ SELECT CEILING(9.8)=10 SELECT FLOOR(9.8)=9 \ \ 2、字符串函数123456789101112131415161718192021#返回字符串中包含的字符数SELECT CHAR_LENGTH ( '好好学习数据库')#合并字符串SELECT CONCAT('我','爱')#替换字符串，从某个位置开始，替换某个长度，替换的内容SELECT INSERT('我爱你婺源',1,3,'很爱')SELECT INSERT('我爱你婺源',1,3,'很爱') #如果起始位置超过字符串长度，则返回原长度#变小写SELECT LOWER('I LOVE YOU')#变大写SELECT UPPER('i love you')#从左边截取指定长度的字符串SELECT LEFT('我爱你中国',3)##从右边截取指定长度的字符串SELECT RIGHT('我爱你中国',3)#替换字符串（要替换的字符串，要替换的文字，替换的内容）SELECT REPLACE('中国欢迎你，你好','你','你们')#截取(从哪个位置开始截取，截取多长）SELECT SUBSTRING('中国欢迎你，你好',1,2)#反转SELECT REVERSE('中国欢迎你') 3、日期和时间函数1234567891011121314#获得当前日期SELECT CURRENT_DATE()SELECT CURDATE()#获得当前日期和时间SELECT NOW()SELECT LOCALTIME()SELECT SYSDATE()#分别获取日期中的某个部分SELECT YEAR(NOW())SELECT MONTH(NOW())SELECT DAY(NOW())SELECT HOUR(NOW())SELECT MINUTE(NOW())SELECT SECOND(NOW()) 4、系统信息的函数12SELECT VERSION()SELECT USER() 5、聚合函数12345678910#聚合函数：返回的是一个值，不要出现多个值#count（字段名） 是非空值的计数count(*)返回所有列的统计SELECT COUNT(StudentName) FROM studentSELECT COUNT(1) FROM student#sum()求总和SELECT SUM(StudentResult) AS 总分 FROM resultSELECT AVG(StudentResult) AS 平均分 FROM resultSELECT MAX(StudentResult) AS 最高分 FROM【】 resultSELECT MIN(StudentResult) AS 最低分 FROM result count（*)尽量少用 六、MySql事务1、事务定义事务就是将一组sql语句放在同一批次内去执行，如果一个sql语句错误，则该批次的所有sql语句都将取消执行，最能理解的就是银行转账 注意： mysql事务只支出innoDB和BDB数据表类型 2、事务的ACID原则 原子性（A） 组sql语句是当做一个整体执行的，不能单独执行其中的某一条，要么全部成功，要么全部失败 一致性（C） 要么都是事务提交前的状态，要么都是事务提交以后的状态，不可能存在事务在中间的什么状态 隔离性（I） 每一个事务处理之间互不影响，彼此独立和透明，事务间不能交叉 持久性（D） 事务一旦提交成功，对事务的影响是永久 的 3、mysql事务实现方法 set autocomment=0关闭mysql的自动提交 start transaction 开启一个事务 执行的sql语句 commit/rollback 提交或者回滚 set autocomment=1 还原mysql默认的自动提交 123456789101112131415161718192021222324252627282930313233代码示例：#使用事务模拟实现转账CREATE TABLE IF NOT EXISTS account( id INT(4) PRIMARY KEY AUTO_INCREMENT, `name` VARCHAR(32) NOT NULL, cash DECIMAL(9,2) NOT NULL);INSERT INTO account (`name`,cash)VALUES ('A',2000),('B',10000);SELECT * FROM account;DELETE FROM account;#没有异常情况时候的事务SET autocommit=0;START TRANSACTION;UPDATE account SET cash=cash-500 WHERE `name`='A';UPDATE account SET cash=cash+500 WHERE `name`='B';COMMIT;SET autocommit=1;#有问题时候的事务用rollback撤销，回到事务开始最初的状态SET autocommit=0;START TRANSACTION;UPDATE account SET cash=cash-500 WHERE `name`='A';UPDATE account SET cash=cash+500 WHERE `name`='B';ROLLBACK；SET autocommit=1; 七、MySql索引和视图1、索引分类 主键索引 唯一索引 常规索引 全文索引 primary key unique index fulltext 避免同一个表中某数据列的值重复 不宜添加过多常规索引 只能英语myisam，并且只能是vachar、char、test类型 唯一索引和主键索引区别： 主键索引只有一个、唯一索引可以有多个 主键索引非空，唯一索引可以null 一个列上有很多索引，数据库会去选一个效率高的索引执行 2、添加索引12345678910111213141516171819202122232425262728293031323334353637383940#添加索引#方式一：在创建表申明列的时候添加上CREATE TABLE text1( id INT(3) PRIMARY KEY, testno VARCHAR(10) UNIQUE, c VARCHAR(50), d VARCHAR(20), e TEXT, INDEX `index_c`(c,d), FULLTEXT(e))ENGINE MYISAM***添加常规索引的时候，可以添加多个列为常规索引，写在前面的列有优先权，索引名字用``隔开，而不是逗号。#方式二，将所有列都申明完毕后再添加索引，统一添加索引CREATE TABLE text2( id INT(3) , testno VARCHAR(10) , c VARCHAR(50), d VARCHAR(20), e TEXT, PRIMARY KEY(id), UNIQUE KEY(testno), INDEX `index_c`(c,d), FULLTEXT(e))ENGINE MYISAM#方式三：创建表完毕后修改表的时候去添加索引CREATE TABLE text3( id INT(3) , testno VARCHAR(10) , c VARCHAR(50), d VARCHAR(20), e TEXT)ENGINE MYISAMALTER TABLE text3 ADD PRIMARY KEY(id);ALTER TABLE text3 ADD UNIQUE KEY(testno);ALTER TABLE text3 ADD INDEX(c,d);ALTER TABLE text3 ADD FULLTEXT(e); 注意：EXPLAIN SELECT * FROM student WHERE studentno=’1000’，explain代表的是查询查询的具体明细，包括如下信息： 全文索引，你要设置全文索引的列，查询的条件不能超过全文数据的50%，否则全文索引就没用了（只能用在字符串类型varchar和text上，只能用于MYISAM） 设置全文索引 12ALTER TABLE student ENGINE=MYISAM;EXPLAIN SELECT * FROM student WHERE MATCH(StudentName) AGAINST('李%'); 3、显示索引信息 在目录index下可以看到 利用sql语句显示索引信息：SHOW INDEX FROM student; 4、删除索引12345671、DROP INDEX 索引名 ON 表名;DROP INDEX testno ON text3;2、ALTER TABLE 表名 DROP INDEX e索引名ALTER TABLE text3 DROP INDEX e;3、#删除主键索引ALTER TABLE 表名 DROP PRIMARY KEY;ALTER TABLE text3 DROP PRIMARY KEY; 5、复合索引A-B-C先把A用到 6、索引准则 选择建立索引的列 频繁搜索的列 经常用作查询的列 经常排序、分组的列 经常用作连接的列（主键、外键） 不介意使用索引的列 仅包含几个不同值的列 小型表 7、视图 视图是保存在数据库中的select查询，是一种虚拟表，使用视图原因，一个是出于安全考虑，用户不必看到整个数据库的结构，另一个是复合用户日常业务逻辑 创建视图 12create view 视图名AS 查询语句 删除视图drop view 视图名 查看视图 select 字段1，字段2 from 视图名 注意事项 每个视图中可以使用多个表 一个视图可以嵌套另一个视图，单最好不要超过三层 对视图进行增加、修改、删除操作会直接影响表中数据 当视图来自多个表时，不允许添加和删除数据 选中系统数据库information_schnma，然后 select * from vieww;可查看所有视图 八、Mysql数据的备份与恢复1、使用命令mysqldump备份12345678910111213141516171819mysqldump是和mysql同级的一个命令！备份整个数据库mysqldump -uroot -p school&gt;E:/java/beifen/school.sql执行备份：*密码可以先不P输出，最后以密码文的形式*&gt;千万别丢了，如果丢了，会报mysqldump couldnot find。。。。备份特定的表mysqldump -uroot -p school grade student &gt;E:/java/beifen/school1.sqlmysqldump设置之指定哪些语句不显示mysqldump -uroot -p --skip-add-drop-table school grade student &gt;E:/java/beifen/school2.sqlmysqldump设置之显示insert into加上列名加上一个-c即可 mysqldump -uroot -p --skip-add-drop-table -c school grade student &gt;E:/java/beifen/school2.sql备份文件解析：1、/*和*/包裹的数据代表是可以被mysql执行的注释，但是不能被其他数据库执行2、--包围的是注释3、 !40101是版本号**mysql --help|more会以一屏显示，一行一行的看 2、使用mysql底下的脚本source1234561、进入mysqlmysql -urrot -p2、选择要备份到哪里use test3、选择要备份的数据库source E:/java/beifen/school.sql 3、使用sqlyong工具备份注意点：1、打勾的时候一定要注意，不要勾选use database和carat database 4、用sql命令进行备份数据1234567891011121314#将school库中的student表中的学号和姓名这两列备份出去USE school;#注意：备份出去的文件不可以提前存在SELECT studentno,StudentName INTO OUTFILE 'E:/java/beifen/student.sql' FROM student;#将备份出去的数据导入到test库中的stable表里来USE test;CREATE TABLE stable( id INT(4), sname VARCHAR(20))LOAD DATA INFILE 'E:/java/beifen/student.sql' INTO TABLE stable(id,sname);SELECT * FROM stable; 九、数据库设计1、设计目的 效率高 节省数据的储存空间 便于进一步扩展 使应用程序的开发变得更容易 2、设计数据库的步骤 收集信息 标识实体 标识每个实体之间的关系 3、绘制E-R图矩形表示实体、椭圆表示属性、菱形表示关系 4、绘制数据库模型图用Visio2007版本及以下版本绘制更好 5、三大范式 第一范式（1NF） 目标是确保每列 原子性，如果每列或者每个属性值都是不可再分的最小数据单元，则满足第一范式 第二范式（2NF） 一个表只描述一件事情，目标是确保表中的每列都和主键相关 如果一个关系满足第一范式，并且除了主键以外的其他键全部依赖于主键，则满足第二范式 第三范式（3NF） 目标是确保每列值都和主键直接相关，而不是间接相关，如果一个关系满足第二范式，并且除了主键以外的其他列都只能依赖于主键，列于列之间不存在相互依赖关系 十、特别注意数据库的脚本sql文件必须保存 十一、Readme 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决在 Eclipse 新建web项目没有自动生成 web.xml 和在新建 servlet 的时候自动生成 web.xml 配置]]></title>
    <url>%2F2019%2F04%2F13%2F%E8%A7%A3%E5%86%B3%E5%9C%A8Eclipse%E6%96%B0%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E6%B2%A1%E6%9C%89%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90web.xml%E5%92%8C%E5%9C%A8%E6%96%B0%E5%BB%BAservlet%E7%9A%84%E6%97%B6%E5%80%99%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90web.xml%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(ru)中，欢迎有兴趣的童鞋们关注。 一、在Eclipse新建web项目没有自动生成web.xml解决办法方法一：在Eclipse新建web项目的时候重要参数上打勾1、file—new-Dynamic Web Project2、next下一步 3、next下一步 4、关键：这里一定要打勾，默认是没有打勾的 5、建好后可以点开就有web.xml了 方法二：在已经建好的项目上加上web.xml 1.项目名称右键—&gt;Properties: 2.点击Project Facets，取消选中Dynamic Web Module,点击Apply 3.重新选中Dynamic Web Module后，会出现Further configuration available… 4.点击Further configuration available…，选中Generate web.xml deployment descriptor,点击ok,Apply后，在WEB-INF下生成了web.xml。 Eclipse在新建servlet的时候自动生成web.xml配置在新建web项目的时候：我们新建默认用的是Tomact7.0,里面用的是servlet3.0版本默认的是使用注解配置，在新建dynamic web project 时，dynamic web module version选择2.5就ok了。选择2.6即可这样就自动生成了servlet的文本.xml的自动配置t 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>eclipse</category>
      </categories>
      <tags>
        <tag>xml</tag>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[-Hibernate 之入门]]></title>
    <url>%2F2019%2F04%2F13%2FHibernate%E4%B9%8B%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(jing)续(chang)更(duan)新(geng)中，欢迎有兴趣的童鞋们关注。 一、什么是框架？框架是软件的半成品，已完成部分功能，调用相应的方法，可以简化开发，提高开发效率 二、javaEE三层架构和对应的企业级框架客户端层：HTML+CSS+JS 1、web层1）servlet+jsp 2） SpringMVC 3）Strute2 2、业务层1）javabean 2）Spring 3、持久层1）JDBC 2）Hibernate 3）Mybatis 三、SSH和SSM这两个都是目前流行的企业级组合开发框架 SSH是指：Strute2+Spring+Hibernate SSM是指：SpringMVC+Spring+Mybatis 四、什么是Hibernate 是一个持久层的ORM框架 五、什么是ORMObject Ralational Mapping 对象关系映射 使表和类建立关系，直接操作类相当于操作表 六、hibernate开发步骤1、导入所需的jar包1）数据库驱动包 2）hibernate所必须包：requied 3）日志记录包 2、建库建表3、实体类4、创建映射1）映射和实体类在同一个包中 2）映射的名字：类名.hbm.xml 3）xml的约束本分可在hibernate的核心包中copy 4）三个字标签： ​ class：属性（name：实体类全路径，table：表名） ​ id:(属性：name类名 column：主键字段名)，主键与相应的属性建立一一映射的关系 ​ property（属性同id）——对应除了主键之外的列和类的属性建立一一映射的关系 实例： 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;!-- 建立类和表的一个映射关系 --&gt; &lt;hibernate-mapping&gt; &lt;class name="com.canghe.domain.Customer" table="cst_customer"&gt; &lt;!-- 建立表中主键和类中属性的映射关系 --&gt; &lt;id name="cust_id" column="cust_id"&gt; &lt;!-- 主键生成策略 --&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;!-- 建立表中其他字段和类中属性进行一一对应 --&gt; &lt;property name="cust_name" column="cust_name"&gt;&lt;/property&gt; &lt;property name="cust_source" column="cust_source"&gt;&lt;/property&gt; &lt;property name="cust_industry" column="cust_industry"&gt;&lt;/property&gt; &lt;property name="cust_level" column="cust_level"&gt;&lt;/property&gt; &lt;property name="cust_phone" column="cust_phone"&gt;&lt;/property&gt; &lt;property name="cust_mobile" column="cust_mobile"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 5、hibernate核心配置文件1）在src文件下 2）文件名：hibernate.cfg.xml 3）xml约束在hibernate核心文件中copy，相应的必要配置可在project下的hibernate.properties下查找 4）四个必要参数 数据库驱动+url+username+password 5）可选配置 显示sql+格式化sql+自动建表 6）映射文件 实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 必要的配置信息,连接数据库中的基本参数 --&gt; &lt;property name="hibernate.connection.driver_class"&gt; com.mysql.jdbc.Driver &lt;/property&gt; &lt;property name="hibernate.connection.url"&gt; jdbc:mysql:///test &lt;/property&gt; &lt;property name="hibernate.connection.username"&gt; root &lt;/property&gt; &lt;property name="hibernate.connection.password"&gt; aaaaa123 &lt;/property&gt; &lt;!-- hibernate的属性 --&gt; &lt;!-- hibernate方言 , 作用：根据配置的方言生成相应的Sql语句--&gt; &lt;property name="hibernate.dialect"&gt; org.hibernate.dialect.MySQLDialect &lt;/property&gt; &lt;!-- 可选配置 --&gt; &lt;!-- 打印sql、 --&gt; &lt;property name="hibernate.show_sql"&gt; true &lt;/property&gt; &lt;!-- 格式化sql语句、 --&gt; &lt;property name="hibernate.format_sql"&gt; true &lt;/property&gt; &lt;!-- 自动建表 --&gt; &lt;property name="hibernate.hbm2ddl.auto"&gt; update &lt;/property&gt; &lt;!-- hibernate 加载映射 --&gt; &lt;mapping resource="com/canghe/domain/Customer.hbm.xml"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 七、工具类hibernateUtils123456789101112131415161718192021222324package com.canghe.util;/** * 工具类 * @author Administrator * */import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;public class HibernateUtils &#123; private static final Configuration configuration; private static final SessionFactory sessionFactory; static &#123; configuration = new Configuration().configure(); sessionFactory = configuration.buildSessionFactory(); &#125; public static Session openSission() &#123; return sessionFactory.openSession(); &#125;&#125; 八、CURD测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.canghe.test;import java.io.Serializable;import org.hibernate.Session;import org.hibernate.Transaction;import org.junit.Test;import com.canghe.domain.Customer;import com.canghe.util.HibernateUtils;public class HibernateDemo2 &#123; @Test /** * 增加（保存对象） */ public void demo1() &#123; //获得session链接对象 Session session = HibernateUtils.openSission(); //开启事务 Transaction transaction = session.beginTransaction(); //处理 Customer customer = new Customer(); customer.setCust_name("小一"); Serializable id = session.save(customer); System.out.println(id); //事务提交 transaction.commit(); //关闭资源 session.close(); &#125; @Test /** * 删除 */ public void demo2() &#123; Session session = HibernateUtils.openSission(); Transaction transaction = session.beginTransaction(); Customer customer = session.get(Customer.class, 4L); session.delete(customer); transaction.commit(); session.close(); &#125; @Test /** * 修改 */ public void demo3() &#123; Session session = HibernateUtils.openSission(); Transaction transaction = session.beginTransaction(); Customer customer = session.get(Customer.class, 5L); customer.setCust_name("小三"); customer.setCust_phone("18603016817"); session.update(customer); transaction.commit(); session.close(); &#125; @Test /** * 查询 */ public void demo4() &#123; Session session = HibernateUtils.openSission(); Transaction transaction = session.beginTransaction(); //get和load方法的区别，load是延迟加载 Customer customer = session.get(Customer.class, 5L); System.out.println(customer); Customer customer2 = session.load(Customer.class, 6L); System.out.println(customer2); transaction.commit(); session.close(); &#125; &#125; 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>JavaEE框架</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 中的数据类型转换]]></title>
    <url>%2F2019%2F04%2F13%2FJS%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(ru)中，欢迎有兴趣的童鞋们关注。 1、普通转换parseInt() parseFloat() 2、强制转换Boolean()可以将所有的数据类型转换为布尔值1、字符砖空字符串——false其他——true2、数值0——false其他——true3、变量值null或者未定义——false其他——true 3、开发中常用到if(!num)直接写变量代表的意思是，如果如果num存在值，那么执行下一步操作，首先num未定义会变成false，然后加上感叹号就变成了true 本文章已同步至GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>JavaWeb前端基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis 常见问题]]></title>
    <url>%2F2019%2F04%2F13%2FMyBatis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(jing)续(chang)更(duan)新(geng)中，欢迎有兴趣的童鞋们关注。 一、什么是Mybatis1、Mybatis是一个类似于Hibernate的ORM持久层开源框架，2、Mybatis通过XML或者注解配置和映射，实现对数据库的访问3、Mybatis的核心设计理念是基于原生sql进行的，正是由于这个设计理念使得Mybatis相对于Hibernate框架执行效率更高，但是代码的可移植性差，由于Mybatis是一个轻量级的框架，框架本身提供的功能较少，但是使用的灵活性更高。二、结果集映射1、结果集映射是在Mybatis的xml映射文件中进行配置的一个映射，表示查询语句结果集中每一条记录如何转换成对应的java对象，将我们的java对象和数据表中的字段一一对应。2、他是通过resultMap这个标签进行配置，里面属性有type和id，id是这个结果集映射的唯一一个标识，用于查询标签的一个引用，type属性用于设置查询结果需要转换的java对象，就是相对应的实体类，可以写全类名，当我们在Mybatis配置文件中配置默认扫描包或者配置类的别名的时候可以使用类名或者别名3、一共有2个字标签，分别是id和result，id于配置数据表主键对应关系，result用于设置其他字段和类属性的一个对应，这两个标签都有2个属性，propery和column，分别设置java对象的属性和数据表字段名三、动态SQL1、Mybatis的动态SQL是Mybatis灵活性的一种体现，可以通过外部传入的参数，使用一系列标签，灵活的拼接sql语句2、里面主要有这几个标签，if、where、set、foreach、choose、when、otherwise，3、if标签用来进行条件判断，有一个test属性，添加判断条件，多个if标签时，记得用。where标签取代sql中的where命令，若标签中无任意结果，则where不会出现在sql中，记得在前面加一个and用来连接；set标签用来取代sql中update set命令；foreach标签进行循环遍历，有collection、item、open、close、separator属性，分别指传入的参数类型，临时变量、语句开始和结束需要拼接的内容，分隔符；choose、when、otherwise相当于java中的多重if结构四、#和$区别1、两者都是用来进行参数传递2、#的方式更常用，内部封装了prepareStatement接口，进行预编译处理，相当于JDBC中为？占位符赋值，这种相对安全，$的方式是字符串拼接，用$号取到的数据会那需要使用正确的格式，拼接到sql中3、当比较而言#更加的安全，能有效的方式sql注入五、多表间关联查询1、开发中经常查询数据会用到多张表进行查询，比如查询一个用户可以有多个订单，但是用户表和商品表是两张不同的表，如果要查询用户以及其对应的商品信息就需要用到多表联查2、主要有两种方式，第一种编写带有连接查询的sql，将需要的字段从多张表中取出，放入结果集，首先在实体类中添加属性对应数据表中字段，其次，在映射文件的结果集映射中添加result标签，为新增的属性设置对应字段，最后修改查询sql，添加连接查询，3、这种方式很少用，方式二是，使用标签通过指定的格式进行配置，在查询时自动获取相关数据表的数据，主要用到两个标签，association处理多对一的关系，一般设置在多的一方的配置文件中，用于子表查询主表，collection标签处理一对多，设置在一的一方的配置文件中，用于主表查询子表，4、如何使用呢？首先在实体类中添加属性，一的一方添加多的一方的集合对象，泛型是多的一方的对象，多的一方添加一的一方的对象，其次在配置文件的结果集中添加标签，多的一方用association，一的一方用collection，对标签进行配置，分别有property、column、select属性，property自动查询的结果保存到那个实体类，column设置携带到查询语句中的字段，select设置自动执行的sql语句的id，最后需要添加对应数据表的结果集映射进来。 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>JavaEE框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N个人站圈报数算法问题]]></title>
    <url>%2F2019%2F04%2F13%2FN%E4%B8%AA%E4%BA%BA%E7%AB%99%E5%9C%88%E6%8A%A5%E6%95%B0%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(jing)续(chang)更(duan)新(geng)中，欢迎有兴趣的童鞋们关注。 这是一道算法面试题1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.Scanner;public class Test1 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int n;// 人数 int m;// 报名数（报到的出列） System.out.print("请输入n："); n = input.nextInt(); System.out.print("请输入m："); m = input.nextInt(); int num = n;// 剩余人数 int flag = 0;// 标记报名数，每报一次就加1 int[] arr = new int[n];// 数组，刚开始所有数都为0,0代表存货，1代表删除该元素 // 只要剩余人数大于等于1个人，就一直循环 while (num &gt;1) &#123; for (int i = 0; i &lt; n; i++) &#123; if (arr[i] == 0) &#123; flag++; &#125; if (flag == m) &#123; arr[i] = 1; System.out.println("第" + (i + 1) + "次出列：编号" + (i+1)); flag=0; num--; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; //最后编号为0代表存活的 if(arr[i]==0) &#123; System.out.println("最后剩下：" + (i+1)); &#125; &#125; &#125;&#125; 方式二： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.LinkedList;import java.util.List;import java.util.Scanner;/** * 使用集合解决 * @author Administrator * */public class Test &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); // 人数 int n; // 报名数（报到的出列） int m; //用来记录报名 int count=0; System.out.print("请输入人数："); n = input.nextInt(); System.out.print("请输入报到出列的数字："); m = input.nextInt(); //集合放人和出列 List&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;(); for (int i = 1; i &lt;=n; i++) &#123; list.add(i); &#125; while(list.size()&gt;1) &#123; for (int i = 0; i &lt;list.size(); i++) &#123; count++; //如果报数到m就讲这个数从集合中移出 if(count==m) &#123; System.out.println("出列的是："+list.remove(i)); count=0;//重新开始报数 i--; &#125; &#125; &#125; //遍历集合看剩余谁 for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println("最后出列："+list.get(i)); &#125; &#125;&#125; 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>Java语言核心</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2 中的OGNL和值栈ValueStack]]></title>
    <url>%2F2019%2F04%2F13%2FStruts2%E4%B8%AD%E7%9A%84OGNL%E5%92%8C%E5%80%BC%E6%A0%88ValueStack%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(入)中，欢迎有兴趣的童鞋们关注。 一、OGNL1、什么是OGNL是一种功能强大的表达式语言，通过他可以获取对象的任意属性和方法，同时能实现必要的类型转换，比EL表达式更加的强大，可以应用在页面，Action以及配置文件中 2、OGNL的作用 对象方法调用 类静态方法调用 赋值操作和表达式串联 访问OGNL上下文 操作集合对象 3、OGNL的要素 表达式 跟对象root context对象 二、值栈的概述1、什么是值栈ValueStack是Struts2的一个接口，OgnlValueStatck是实现类，客户端发送一个请求就会创建一个Action实例，同时会创建一个OgnlValueStatck实例，ValueStack其实类似于数据中转站，Struts中的数据都保存在值栈中，贯穿Action的生命周期，值栈中的数据可在JSP、Action、配置文件中使用 2、值栈的内部结构值栈的内部有两个主要区域， 1）root区域 实际上是一个ArrayList集合，放的是对象，实现压栈和出栈功能，拥有栈的特点，先进后出，后进先出，最后压进栈的数据再栈顶，称之为对象栈，取的时候不用加#号 通常操作值栈，就是值操作root区域，可查看值栈的内部结构 2）context区域 他是一个map结构，存放的是一些引用，request、session、等，其中attr代表该Map按如下顺序检索某个属性：request、session、application，其中使用&lt;s:iterator时，var存放的是放在context中的，取的时候要加#号 3、ActionContext和ValueStatck的关系通过查询源码可以知道，在创建ActionContext的时候，会创建ValueStatck对象，将ValueStatck独享给ActionContext，ActionContext中有一个ValueStatck的引用，ValueStatck中也有一个ActionContext的引用，ActionContext获取servlet的时候，依赖值栈了。 4、如何获取值栈对象 两种方式，获取的是同一个值栈 5、向值栈存数据 使用第一种方式的原因是因为，默认情况下Action会被压入到值栈中，所以Action中的属性也会被放入值栈，第二种方式，会压栈，即每一次push都会将其放入栈顶 6、从值栈中获取数据1）采用提供get方法的方式获取 1&lt;s:property value=&quot;user.cust_name&quot;/&gt; 2）采用valueStatck本身方法方式存入获取 1&lt;s:property value=&quot;cust_name&quot;/&gt; 3）获取值栈中集合的数据 1&lt;s:property value=&quot;list[0].cust_name&quot;/&gt; 4）获取context区域存放的数据 1&lt;s:property value=&quot;#request.cust_name&quot;/&gt; 7 、EL为何能访问值栈中的数据因为Struts2的底层对request.getAttribute()方法进行了增强，找到 找到就返回，没有找到就会从值栈中去找 三、OGNL特殊字符1、#号1）获取context中的数据，在使用标签遍历的时候var中的值 2）构建Map集合 默认Struts2框架会识别 12&#123;&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;&#125;为list集合&#123;&quot;aa&quot;:&quot;11&quot;,&quot;bb&quot;:&quot;22&quot;&#125;为map集合 当使用标签的时候，可以用#构建map集合 2、%号强制解析OGNL，Struts2的有些便签不能识别OGNL，需要使用%强制解析OGNL 3、$号1）在配置文件中使用 A、属性文件：国际化的地方 B：XML：如文件下载的时候使用 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>JavaEE框架</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax 常用用法]]></title>
    <url>%2F2019%2F04%2F13%2FAjax%E5%B8%B8%E7%94%A8%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(入)中，欢迎有兴趣的童鞋们关注。 一、ajax是什么异步的脚本，在整体页面不刷新的情况下，完成与后台数据交互，并根据返回数据，局部刷新页面 二、ajax常用场合1、表单验证：如验证用户名是否可用 2、页面拼接显示 3、前后端分离式的网站结构 三、ajax常见使用格式1、基础格式12345678910语法: $.ajax(&#123; url:&quot;需要访问的后台方法的地址&quot;, type:&quot;post&quot;, //数据传递的格式, post或get data: &#123;&#125;, //需要携带到后台的请求参数 dataType: &quot;&quot;, //参数的数据格式, 例如&quot;json&quot; success:fucntion(data)&#123; //后台响应成功后需要执行的回调函数 &#125;&#125;); 2. post格式(常用)12345678910111213141516171819202122232425262728293031323334//表单验证$(&quot;[name=&apos;userName&apos;]&quot;).bind(&quot;blur&quot;, function()&#123; //获取数据 var userName = $(&quot;[name=&apos;userName&apos;]&quot;).val().trim(); //关闭异步 $.ajaxSettings.async = false; //使用ajax访问后台, 查询用户名是否存在 //ajax post格式 $.post( &quot;$&#123;pageContext.request.contextPath &#125;/checkUserName&quot;, //地址 &#123; userName:userName &#125;, //&quot;userName=&quot;+userName, //参数(传给后台的参数) //&quot;$&#123;pageContext.request.contextPath &#125;/checkUserName?userName=&quot;+userName, function(data)&#123;//data是后台传过来的参数，也可以是HTML页面 //辅助变量 var msg = &quot;√&quot;; var color = &quot;green&quot;; //判断 if(data==0)&#123; msg = &quot;用户名已存在&quot;; color = &quot;red&quot;; flag = false; &#125; $(&quot;[name=&apos;userName&apos;]&quot;).parent().next().html(msg).css(&quot;color&quot;, color); &#125; ); //开启异步 $.ajaxSettings.async = true; &#125; 3、get格式123456789101112131415$.get( &quot;$&#123;pageContext.request.contextPath &#125;/checkUserName?userName=&quot;+userName, function(data)&#123; //辅助变量 var msg = &quot;√&quot;; var color = &quot;green&quot;; //判断 if(data==0)&#123; msg = &quot;用户名已存在&quot;; color = &quot;red&quot;; flag = false; &#125; $(&quot;[name=&apos;userName&apos;]&quot;).parent().next().html(msg).css(&quot;color&quot;, color); &#125; ); 四、使用ajax进行页面拼接1、ajax局部刷新函数使用该函数可以做到，将请求通过ajax传递给后台并携带页面需要传递到后台的参数，这个后台就是处理该请求的servlet，吼他接收到了请求，需要传递给页面一个消息，跳转到需要的页面。当然这里可以理解为后台传递给了页面一个页面作为参数data，然后tojump方法接收到该data，将该页面显示在我们需要指定的区域，这个时候相当于完成了局部刷新（记住ajax的执行过程） 12345678910111213//ajax局部页面刷新function toJump(url, param) &#123; //alert(url+&quot;:&quot;+param); $.post( webroot+url, //拼接绝对路径 param, function(data)&#123; //alert(data); $(&quot;#main&quot;).html(data); //将id main中的内容替换成data接收到的页面 &#125;, &quot;html&quot; //表示, data接收的数据类型是页面 );&#125; 比如我要将这个请求给到queryOne这个servlet，不携带任何参数，那么该后台接收到请求之后做什么呢？ 12//跳转到个人中心显示页(将页面信息作为参数传给页面response.sendRedirect(request.getContextPath()+&quot;/page/user/info.jsp&quot;); 很简单，只需要跳转到需要显示的页面，这里理解为跳转该页面为将该页面作为data参数返回给到页面 2、调用函数，实现局部显示这个时候在页面中调用toJump(“queryOne”);函数那么就可以将该页面放在我们想放的范围内显示了 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>JavaWeb前端知识</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse 详解及eclipse快捷键]]></title>
    <url>%2F2019%2F04%2F13%2Feclipse%E8%AF%A6%E8%A7%A3%E5%8F%8Aeclipse%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[eclipse在我们开发中帮了我们很多的忙，其中也有很多的快捷键可以提高我们开发的效率，但是这些快捷快捷键你都知道吗？ 一、eclipse详解以下是关于eclipse的中英对照，如果遇到不懂的地方可以做参考 「File」菜单这个菜单可以建立、储存、关闭、打印、汇入及汇出工作台资源以及结束工作台本身。 名称 功能 New(新建) 建立Java元素或新资源。配置哪些元素会显示在「Window」→「Preferences」的子菜单中。在Java视景中，依预设，会提供项目、套件、类别、接口、来源数据夹、实时运算簿、档案和数据夹的建立动作。 Close(关闭) 关闭现行编辑器。如果编辑器中有资料尚未储存，则会显示一个储存要求对话框。 Close All(全部关闭) 关闭所有编辑器。如果编辑器中有资料尚未储存，则会显示一个储存要求对话框。 Save(储存) 储存现行编辑器的内容。如果编辑器中没有未储存的变更，则会停用。 Save As(另存新檔) 以新名称储存现行编辑器中的内容。 Save All(全部储存) 储存所有编辑器内容以及未储存的变更。如果没有编辑器中有未储存的变更，则会停用。 Revert(回复) 将现行编辑器的内容回复成已储存档案中的内容。如果编辑器中没有未储存的变更，则会停用。 Move(移动) 移动资源。如果是Java元素则会停用。如果要移动Java元素，请使用「Refactor」→「Move」（如此会更新档案的所有参照），或使用「Edit」→「Cut/Paste」（如此不会更新参照）。 Rename(重新命名) 将资源重新命名。如果是Java元素则会停用。如果要重新命名Java元素，请使用「Refactor」→「Rename」（如此会更新档案的所有参照）。 Refresh(重新整理) 以本端档案系统来重新整理所选元素的内容。如果不是从特定选项启动，这个指令会重新整理所有项目。 Print(打印) 打印现行编辑器的内容。会在编辑器成为焦点时启用。 Switch workspace(切换工作区) 这个指令可以切换至不同的工作区这会重新启动工作台 Open external file(开启外部档案) 这个指令可以在文字编辑器中开启不在工作区中的档案 Import(汇入) 开启汇入精灵对话框。JDT不会提供任何汇入精灵。 Export(汇出) 开启汇出精灵对话框。JDT会提供JAR档汇出精灵和Javadoc产生精灵。 Properties(内容) 开启所选元素的「内容」页面。依据Java项目开启Java建置路径页面，且可使用Javadoc位置页面。如果是JAR保存文件，请在这个配置JAR的程序文件附加与Javadoc位置。 Recent file list(最近使用的档案清单 「File底端维护了一份最近在工作台中存取的档案的清单只要选取文件名，就可以从「File开启这其中的任何档案。 Exit(结束) 结束Eclipse 「Edit」菜单这个菜单可协助操作编辑器区域中的资源 名称 功能 Undo(复原) 回复成编辑器中的前一次变更 Redo(重做) 回复已取消的变更 Cut(剪下) 将目前所选取的文字或元素复制到剪贴簿中，并移除元素。就元素而言，在贴到剪贴簿前不会移除。 Copy(复制) 将目前所选取的文字或元素复制到剪贴簿中。 Paste (贴上) 将目前的内容当成文字贴到编辑器中，或当成同层级或下层元素，贴到目前所选的元素中。 Delete(删除) 删除目前的文字或元素选项。 Select All(全选) 选取所有的编辑器内容。 Find / Replace(寻找/取代) 开启「寻找/取代」对话框。限编辑器。 Find Next(寻找下一个) 寻找目前所选文字下一个搜寻结果。限编辑器。 Find Previous(寻找上一个) 寻找目前所选文字上一个搜寻结果。限编辑器。 Incremental Find Next(增量寻找下一个) 启动增量寻找模式。在呼叫后，请按照状态列中的指示来输入搜寻文字。限编辑器。 Incremental Find Previous(增量寻找上一个) 启动增量寻找模式。在呼叫后，请按照状态列中的指示来输入搜寻文字。限编辑器。 Add Bookmark(新增书签) 为目前的文字选项或所选取的元素新增书签。 Add Task(新增作业) 为目前的文字选项或所选取的元素新增使用者定义的作业。 Expand Selection to(展开选项至) n 含括元素：选取程序代码中的含括表示式、区块、方法。这个动作会注意Java语法。如果程序代码的语法有错，可能无法运作正常。（上移键） n 下一个元素：选取现行与下一个元素。（右移键）n 上一个元素：选取现行与上一个元素（左移键）n 还原前次的选择：在呼叫展开选项至之后，还原先前的选项。（下移键）Show Tooltip Description(显示工具提示说明) 以浮动说明方式显示出现在现行光标位置上的值。对话框可以卷动，因而不会缩短说明。 Content Assist(内容辅助) 在现行光标位置开启一个内容辅助对话框，以显示Java程序代码的辅助提议与范本。请参阅「模板」喜好设定页面，以取得可用的模板（「Window」→「Preferences」→「Java」→「Editor」→「Templates」），然后移至「编辑器」喜好设定页面（「Window」→「Preferences」→「Java」→「Editor」→「Code Assist」），来配置程序代码辅助的行为。 Quick Fix(快速修正) 如果光标位于有出现问题指示之处，则这个动作会在现行光标处开启一个内容辅助对话框，以提供可能的更正动作。 Parameter Hints(参数提示) 如果光标位于方法参照的参数规格处，这个动作会以浮动说明的方式显示参数类型信息。现行光标处的参数会以粗体字显示。 Encoding(编码) 切换目前所示文字内容的编码。 「Source」菜单 名称 功能 Toggle Comment(批注) 标注出内含现行选择项的所有字行。 Add Block Comment(批注区块) 标注出内含现行选择项的区块。 Remove Block Comment(解除批注区块) 取消标注内含现行选择项的区块。 Shift Right(向右移位) 增加目前所选字行的内缩层次。只有在选择项涵盖多行或一整行时才会启用。 Shift Left(向左移位) 减少目前所选字行的内缩层次。只有在选择项涵盖多行或一整行时才会启用。 Format(格式) 可使用程序代码格式制作器，来设定目前文字选择项的格式。格式设定选项是在「Code Formatter」喜好设定页面（「Window」→「Preferences」→「Java」→Code Formatter））中配置 Format Element(格式成员) 格式化成员 Sort Members(排序成员) 「Window」→「Preferences」→「Java」→「Appearance」→「Members Sort Order」中指定的排序次序，来排序类型中的成员 Organize Imports(组织汇入) 组织目前开启或所选编译单元中的汇入宣告。会移除不必要的汇入宣告，且会按照「Organize Import」喜好设定页面（「Window」→「Preferences」→「Java」→「Organize Import」）中的指定，来排列必要的汇入宣告。「Organize Import」可执行于不完整的程序文件上，并且会在所参照的类型名称无法唯一对映至现行项目中的某个类型时提示。 也可以组织多个编译单元，其做法是对某个套件呼叫动作，或选取一组编译单元。Add Import(新增汇入) 为目前所选的类型参照建立一项汇入宣告。如果类型参照完整，则会移除资格。如果所参照的类型名称无法唯一对映至现行项目中的某个类型，将会提示指定正确的类型。「Add Import」会试着遵循「Organize Import」喜好设定页面中指定的汇入顺序。 Override/Implement Methods(置换/实作方法) 会开启「Override Method」对话框，可以置换或实作现行类型中的方法。适用于类型或类型中的某个文字选择项。 Generate Getter and Setter(产生Getter和Setter) 开启「Generate Getter and Setter」对话框，可以为现行类型中的字段，建立Getter和Setter。适用于字段与类型或类型中的某个文字选择项。 Generate Delegate Methods(产生委派方法) 开启「Generate Delegate Methods」对话框，可以为现行类型中的字段建立方法委派。可用在字段。 Add Constructor from Superclass(新增Super类别中的建构子) 为目前所选的类型新增Super类别中所定义的建构子。适用于类型或类型中的某个文字选择项。 Surround with try/catch(以try/catch包覆) 针对所选的陈述式，评估所有必须捕捉到的异常状况。这些表示式会包覆try catch区块。可以使用编辑菜单中的展开选项至，以取得有效的选项范围。 Externalize Strings(将字符串提出) 开启「Externalize Strings」精灵。这个精灵可以藉由会存取内容档的陈述式，来更换程序代码中的所有字符串。 Find Strings to Externalize(寻找要提出的字符串) 会出现一个对话框，其中显示未提出字符串数目的摘要。适用于项目、来源资料夹与套件。 Convert Line Delimiters To(将行定界字符转换成) 在目前开启的编辑器中，变更所有行定界字符，而采用下列操作系统中所用的行定界字符： n CRLF(Windows)n LF（Unix、MacOSX）n CR（传统MacOS）Java编辑器容许混合使用行定界字符。不过，其它某些工具会要求使用和OS一致的行定界字符，或者要求至少行定界字符要一致。 「Refactor」菜单重构指令也可以在一些视图的快速菜单与Java编辑器中找到。 名称 功能 Undo(复原) 「Undo」前次的重构作业。重构复原缓冲区，共在执行重构后程序文件未变更的状况下有效。 Redo(重做) 重做前次复原的重构作业。重构复原/重做缓冲区的有效期，仅限于执行重构后到没有其它程序文件变更的这段时间。 Rename(重新命名) 启动「Rename Refactoring」对话框：重新命名所选的元素，并且（如果有启用的话）更正元素的（以及其它档案中的）所有参照。适用于方法、字段、区域变量、方法参数、类型、编译单元、套件、来源数据夹、项目，并且适用于可解析成这些元素类型之一的文字选项。 Move(移动) 启动「Move」重构对话框：移动所选的元素，并（如果有启用的话）更正元素的（以及其它档案中的）所有参照。可套用至一或多个Static方法、Static字段、类型、编译单元、套件、来源数据夹与项目，并且套用于可解析成这些元素类型之一的文字选择项。 Change Method Signature(变更方法签章) 启动「Change Method Signature」重构对话框。变更参数名称、参数类型、参数顺序，并更新对应方法的所有参照。此外，可以移除或新增参数，也可以变更方法传回类型及其可见性。这个重构作业可套用至方法或套用在解析成方法的文字选项。 Convert Anonymous Class to Nested(将匿名类别转换成巢状) 启动「Convert Anonymous Class to Nested」重构对话框。协助将匿名内部类别转换成成员类别。这个重构作业可套用至匿名内部类别。 Convert Nested Type to Top Level(将巢状类型转换成最上层) 启动「Convert Nested Type to Top Level」重构对话框。为所选成员类型建立新的Java编译单元，同时依需要更新所有参照。对于非static成员类型，将新增一个字段，以容许存取先前含括的实例。这个重构作业可套用至成员类型或解析成成员类型的文字。 Push Down(下推) 启动「Push Down」重构对话框。将类别中的一组方法和字段移至它的子类别。这个重构作业可套用至一个或多个以相同类型宣告的方法和字段，或套用在字段或方法内的文字选项。 Pull Up(上拉) 启动「Pull Up」重构精灵。将字段或方法移至其宣告类别的Super类别，或（如果是方法）将方法宣告成Super类别中的abstract。这个重构作业可套用至一个或多个以相同类型宣告的方法、字段和成员类型，或套用在字段、方法或成员类型内的文字选项。 Extract Interface(撷取界面) 启动「Extract Interface」重构对话框。以一组方法建立新的接口，并使所选类别实作接口，同时选择性将类别参照变更为新接口（在可能的情况下）。这个重构作业可套用至类型。 Use Supertype Where Possible(适当时使用Super类型) 启动「Use Supertype Where Possible」重构对话框。在识别所有可能发生这个取代的位置后，将出现的类型换成其Super类型之一。这个重构作业可用在类型之上。 Inline(列入) 启动「Inline」重构对话框。列入区域变量、方法或常数。这个重构作业可用在方法、static final字段，以及解析为方法、static final字段或区域变量的文字选项。 Extract Method(撷取方法) 启动「Extract Method」重构对话框。会建立一个内含目前所选之陈述式或表示式的新方法，并将选择项换成新方法的参照。可以使用编辑菜单中的展开选项至，以取得有效的选项范围。这项特性非常适合用来清除冗长、杂乱和太复杂的方法。 Extract Local Variable(撷取区域变量) 启动「Extract Local Variable」重构对话框。会建立一个新变量，以指定给目前所选的表示式，并将选择项换成新变量的参照。这个重构作业可用在解析为区域变量的文字选项。可以使用编辑菜单中的展开选项至，以取得有效的选项范围。 Extract Constant(撷取常数) 启动「Extract Constant」重构对话框。从所选表示式中建立static final字段并替代字段参照，以及选择性地重新写入其它出现相同表示式的位置。这个重构作业可用在static final字段，以及解析为static final字段的文字选项。 Convert Local Variable to Field(将区域变量转换成字段) 启动「Convert Local Variable to Field」重构对话框。将区域变量转换成字段。如果在建立时已起始设定变量，则作业会将起始设定移至新字段的宣告，或移至类别的建构子。这个重构作业可用在解析为区域变量的文字选项。 Encapsulate Field(封装字段) 启动「Encapsulate Field」重构对话框。会将字段的所有参照换成getting与setting方法。适用于所选的字段或可解析成字段的文字选择项。 「Navigate」菜单这个菜单可以寻找及导览工作台中显示的资源及其它成品。 名称 功能 Go Into(进入) 将视图输入设定在目前所选的元素上。「套件浏览器」视图可支持这项。 Go To(移至) n 上一页：将视图输入设定在历程中的上一个输入上：必须有历程，才能用到这项（已使用「Go Into」） n 下一页：将视图输入设定在历程中的下一个输入上：必须有历程，才能用到这项（已使用「Go Into」、「Go Into」→「Back」）n 往上移一层：将现行视图的输入设定在其输入的母元素上。n 参照测试：浏览以找出所有参照目前选取之类型的JUnit测试n 类型：浏览以找出类型，并在现行视图中显示它。「Package Explorer」视图支援这项。n 套件：浏览以找出套件，并在现行视图中显示它。「Package Explorer」视图支援这项。n 资源：浏览以找出资源，并在现行视图中显示它。Open(开启) 试着解析现行程序代码选项上所参照的元素，并开启宣告该参照的档案。 Open Type Hierarchy(开启类型阶层) 试着解析现行程序代码选项上所参照的元素，并在「Type Hierarchy」视图中开启该元素。针对元素呼叫，并开启元素的类型阶层。显示Java元素的Java编辑器与视图中可支持这项。 Open Call Hierarchy(开启呼叫阶层) 试着开启呼叫现行程序代码选项上所参照的元素，并在「Call Hierarchy」视图中开启该元素。 Open Super Implementation(开启super实作) 开启一个编辑器，以显示目前所选方法或现行光标位置旁之方法的super实作。如果未选取方法，或者方法没有super实作，则不会开启编辑器。 Open External Javadoc(开启外部Javadoc) 开启目前所选元素或文字选项的Javadoc文件。JAR或项目的Javadoc位置是在项目或JAR的「Javadoc Location」内容页面中指定。请注意，这个外部Javadoc文件可能未以现行程序代码中指定的Javadoc加以更新。可以使用Javadoc汇出精灵，在Java项目中为程序文件建立Javadoc文件。 Open Type(开启类型) 显示「Open Type」选择对话框，以便在编辑器中开启一个类型。「开启类型」选择对话框中显示工作区中的所有现有类型。 Open Type In Hierarchy(在「阶层」中开启类型) 显示「Open Type」选择对话框，以便在编辑器与「Type Hierarchy」视图中开启一个类型。「Open Type」选择对话框中显示工作区中的所有现有类型。 Show in → Package Explorer(显示在→套件浏览器) 在「Package Explorer」视图中显示目前所选的元素（或现行光标位置旁的元素）。 Quick Outline(显示概要) 为目前选取的类型开启小型概要器。 Quick Type Hierarchy(显示类型阶层) 为目前选取的类型开启小型类型阶层器。 Next Annotation (移至下一个问题) 选取下一个问题。Java编辑器中支持这项。 Previous Annotation (移至上一个问题) 选取上一个问题。Java编辑器中支持这项。 Go to Last Edit Location(移至前次编辑位置) 显示前次发生编辑的位置。 Go to Line(移至指定行号) 开启对话框，以输入指示编辑器应移至的行号。限编辑器。 Back(向后) 这个指令会导览至之前在编辑器中检视的前一个资源。这个指令和Web浏览器的上一页按钮相同。 Forward(向前 这个指令会导览并复原之前的上一页指令所造成的效果。这个指令和Web浏览器的下一页按钮相同。 「Search」菜单 名称 功能 Search…(搜寻…) 开启搜寻对话框 File…(档案…) 针对「档案搜寻」页面开启搜寻对话框 Java…(Java…) 针对「Java搜寻」页面开启搜寻对话框 References(参照) 寻找所选Java元素的所有参照 Declarations(宣告) 寻找所选Java元素的所有宣告 Implementors(实作者) 寻找所选接口的所有实作者。 Read Access(读取权) 寻找所选字段的所有读取权 Write Access(写入权) 寻找所选字段的所有写入权 Referring Tests…() 寻找所选Java元素的所有测试参照 Occurrences in File(档案中的搜寻结果) 寻找所选Java元素在其档案中的所有出现项目 Exception Occurrences(抛出例外中的搜寻结果) 寻找所选Java元素在其抛出例外中的所有出现项目 Search Scopes Submenu(搜寻范围子菜单)： 范围 可用性 说明 Workspace(工作区) 所有元素 在整个工作区中搜寻 Project(专案) 所有元素 在含括所选元素的项目中进行搜寻 Hierarchy(阶层) 类型和成员 在类型的阶层中搜寻 Workings Set(工作集) 所有元素 在工作集中搜寻 工作集对话框可以储存并命名范围。「搜寻范围」子菜单中亦会显示工作集的现有实例。可在下列视图中透过所选资源与元素的快速菜单，来执行Java搜寻：n 「Package Explorer」n 「Outline」视图n 「Search Result」视图n 「Hierarchy」视图n 「Browsing」视图Java编辑器中亦提供「Search」快速菜单。目前所选文字必须可解析成Java元素，才能执行搜寻。所选Java元素的类型会定义所能使用的「Search」快速菜单。Java编辑器不会根据选项而限制可用的Java搜寻项清单。 「Project」菜单「项目」菜单可以对工作台中的项目执行动作（建置或编译）。 名称 功能 Open Project(开启专案) 显示对话框，可以选取开启已关闭的项目 Close Project(关闭专案) 关闭目前所选取的项目 Build All(全部建置) 这个指令会对工作台中的所有项目执行增量(incremental)建置。也就是说，它会建置（编译）自从前次增量建置后，工作台中受到任何资源变更所影响的所有资源。自动建置关闭时，才可使用这个指令。 Build Project(建置专案) 这个指令会对目前选取的项目执行增量(incremental)建置。也就是说，它会建置（编译）自从前次建置后，受到任何资源变更所影响的项目中的所有资源。自动建置关闭时，才可使用这个指令。 Build Workings Set(重新建置工作集) 这个菜单可以在工作集上执行增量(incremental)建置。也就是说，它会建置（编译）前次建置之后，受到任何资源变更所影响之工作集中的所有资源。自动建置关闭时，才可使用这个指令。 Clean(清除) 这个指令会舍弃先前的所有建置结果。如果自动建置是开启的，这会呼叫完整的建置。 Build Automatically(自动建置) 自动建置工作区中的所有项目。这个指令可以切换自动建置喜好设定。 Generate Javadoc…(产生Javadoc…) 对目前选取的项目开启「Generate Javadoc」精灵。 Properties(内容) 对目前选取的项目开启内容页面。 「Run」菜单 名称 功能 Toggle Line Breakpoint(切换行岔断点) 这个指令可以在目前于作用中Java编辑器中所选之行处，新增或移除Java行岔断点。 Toggle Method Breakpoint(切换方法岔断点) 这个指令可以针对目前的二进制方法，新增或移除方法岔断点。可在Java类别档编辑器的来源中选取二进制方法，或在其它任何视图中选取（像是「Outline」视图）。 Toggle Watchpoint(切换监视点) 这个指令可以针对目前的Java字段，新增或移除字段监视点。可在Java编辑器的来源中选取字段，或在其它任何视图中选取（像是「Outline」视图）。 Skip All Breakpoints(忽略所有的岔断点) 这个指令可以忽略所有的岔断点 Add Java Exception Breakpoint(新增Java异常状况岔断点) 这个指令可以建立一个异常状况岔断点。可藉由指定异常状况岔断点，而在掷出异常状况时，暂停执行绪或VM的执行。可设为在未捕捉到或捕捉到（或两者）异常状况时暂停执行。 Add Class Load Breakpoint 这个指令可让以建立一个Class Load岔断点。 Run Last Launched(执行前一次的启动作业) 这个指令可以在执行模式下迅速重复最近一次的启动作业（如果有支持该模式的话）。 Debug Last Launched(除错前一次的启动作业) 这个指令可以在除错模式下迅速重复最近一次的启动作业（如果有支持该模式的话）。 Run History(执行历程) 呈现在执行模式下启动的启动配置之最近历程的子菜单 Run As(执行为) 呈现所登录之执行启动快捷方式的子菜单。启动快捷方式可支持工作台或作用中编辑器选项的感应式启动。 Run…(执行…) 这个指令会了解启动配置对话框，以管理执行模式下的启动配置。 Debug History(除错历程) 呈现在除错模式下启动的启动配置之最近历程的子菜单 Debug As(除错为) 呈现所登录之除错启动快捷方式的子菜单。启动快捷方式可支持工作台或作用中编辑器选项的感应式启动。 Debug…(除错…) 这个指令会了解启动配置对话框，以管理除错模式下的启动配置。 Inspect(视察) 当执行绪暂停时，这个指令会使用「表示式」视图，显示在该执行绪之堆栈框或变量的环境定义下，视察所选表示式或变量的结果。 Display(显示) 当执行绪暂停时，这个指令会使用「Display」视图，显示在该执行绪之堆栈框或变量的环境定义下，评估所选表示式的结果。如果目前作用中的部分是「Java Snippet Editor(Java片段编辑器)」，则会在其中显示结果。 Execute(执行) 执行 Step into Selection 这些指令可以逐步执行所要除错的程序代码。 Externakl Tools(外部工具) 外部工具 「Windows」菜单这个菜单可以显示、隐藏，以及另行在工作台中操作各种视图、视景和动作。 名称 功能 New Window(开新窗口) 这个指令会开启一个新的工作台窗口，其中含有与现行视景相同的视景。 Open Perspective(开启视景) 这个指令会在此工作台窗口中开启新视景。可以在「Window」→「Preferences」→「Workbench」→「Perspectives」页面中变更这个喜好设定。在工作台窗口内开启的所有视景都会显示在快捷方式列上。 Show View(显示视图) 这个指令会在现行视景中显示选取的视图。可以在「Window」→「Preferences」→「Workbench」→「Perspectives」页面中配置开启视图的方式。可能会想开启的视图会最先列示；这份清单视现行视景而定。从其它… 子菜单中，可以开启任何视图。视图会依照「Show View」对话框中的各个种类来排序。 Customize Perspective(自订视景) 每个视景包含一组预先定义的动作，可以从菜单列和工作台工具列存取这些动作。 Save Perspective As(另存新视景) 这个指令可以储存现行视景，以及建立自己的自订视景。储存视景之后，可以使用「Window」→「Show View」→「Other…」菜单项目来开启更多这类型的视景。 Reset Perspective(重设视景) 这个指令会将现行视景的布置变更为其原始的配置。 Close Perspective(关闭视景) 这个指令会关闭作用中的视景。 Close All Perspectives(关闭所有视景) 这个指令会关闭工作台窗口中的所有已开启视景。 Navigation(导览) 这个子菜单包含用于在工作台窗口中的视图、视景及编辑器之间导览的按键。 n 显示系统菜单：显示用来重新调整大小、关闭或固定现行视图或编辑器的菜单。n 显示视图菜单：显示可在作用中视图的工具列中存取的下拉菜单。n 将作用中的视图或编辑器最大化：使作用中的部分占用整个画面，如果已占用整个画面，就使它返回原始状态。n 启动编辑器：使现行编辑器作用中。n 下一个编辑器：启动最近使用的编辑器清单中的下一个开启的编辑器。n 上一个编辑器：启动最近使用的编辑器清单中的上一个开启的编辑器。n 切换至编辑器：显示一个对话框，用来切换到已开启的编辑器。显示一个对话框，用来切换到已开启的编辑器。n 下一个视图：启动最近使用的视图清单中的下一个开启的视图。n 上一个视图：启动最近使用的编辑器清单中的上一个开启的编辑器。n 下一个视景：启动最近使用的视景清单中的下一个开启的视景。n 上一个视景：启动最近使用的视景清单中的上一个开启的视景。Preferences(喜好设定) 这个指令可以指出在使用工作台时的喜好设定。其中有各式各样的喜好设定可用来配置工作台及其视图的外观，以及用来自订在工作台中安装的所有工具的行为。 「Help」菜单这个指令提供有关使用工作台的说明。 下面是一些快捷键的用法：下面是一些快捷键的用法：名称 功能 Welcome(欢迎使用) 这个指令会开启欢迎使用内容。 Help Contents(说明内容) 这个指令显示说明视图。说明视图含有说明书籍、主题，以及与工作台和已安装特性的相关信息。 Tips and Tricks(要诀和技巧) 这个指令会开启可能尚未探索之有兴趣的生产力特性的清单。 Cheat Sheets(提要) 这个指令会开启选取提要的对话框。 Software Updates(软件更新) 这个指令群组可以更新产品以及下载及安装新特性。 About Eclipse Platform(关于Eclipse平台) 这个指令显示产品、已安装特性及可用外挂程序的相关信息。 二、eclipse中最常用的快捷键一、常用系列： 二、查看和定位快捷键系列在程序中，迅速定位代码的位置，快速找到 Bug 的所在，是非常不容易的事，Eclipse 提供了强大的查找功能，可以利用如下的快捷键帮助完成查找定位的工作。 三、调试快捷键系列 四、常用编辑器快捷键系列通常文本编辑器都提供了一些和编辑相关的快捷键，在 Eclipse 中也可以通过这些快捷键进行文本编辑。 五、切换系列六、Ctrl系列 七、Ctrl+Shift系列 八、F 快捷键系列 九、行编辑用系列 十、不常用系列 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>eclipse</category>
      </categories>
      <tags>
        <tag>eclipse</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle 知识点总结]]></title>
    <url>%2F2019%2F04%2F13%2Foracle%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(ru)中，欢迎有兴趣的童鞋们关注。 一、Oracle概念oracle数据可系统是美国oracle（甲骨文）公司提供的以分布式数据库为核心的一组软件产品，是目前最流行的客户/服务器或B/S体系结构的数据库之一，oracle数据库时目前世界上使用最为广泛的数据库管理系统，作为一个通用的数据库系统，它具有完善的数据库管理功能，是关系型数据库，比mysql更为庞大，在现行的关系型数据库中排名第一（oracle、mysql、SqlServer），时间是最为精确的。 二、Oracle的安装安装教程 三、Oracle数据库的体系结构1、数据库databaseOracle数据库是数据的物理储存，这就包括（数据文件ORA或者DBF、控制文件、联机日志、参数文件）。其实Oracle数据库的概念和其他数据库不一样，这里的数据库时一个操作系统只有一个库，可以看做Oracle就只有一个大数据库。 2、实例一个数据库可以有n个实例，有一系列的后台进程和内存结构组成。 3、数据文件dbf是数据库的物理储存单位，数据库的数据是储存在表空间中的，真正是在某一个或者多个数据文件中，而一个表空间可以由一个或多个数据文件组成，一个数据文件只能属于一个表空间，一旦数据文件被加入到某个表空间后，就不能删除这个文件，如果要删除某个数据文件，只能删除其所属于的表空间才行。 4、表空间表空间是Oracle对物理数据库上相关数据文件的逻辑映射，一个数据库在逻辑上被划分成一到若干个表空间，每个表空间包含了在逻辑上相关联的一组结构，每个数据库至少有一个表空间（称之为system表空间） 每个表空间由同一磁盘上的一个或多个文件组成，这些文件叫数据文件，一个数据文件只能属于一个表空间。 5、用户用户是在实例下建立的，不同实例中可以建相同名字的用户，表的数据是由用户放入某一个表空间的，而这个表龙剑会随机把这些表数据进行管理和存放的，但是表不是由表空间去查询的，而是由用户去查询。 6、SCOTT和HR用户是Oracle帮我们建好的测试账户，Scott账户常用，里面有emp、dept表等。 四、Oracle和MYSQL的差别1、新建项目的方式 MYSQL : 创建一个数据库,创建相应的表 2、Oracle是多用户的, MYSQL是多数据库的 3、Oracle安全级别要高,MYSQL开源免费 1、数据完整性关注数据的有效性和准确性 1）实体完整 关注点：一条数据的唯一性 使用主键、唯一约束 2）域完整性 关注点：字段的格式 非空、检查、外键约束 3）引用完整 关注点：字段的引用关系 4）自定义完整 可使用存储过程、触发器等进行规范 2、数据冗余字段的数据出现重复，重复的数据是可忍受可不处理 处理方式：将重复数据提取成一张新的数据表 五、基本查询1、SQL概念结构化查询语言 2、SQL分类DDL : 数据定义语言 create alter drop truncateDML : 数据操纵语言 insert update delete DCL : 数据控制语言 安全 授权 grant revoke DQL : 数据查询语言 select from子句 where子句 在oracle中将DQL放入DML中，多了TCL：事务控制语言 commit、rollback 3、Oracle中的数据字典所谓数据字典就是编写sql语句，全选可以一次性执行不报错 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* 1.删除数据对象 */-- 删除数据表drop table t_reply;drop table t_user;-- 删除序列drop sequence sq_user;drop sequence sq_reply;/* 2.创建数据对象 */-- 创建数据表create table t_user( u_id number(4) primary key, u_userName varchar2(40) unique not null, u_password varchar2(50) not null, u_gender number(1) check(u_gender in (0,1,2)), u_age number(3) check(u_age between 12 and 120), u_registeTime date not null);create table t_reply( r_id number(10) primary key, r_content varchar2(500) not null, r_userId number(4) not null, foreign key(r_userId) references t_user(u_id));-- 创建序列create sequence sq_user start with 1001;create sequence sq_reply start with 10000001;/* 3.添加测试数据 */-- 处理全新的数据表和全新的序列在使用时取不到初始值的问题insert into t_user values (1, '1', '1', 1, 25, sysdate);insert into t_reply values (1, '1', 1);delete from t_reply;delete from t_user;commit;/*insert into t_user values (1000, 'owner', '9999', 1, 25, sysdate);insert into t_reply values (10000000, '人员召集...', 1000);*/ -- 添加数据insert into t_user values (sq_user.nextval, 'admin', '9999', 1, 25, sysdate);insert into t_reply values (sq_reply.nextval, '系统1.0上线...', sq_user.currval);/* 4.提交 */commit;/* 5.查询语句 *//* select * from t_user; select * from t_reply;*/ 3、查询语句的结构1select [列名] [*] from 表名 [where 条件] [group by 分组条件] [having 过滤] [order by 排序] 4、伪表dual dual : oracle中的虚表 ,伪表, 主要是用来补齐语法结构， 1234比如：select 1+1 from dual;注意：直接写一个常量比写 * 要高效select count(1) from emp;select count(*) from emp; 5、别名查询使用as 关键字, 可以省略，别名中不能有特殊字符或者关键字, 如果有就加双引号(比如空格） 12elect ename 姓名, sal 工资 from emp;select ename "姓 名", sal 工资 from emp; 6、去除重复数据 distinct加在select和列名后面，多列去除重复: 每一列都一样才能够算作是重复 12345--单列去除重复select distinct job from emp;--多列去除重复的select distinct job,deptno from emp; 7、查询中四则运算需要用到伪表dual 123select 1+1 from dual;--查询员工年薪 = 月薪* 12select sal*12 from emp; 在Oracle 中 ,双引号主要是别名的时候使用, 单引号是使用的值, 是字符 8、空值处理函数注意: null值 , 代表不确定的 不可预知的内容 , 不可以做四则运算 1）mysql的空值处理​ ifnull(参数1, 参数2):​ 判断参数1是否为null,​ 不为null, 则函数的结果取参数1的值​ 为null, 则取参数2的值​ if(参数1, 参数2, 参数3)​ 判断参数1是否为null,​ 为null, 则取参数3的值​ 不为null, 则取参数2的值​ 注意if函数只能处理数值字段的空值 1234567SELECT e.`ename` 姓名, e.`sal` 底薪, e.`comm` 奖金, (e.`sal`+e.`comm`) 实发, IFNULL(e.`sal`+e.`comm`, e.`sal`) 实发1, IF(e.`comm`, e.`sal`+e.`comm`, e.`sal`) 实发2FROM emp e; 2）oracle的空值处理 nvl（参数1，参数2）：如果1为null，则返回2，不为null就为1 nvl2（参数1, 参数2, 参数3）1为null，则返回,3，不为null，则返回2 decode(需要判断的字段,​ 常量值1, 结果值1,​ 常量值2, 结果值2,​ ….​ 常量值n, 结果值n,​ 默认结果值​ ) 1234567select e.ename 姓名, e.sal 底薪, e.comm 奖金, nvl(e.sal+e.comm, e.sal) 实发1, nvl2(e.comm, e.sal+e.comm, e.sal) 实发2, decode(e.comm, null, e.sal, e.sal+e.comm) 实发3from emp e; 9、字符串拼接 Oracle 特有的连接符: || 拼接 concat(str1,str2) 函数, 在mysql和Oracle中都有 1234567--查询员工姓名 : 姓名:SCOTTselect ename from emp;--使用拼接符select '姓名:' || ename from emp;--使用函数拼接select concat('姓名:',ename) from emp; 六、条件查询条件查询就是where后面的写法 1、关系运算符和排序12&gt; &gt;= = &lt; &lt;= != &lt;&gt;注意：不等于既可以用！=也可以用&lt;&gt;但是&lt;&gt;效率更高 2、逻辑运算符 and or not 3、其它运算符12345like 模糊查询in(set) 在某个集合内between..and.. 在某个区间内 is null 判断为空is not null 判断不为空 4、模糊查询: like % 匹配多个字符 _ 匹配单个字符 如果有特殊字符, 需要使用escape转义 1234--查询员工姓名中,包含%的员工信息select * from emp where ename like '%\%%' escape '\';select * from emp where ename like '%#%%' escape '#'; 5、排序order by升序: asc ascend 降序: desc descend 排序注意null问题 : nulls first | last指定null值显示的位置 同时排列多列, 用逗号隔开 12345--查询员工信息,按照奖金由高到低排序select * from emp order by comm desc nulls last;--查询部门编号和按照工资 按照部门升序排序, 工资降序排序select deptno, sal from emp order by deptno asc, sal desc; 分析函数：用来处理排名并列问题 rank——排名可并列，之后序号不会顺眼（如2个第二，下一个是第四名）1,2,2,4 dense_rank——排名可并列，之后序号会顺眼（如2个第二，下一个是第三名）1,2,2,3 row_number——不可并列排名 over——添加分组条件 partition—by——分组 12345678910111213141516171819/*4. 查询实发工资总排名前十的员工, 将十人按照部门分组排名显示, 排名可并列, 排名不空出 结果集要求显示: 员工编号, 员工姓名, 部门名称, 实发工资, 部门排名, 总排名*/select b.*, dense_rank() over(partition by b.部门名称 order by b.实发工资 desc) 部门排名from( select dense_rank() over(order by s.实发工资 desc) 总排名,s.* from ( select e.empno 员工编号,e.ename 员工姓名,d.dname 部门名称, e.sal+nvl(e.comm,0) 实发工资 from emp e inner join dept d on e.deptno=d.deptno ) s ) bwhere b.总排名&lt;=10 6、分组排序 select 分组的条件，分组之后的条件 from 表名 group by 分组的条件 having 条件过滤 在分组查询语句的检索内容中, 只能出现分组字段和聚合函数 sql的编写顺序：​ select,from,where,group by,having,order bysql的执行顺序：​ from,where,group by,having,select,order by……. where和having的区别： where后面不能跟聚合函数，可以接单行函数having是在group by之后执行，可以接聚合函数 12345--分组统计所有部门的平均工资，找出平均工资大于1500的部门select deptno,avg(sal) from emp group by deptno having avg(sal)&gt;1500;--报错,给分组之后的条件取别名的时候出错，因为sql语句执行的顺序问题select deptno,avg(sal),bb from emp group by deptno having bb&gt;1500; 七、函数函数: 必须要有返回值 1、单行函数对某一行中的某个值进行处理 1）数值函数 取整 12select ceil(45.926) from dual; --46 向上取整select floor(45.926) from dual; --45 向下取整 四舍五入 round（a，b） b如果是正数代表取到小数点后b位数为止 b如果是负数代表取到十位为止 123456elect round(45.926,2) from dual; --45.93select round(45.926,1) from dual; -- 45.9select round(45.926,0) from dual; --46select round(45.926,-1) from dual; --50select round(45.926,-2) from dual; --0select round(65.926,-2) from dual; --100 截断（去尾法） 123456select trunc(45.926,2) from dual; --45.92select trunc(45.926,1) from dual; -- 45.9select trunc(45.926,0) from dual; --45select trunc(45.926,-1) from dual; --40select trunc(45.926,-2) from dual; --0select trunc(65.926,-2) from dual; --0 求余 12select mod(9,3) from dual; --0select mod(9,4) from dual; --1 2）字符函数 123456789101112131415 substr(str1,起始索引,长度) --注意: 起始索引不管写 0 还是 1 都是从第一个字符开始截取select substr('abcdefg',0,3) from dual; --abcselect substr('abcdefg',1,3) from dual; --abcselect substr('abcdefg',2,3) from dual; --bcd--获取字符串长度 24 28select length('abcdefg') from dual;--去除字符左右两边的空格select trim(' hello ') from dual;--替换字符串Select replace('hello','l','a') from dual; 3） 日期函数 123456789101112131415161718192021-查询今天的日期（查询的是服务器上的日期）select sysdate from dual;--查询3个月后的今天的日期select add_months(sysdate,3) from dual;--查询3天后的日期select sysdate + 3 from dual;--查询员工入职的天数select sysdate - hiredate from emp;select ceil(sysdate - hiredate) from emp;--查询员工入职的周数select (sysdate - hiredate)/7 from emp;--查询员工入职的月数select months_between(sysdate,hiredate) from emp;--查询员工入职的年份select months_between(sysdate,hiredate)/12 from emp; 4） 转换函数 数值转字符 1234567891011select to_char(sal,'$9,999.99') from emp;select to_char(sal,'L9,999.99') from emp;/*to_char(1210.73, '9999.9') 返回 '1210.7' to_char(1210.73, '9,999.99') 返回 '1,210.73' to_char(1210.73, '$9,999.00') 返回 '$1,210.73' to_char(21, '000099') 返回 '000021' to_char(852,'xxxx') 返回' 354'*/ 日期转字符 to_char() （不区分大小写） 12345678910111213select to_char(sysdate,'yyyy-mm-dd hh:mi:ss') from dual;select to_char(sysdate,'yyyy-mm-dd hh12:mi:ss') from dual; --默认的是24小时制度--只想要年select to_char(sysdate,'yyyy') from dual; --2017--只想要日select to_char(sysdate,'d') from dual; --2 代表一个星期中第几天（美国周天是一个星期的第一天）select to_char(sysdate,'dd') from dual; --10 代表一个月中的第几天select to_char(sysdate,'ddd') from dual; --100 代表一年中的第几天select to_char(sysdate,'day') from dual; --monday（星期的英文）select to_char(sysdate,'dy') from dual; --mon 星期的简写 字符转日期 1234select to_date('2017-04-10','yyyy-mm-dd') from dual;--查询1981年 -- 1985年入职的员工信息select * from emp where hiredate between to_date('1981','yyyy') and to_date('1985','yyyy'); 5） 通用函数 123456789101112131415nvl(参数1,参数2) 如果参数1 = null 就返回参数2 nvl2(参数1,参数2,参数3) 如果参数1 = null ,就返回参数3, 否则返回参数2 nullif(参数1,参数2) 如果参数1 = 参数2 那么就返回 null , 否则返回参数1 coalesce: 返回第一个不为null的值 select nvl2(null,5,6) from dual; --6;select nvl2(1,5,6) from dual; --5;select nullif(5,6) from dual; --5select nullif(6,6) from dual; --nullselect coalesce(null,null,3,5,6) from dual; --3 2、多行函数（聚合函数）对某一列的所有行进行处理 max() min count sum avg 注意：直接忽略空值 例子： 12345--统计员工的平均奖金 550 错误 2200/14 =，因为空值产生的影响select avg(comm) from emp;--统计员工的平均奖金 157.select sum(comm)/count(1) from emp;select ceil(sum(comm)/count(1)) from emp; 3、条件表达式作用：查询的时候用来替换列中所有数据的值，区别于取别名，取别名只是单纯的给子弹取别名 123456789101112131415161718192021222324/*条件表达式： case 字段 when 值1 then 值 when 值2 then 值 else 默认值 end "别名"case、when通用的写法，mysql和oracle中都可以用oracle特有的写法：decode(字段,if1,then1,if2,then2,else1)*/--给表中姓名取一个中文名select case ename when 'SMITH' then '刘备小二' when 'ALLEN' then '萨达' else '路人甲' end "中文名"from emp;--oracle 特有写法select decode(ename,'SMITH','刘备小二','ALLEN','萨达','路人甲') from emp; 八、多表查询1、笛卡尔积实际上是两张表的乘积,但是在实际开发中没有太大意义，格式: select * from 表1,表2 123456select * from emp;select * from dept;select * from emp, dept;select * from emp e1, dept d1 where e1.deptno = d1.deptno; 2、内连接隐式内联接:​ 等值内联接: where e1.deptno = d1.deptno;​ 不等值内联接: where e1.deptno &lt;&gt; d1.deptno;​ 自联接: 自己连接自己 显式内联接:​ select * from 表1 inner join 表2 on 连接条件​ inner 关键字可以省略 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 --查询员工编号,员工姓名,经理的编号,经理的姓名select e1.empno,e1.ename,e1.mgr,m1.enamefrom emp e1, emp m1 where e1.mgr= m1.empno;--查询员工编号,员工姓名,员工的部门名称,经理的编号,经理的姓名select e1.empno,e1.ename,d1.dname,e1.mgr,m1.enamefrom emp e1, emp m1,dept d1 where e1.mgr= m1.empno and e1.deptno = d1.deptno;--查询员工编号,员工姓名,员工的部门名称,经理的编号,经理的姓名,经理的部门名称select e1.empno,e1.ename,d1.dname,e1.mgr,m1.ename,d2.dnamefrom emp e1, emp m1,dept d1,dept d2 where e1.mgr= m1.empno and e1.deptno = d1.deptno and m1.deptno = d2.deptno ;--查询员工编号,员工姓名,员工的部门名称,员工的工资等级,经理的编号,经理的姓名,经理的部门名称select e1.empno,e1.ename,d1.dname,s1.grade,e1.mgr,m1.ename,d2.dnamefrom emp e1, emp m1,dept d1,dept d2,salgrade s1 where e1.mgr= m1.empno and e1.deptno = d1.deptno and m1.deptno = d2.deptno and e1.sal between s1.losal and s1.hisal ;--查询员工编号,员工姓名,员工的部门名称,员工的工资等级,经理的编号,经理的姓名,经理的部门名称,经理的工资等级select e1.empno,e1.ename,d1.dname,s1.grade,e1.mgr,m1.ename,d2.dname,s2.gradefrom emp e1, emp m1,dept d1,dept d2,salgrade s1,salgrade s2 where e1.mgr= m1.empno and e1.deptno = d1.deptno and m1.deptno = d2.deptno and e1.sal between s1.losal and s1.hisal and m1.sal between s2.losal and s2.hisal ;--查询员工编号,员工姓名,员工的部门名称,员工的工资等级,经理的编号,经理的姓名,经理的部门名称,经理的工资等级--将工资等级 1,2,3,4 显示成 中文的 一级 二级 三级...select e1.empno, e1.ename, d1.dname, case s1.grade when 1 then '一级'--为所有列更换成你想要的信息 when 2 then '二级' when 3 then '三级' when 4 then '四级' else '五级' end "等级",--取别名 e1.mgr, m1.ename, d2.dname, decode(s2.grade,1,'一级',2,'二级',3,'三级',4,'四级','五级') "等级"from emp e1, emp m1,dept d1,dept d2,salgrade s1,salgrade s2 where e1.mgr= m1.empno and e1.deptno = d1.deptno and m1.deptno = d2.deptno and e1.sal between s1.losal and s1.hisal and m1.sal between s2.losal and s2.hisal ;--查询员工姓名和员工部门所处的位置select e1.ename,d1.loc from emp e1,dept d1 where e1.deptno = d1.deptno;select * from emp e1 inner join dept d1 on e1.deptno = d1.deptno; 2、外连接外连接: (标准,通用写法)​ 左外连接: left outer join 左表中所有的记录,如果右表没有对 应记录,就显示空​ 右外连接: right outer join 右表中的所有记录,如果左表没有对应记录,就显示空​ outer 关键字可以省略 Oracle中的外连接: (+) 实际上是如果没有对应的记录就加上空值​ select * from emp e1,dept d1 where e1.deptno = d1.deptno(+); 123456select * from emp e1 left outer join dept d1 on e1.deptno = d1.deptno;insert into emp(empno,ename) values(9527,'HUAAN');select * from emp e1,dept d1 where e1.deptno = d1.deptno(+);select * from emp e1 right outer join dept d1 on e1.deptno = d1.deptno;select * from emp e1,dept d1 where e1.deptno(+) = d1.deptno; 九、子查询查询语句中嵌套查询语句; 用来解决复杂的查询语句 1、单行子查询= = &lt; &lt;= &lt;&gt; != 12345678910111213141516171819202122232425262728293031--查询最高工资的员工信息 --1.查询出最高工资 --5000select max(sal) from emp;--2. 工资等于最高工资select * from emp where sal = (select max(sal) from emp);--查询出比雇员7654的工资高,同时和7788从事相同工作的员工信息--1.雇员7654的工资 1250select sal from emp where empno = 7654;--2.7788从事的工作 ANALYSTselect job from emp where empno = 7788;--3.两个条件合并select * from emp where sal &gt; 1250 and job = 'ANALYST';select * from emp where sal &gt; (select sal from emp where empno = 7654) and job = (select job from emp where empno = 7788);--查询每个部门最低工资的员工信息和他所在的部门信息--1.查询每个部门的最低工资,分组统计select deptno,min(sal) minsal from emp group by deptno;--2.员工工资等于他所处部门的最低工资select * from emp e1, (select deptno,min(sal) minsal from emp group by deptno) t1 --将查询到的结果作为一张表进行两表连查where e1.deptno = t1.deptno and e1.sal = t1.minsal; --3.查询部门相关信息select * from emp e1, (select deptno,min(sal) minsal from emp group by deptno) t1, dept d1 where e1.deptno = t1.deptno and e1.sal = t1.minsal and e1.deptno = d1.deptno; 2、多行子查询in not in &gt;any &gt;all exists not exists 通常情况下, 数据库中不要出现null 最好的做法加上Not null​ null值并不代表不占空间, char(100) null 100个字符 12345--查询不是领导的信息select * from emp where empno not in (select mgr from emp);select * from emp where empno &lt;&gt;all(select mgr from emp);--正确的写法select * from emp where empno not in (select mgr from emp where mgr is not null); 3、exists(查询语句) 存在的意思,判断一张表里面的记录是否存在与另外一张表中，作布尔值来处理:， 当查询语句有结果的时候, 就是返回true，否则返回的是false，数据量比较大的时候是非常高效的 12--查询有员工的部门的信息select * from dept d1 where exists(select * from emp e1 where e1.deptno = d1.deptno ); 十、分页 Oracle的分页查询需要使用伪列辅助 伪列 : 在Oracle的结果集中默认带有的可以使用的​ 不出现在结果集列中的内容.​ rownum : 伪列序号, 从1开始​ rowid : 伪列地址 SQL执行顺序​ from .. where ..group by..having .. select..rownum..order by 默认都是从1开始。 1234567891011rownum按照员工id排序后再分页select t.*from ( select rownum rn,e.* from ( select * from emp order by empno ) e ) twhere t.rn between 5 and 9; 123456789101112131415rowid去除表中重复数据create table p( name varchar2(10));insert into p values('黄伟福');insert into p values('赵洪');insert into p values('杨华');delete from p where select rowid,p.* from p;select distinct * from p;delete from p p1 where rowid &gt; (select min(rowid) from p p2 where p1.name = p2.name); 十一、集合运算 所有的查询结果可能不是来自同一张表, 将查询结果进行合并，并去除重复项 1、并集union : 去除重复的,并且排序 union all : 不会去除重复的 1234567select * from emp where sal &gt; 1500unionselect * from emp where deptno = 20;select * from emp where sal &gt; 1500union allselect * from emp where deptno = 20; 2、交集运算: intersect1234567--工资大于1500,并且20号部门下的员工select * from emp where sal &gt; 1500;select * from emp where deptno = 20;select * from emp where sal &gt; 1500intersectselect * from emp where deptno = 20; 3、差集运算两个结果相减 1234567891011--1981年入职员工(不包括总裁和经理)--1981年入职员工select * from emp where to_char(hiredate,'yyyy')='1981';--总裁和经理select * from emp where job = 'PRESIDENT' or job = 'MANAGER';select * from emp where to_char(hiredate,'yyyy')='1981'minusselect * from emp where job = 'PRESIDENT' or job = 'MANAGER'; 4、集合运算中的注意事项1.列的类型要一致2.按照顺序写3.列的数量要一致,如果不足,用空值填充 1234567891011121314151617181920212223select ename,sal from emp where sal &gt; 1500unionselect ename,sal from emp where deptno = 20;--列的类型不匹配select ename,sal from emp where sal &gt; 1500unionselect sal,ename from emp where deptno = 20;--列的数量不匹配select ename,sal,deptno from emp where sal &gt; 1500unionselect ename,sal from emp where deptno = 20;select ename,sal,deptno from emp where sal &gt; 1500unionselect ename,sal,null from emp where deptno = 20;select ename,sal,deptno from emp where sal &gt; 1500unionselect ename,sal,66 from emp where deptno = 20;select * from emp;select * from dept; 十二、DDL语句管理表1、表空间逻辑单位, 通常我们新建一个项目,就会去新建表空间,在表空间中创建用户来创建表 创建表空间 语法:​ create tablespace 表空间的名称​ datafile ‘文件的路径(服务器上)’​ size 大小​ autoextend on 自动扩展​ next 每次扩展的大小 123456--创建表空间-create tablespace canghedatafile 'C:\oracle\canghe.dbf'size 100mautoextend onnext 10m; 删除表空间 12--删除表空间drop tablespace canghe; 2、创建用户 create user 用户名 identified by 密码 default tablespace 表空间的名称 123create user cangheidentified by canghedefault tablespace canghe; 授权 123--授予 dba的角色grant dba to canghe;select * from scott.emp; 3、创建表 create table 表名(​ 列名 列的类型 [列的约束],​ 列名 列的类型 [列的约束]​ ); 列的类型: varchar ,在Oracle中,目前是支持的, 但是不保证以后还支持 varchar2(长度) 可变字符长度 varchar2(10) hello 占5个字符 char(长度) 固定长度字符 char(10) hello 占10个字符,用空格填充 number(总长度,小数长度) 数字类型 --小数长度不能大于等于总长度 date 年月日时分秒 2017/4/13 9:43:49 timestamp 时间戳, 比date类型更加精确 13-APR-17 09.44.08.272000 AM +08:00 LONG/CLOB : 存放一本小说 BLOB : 存放电影 java 存进去, 再读取出来 使用子查询的方式创建表 create table 表名 as 查询语句; 注意: 只会复制表结构和表中的数据,不会复制列的约束 如果查询语句有结果, 就是复制 表结构和数据 如果查询语句没有结果, 就是复制 表结构 1234567create table test1( name1 varchar2(10), name2 char(10), age number(4,2));create table 表名 as 查询语句; 复制表create table emp as select * from scott.emp; 4、修改表 添加咧 alter table 表名 add 列 修改列 修改列类型：modify 修改列名：rename 删除咧 alter table 表名 drop column 列名; 修改列名 alter table 表名 rename column 列名; 重命名表 rename 旧表名 to 新表名; 5、删除表drop table 表名 6、表的五大约束 主键约束 primary key 非空约束 not null 唯一约束 unique 外键约束 添加外键约束： alter table 表名 add foreign key（添加约束的字段） references 引用的表名 （引用的字段） 插入：先主表、再从表 删除：先从表，再主表 强制删除表（不建议）： drop table 表名 cascade constraint; 级联删除: 添加外键约束,使用级联约束 ,在删除的时候,使用级联删除 123456789----添加外键约束,使用级联约束 ,在删除的时候,使用级联删除alter table product add foreign key(cno) references category(cid) on delete cascade;insert into category values(2,'电脑办公');insert into product values(11,'外星人',2);--级联删除 : 首先去从表中找有没有 关联数据, 如果在从表中找到关联数据,先删除从表中关联数据,然后再删除表中的数据delete from category where cid = 2; 检查约束 check( 列名 in (‘值1’,’值2’,’值3’)) 十三、DML管理表数据1、插入数据 指定列名插入 insert into 表名 values(所有列的值都要对应写上) 不指定列名插入 insert into 表名(列1,列2) values(值1,值2); 使用子查询插入 insert into 表名 查询语句 2、修改数据update 表名 set 列名 = 列的值 [where 条件] 3、删除数据delete from 表名 [where 条件] 1234567delete和truncate 区别 delete: truncate: DML DDL 逐条删除 先删除表再创建表 支持事务操作 不支持事务操作, 执行效率要高 十四、其他数据库对象1、事务事务: 就是一系列的操作,要么都成功,要么都失败​ 四大特性: 原子性,隔离性,持久性,一致性​ 如果不考虑隔离级别: 脏读,虚读,不可重复读 MYSQL隔离级别: READ UNCOMMITTED , READ COMMITTED, REPEATABLE READ, SERIALIAZABLE ORACLE隔离级别: READ COMMITTED SERIALIZABLE READ ONLY 默认隔离级别: READ COMMITTED 提交 : commit 事务的保存点/回滚点: savepoint 保存点的名称 回滚: rollback 2、视图视图: 是对查询结果的一个封装​ 视图里面所有的数据,都是来自于它查询的那张表,视图本身不存储任何数据​ 1.能够封装复杂的查询结果​ 2.屏蔽表中的细节​ 语法:​ create [or replace] view 视图的名称 as 查询语句 [ with read only]​ 注意: 通常不要通过视图去修改,视图创建的时候,通常要加上with read only 12345678910--创建一个视图create or replace view view_test1 as select ename,job,mgr from emp;--通过视图修改数据update view_test1 set ename='SMITH2' where ename = 'SMITH';--创建一个只读视图create or replace view view_test2 as select ename,job,mgr from emp with read only;update view_test2 set ename='SMITH3' where ename = 'SMITH2'; -同义词的概念（就是为视图取的一个别名）create synonym dept for view_test3; 3、序列oracle中用来控制自增长的 12345678910111213141516语法: create sequence 序列的名称 start with 从几开始 increment by 每次增长多少 maxvalue 最大值 | nomaxvalue minvalue 最小值 | nominvalue cycle | nocycle 是否循环 1,2,3,1,2,3 cache 缓存的数量3 | nocache 1,2,3,4,5,6 如何从序列获取值 currval : 当前值 nextval : 下一个值 注意: currval 需要在调用nextval之后才能使用 永不回头,往下取数据, 无论发生异常, 回滚 123--序列用的最多的一种写法create sequence seq_test2;select seq_test2.nextval from dual; 4、索引1234567891011121314151617索引:相当于是一本书的目录,能够提高我们的查询效率 如果某一列,你经常用来作为查询条件,那么就有必要创建索引,数据量比较的情况 语法: create index 索引的名称 on 表名(列) 注意:主键约束自带主键索引, 唯一约束自带唯一索引 索引原理: btree balance Tree 平衡二叉树 如果某列作为查询条件的时候,可以提高查询效率,但是修改的时候,会变慢 索引创建好之后,过了一段,DBA都会去做重构索引 SQL调优: 1.查看执行计划F5 2. 分析里面的cost 和 影响行数, 想办法降低 十五、PLSQL编程1、概述procedure Language 过程语言 Oracle对SQL的一个扩展​ 让我们能够像在java中一样写 if else else if 条件, 还可以编写循环逻辑 for while 2、基本语法12345678910declare --声明变量 变量名 变量类型; 变量名 变量类型 := 初始值; vsal emp.sal%type; --引用型的变量 vrow emp%rowtype; --声明记录型变量 begin --业务逻辑,比如输出一句话： dbms_output.put_line()相当于java中 syso end; 12345declare i varchar2(10) := '张三'; begin dbms_output.put_line(i);end; 3、变量%type —引用型变量 %rowtype —记录型变量 4、PL条件判断1234567if then elsif then else end if; 12345678910111213declare age number := &amp;aaa;begin if age &lt; 18 then dbms_output.put_line('小屁孩'); elsif age&gt;=18 and age &lt;=24 then dbms_output.put_line('年轻人'); elsif age&gt;24 and age &lt; 40 then dbms_output.put_line('老司机'); else dbms_output.put_line('老年人'); end if;end; 5、循环操作1234567891011121314while 循环 while 条件 loop end loop; for循环 for 变量 in [reverse] 起始值..结束值 loop end loop; loop循环 loop exit when 条件 end loop; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576--输出1~10declare i number :=1;begin while i&lt;=10 loop dbms_output.put_line(i); i := i+1; end loop;end;--输出1~10declarebegin for i in reverse 1..10 loop dbms_output.put_line(i); end loop;end;--输出1~10declare i number :=1;begin loop exit when i&gt;10; dbms_output.put_line(i); i := i+1; end loop;end;/* * *** ***** *** * 输出 m x : [-m,m] y : [-m,m] 输出所有满足条件的 : abs(y)+abs(x) &lt;=m m取值*/--使用PLSQL输出菱形declare m number := 10;begin for x in -m..m loop for y in -m..m loop if abs(y) + abs(x) &lt;= m then dbms_output.put('*'); else dbms_output.put(' '); end if; end loop; dbms_output.new_line(); end loop; end;--使用PLSQL输出三角形,只要是三个角declare m number := 10;begin for x in reverse -m..m loop for y in -m..m loop if abs(y) + abs(x) &lt;= m and x&gt;=0 then dbms_output.put('*'); else dbms_output.put(' '); end if; end loop; dbms_output.new_line(); end loop; end; 十六、游标用来操作查询的结果集.相当于JDBC中的ResultSe 1234567891011121314151617181920语法: cursor 游标名[(参数名 参数类型)] is 查询结果集 开发步骤: 1. 声明游标 2. 打开游标 open 游标名 3. 从游标中取数据 fetch 游标名 into 变量 游标名%found :找到数据 游标名%notfound : 没有找到数据 4. 关闭游标 close 游标名 系统引用游标 1. 声明游标 : 游标名 sys_refcursor 2. 打开游标: open 游标名 for 结果集 3. 从游标中取数据 4. 关闭游标 for循环遍历游标: 不需要声明额外变量 不需要打开游标 不需要关闭游标 1、不带参数游标123456789101112131415161718192021222324*/--输出员工表中所有的员工姓名和工资(不带参数游标)/* 游标:所有员工 声明一个变量,用来记录一行数据 %rowtype*/declare --游标 cursor vrows is select * from emp; --s声明变量,记录一行数据 vrow emp%rowtype;begin --1.打开游标 open vrows; --2.从游标提取数据 --循环取数据 loop fetch vrows into vrow; exit when vrows%notfound; dbms_output.put_line('姓名:'||vrow.ename ||' 工资: ' || vrow.sal); end loop; --3.关闭游标 close vrows;end; 2、带参数的游标123456789101112131415161718192021--输出指定部门下的员工姓名和工资/* 游标: 指定部门的所有员工 声明一个变量记录一行数据*/declare --声明游标 cursor vrows(dno number) is select * from emp where deptno = dno; --声明变量 vrow emp%rowtype;begin --1.打开游标 , 指定10号部门 open vrows(10); --2. 循环遍历,取数据 loop fetch vrows into vrow; exit when vrows%notfound; dbms_output.put_line('姓名:'||vrow.ename ||' 工资: ' || vrow.sal); end loop; close vrows;end; 3、系统引用游标1234567891011121314151617--输出员工表中所有的员工姓名和工资declare --声明系统引用游标 vrows sys_refcursor; --声明一个变量 vrow emp%rowtype;begin --1.打开游标 open vrows for select * from emp; --2.取数据 loop fetch vrows into vrow; exit when vrows%notfound; dbms_output.put_line('姓名:'||vrow.ename ||' 工资: ' || vrow.sal); end loop; close vrows;end; 4、-使用for循环遍历游标123456789101112131415161718192021222324252627282930313233--按照员工工作给所有员工涨工资,总裁涨1000,经理涨800,其他人涨400/* 游标 : 所有员工 声明一个记录一行数据 */declare --声明游标 cursor vrows is select * from emp; --声明一个变量 vrow emp%rowtype; begin --1.打开游标 open vrows; --2.循环取数据 loop --取数据 fetch vrows into vrow; --退出条件 exit when vrows%notfound; --根据不同的职位,涨工资 总裁涨1000,经理涨800,其他人涨400 if vrow.job = 'PRESIDENT' then update emp set sal = sal + 1000 where empno = vrow.empno; elsif vrow.job = 'MANAGER' then update emp set sal = sal + 800 where empno = vrow.empno; else update emp set sal = sal + 400 where empno = vrow.empno; end if; end loop; --3.关闭游标 close vrows; --4.提交事务 commit;end; 十七、例外例外:(意外)程序运行的过程发生异常,相当于是JAVA中的异常 1234567891011121314151617181920212223declare --声明变量 begin --业务逻辑 exception --处理异常 when 异常1 then ... when 异常2 then ... when others then ...处理其它异常 end; zero_divide : 除零异常 value_error : 类型转换异常 too_many_rows : 查询出多行记录,但是赋值给了rowtype记录一行数据变量 no_data_found : 没有找到数据 自定义异常: 异常名 exception; raise 异常名 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859--查询指定编号的员工,如果没有找到,则抛出自定义的异常/* --错误的演示 1.声明一个变量 %rowtype 2.查询员工信息,保存起来 3.判断员工信息是否为空 4. 如果是 则抛出异常*/declare -- 1.声明一个变量 %rowtype vrow emp%rowtype; --2 .声明一个自定义的异常 no_emp exception; begin --查询员工信息,保存起来 select * into vrow from emp where empno = 8888; --抛出异常 if vrow.sal is null then raise no_emp; --抛出自定义的异常 end if;exception when no_emp then dbms_output.put_line('输出了自定义的异常'); when others then dbms_output.put_line('输出了其它异常'||sqlerrm); end;--查询指定编号的员工,如果没有找到,则抛出自定义的异常/* 游标来判断 %found %notfound 声明一个游标 声明一个变量,记录数据 从游标中取记录 如果有,则不管它 如果没有就抛出自定义的异常*/declare --声明游标 cursor vrows is select * from emp where empno=8888; --声明一个记录型变量 vrow emp%rowtype; --声明一个自定义异常 no_emp exception; begin --1.打开游标 open vrows; --2.取数据 fetch vrows into vrow; --3.判断游标是否有数据 if vrows%notfound then raise no_emp; end if; close vrows;exception when no_emp then dbms_output.put_line('发生了自定义的异常');end; 十八、存储过程12345678910存储过程: 实际上是封装在服务器上一段PLSQL代码片断,已经编译好了的代码 1.客户端取调用存储过程,执行效率就会非常高效 语法: create [or replace] procedure 存储过程的名称(参数名 in|out 参数类型,参数名 in|out 参数类型) is | as --声明部分 begin --业务逻辑 end; 123456789101112131415161718192021222324252627282930313233343536373839*/--给指定员工涨薪,并打印涨薪前和涨薪后的工资/* 参数 : in 员工编号 参数 : in 涨多少 声明一个变量 : 存储涨工资前的工资 查询出当前是多少 打印涨薪前的工资 更新工资 打印涨薪后的工资 */create or replace procedure proc_updatesal(vempno in number,vnum in number)is --声明变量.记录当前工资 vsal number; begin --查询当前的工资 select sal into vsal from emp where empno = vempno; --输出涨薪前的工资 dbms_output.put_line('涨薪前:'||vsal); --更新工资 update emp set sal = vsal + vnum where empno = vempno; --输出涨薪后的工资 dbms_output.put_line('涨薪后:'||(vsal+vnum)); --提交 commit;end;--调用方式1call proc_updatesal(7788,10);--调用方式2 用的最多的方式declarebegin proc_updatesal(7788,-100);end; 十九、存储函数1、基本语法和例子存储函数: 实际上是一段封装是Oracle服务器中的一段PLSQL代码片断,它是已经编译好了的代码片段​​ 语法:​ create [or replace] function 存储函数的名称(参数名 in|out 参数类型,参数名 in|out 参数类型) return 参数类型​ is | as​​ begin​ end; 存储过程和函数的区别: 1.它们本质上没有区别 2.函数存在的意义是给过程调用 存储过程里面调用存储函数 3.函数可以在sql语句里面直接调用 4.存储过程能实现的,存储函数也能实现,存储函数能实现的,过程也能实现 默认是 in 12345678910111213141516171819202122*/--查询指定员工的年薪/* 参数 : 员工的编号 返回 : 年薪 */create or replace function func_getsal(vempno number) return numberis --声明变量.保存年薪 vtotalsal number; begin select sal*12 + nvl(comm,0) into vtotalsal from emp where empno = vempno; return vtotalsal;end;--调用存储函数declare vsal number;begin vsal := func_getsal(7788); dbms_output.put_line(vsal);end; 2、java调用存储过程、存储函数1）基本套路 12345678910111213141516171819202122232425/* JAVA调用存储过程 JDBC的开发步骤: 1.导入驱动包 2.注册驱动 3.获取连接 4.获取执行SQL的statement 5.封装参数 6.执行SQL 7.获取结果 8.释放资源 *//* 封装一个存储过程 : 输出所有表中的记录 输出类型 : 游标 */create or replace procedure proc_getemps(vrows out sys_refcursor)isbegin --1.打开游标, 给游标赋值 open vrows for select * from emp;end; 2）调用存储过程 12345678910111213141516171819202122232425262728293031323334/** * 查询指定员工的年薪，用存储过程实现 * create or replace procedure proc_gettotalsal(vempno in number,vtotalsal out number) is begin select sal*12 + nvl(comm,0) into vtotalsal from emp where empno = vempno; end; * @throws Exception */ public void test1() throws Exception &#123; //注册驱动 Class.forName("oracle.jdbc.driver.OracleDriver"); //获取连接 String url="jdbc:oracle:thin:@106.13.43.205:1521:orcl"; String user="canghe"; String password="canghe"; Connection conn = DriverManager.getConnection(url, user, password); //获取执行对象 String sql="&#123;call proc_gettotalsal(?,?)&#125;"; CallableStatement state = conn.prepareCall(sql); //为问号赋值 state.setInt(1, 7654);//设置员工编号 state.registerOutParameter(2, OracleTypes.NUMBER); //执行statement state.execute(); //获取结果 int totle = state.getInt(2); //输出结果 System.out.println(totle); //释放资源 state.close(); conn.close(); &#125; 3）调用存储函数 123456789101112131415161718192021222324252627282930313233343536//调用存储函数 /* create or replace function func_getsal(vempno number) return number is --声明变量.保存年薪 vtotalsal number; begin select sal*12 + nvl(comm,0) into vtotalsal from emp where empno = vempno; return vtotalsal; end; */public void test2() throws Exception&#123; //注册驱动 Class.forName("oracle.jdbc.driver.OracleDriver"); //2.获取连接 String url = "jdbc:oracle:thin:@106.13.43.205:1521:orcl"; String username = "canghe"; String password = "canghe"; Connection conn = DriverManager.getConnection(url, username,password); //3.获取执行SQL的statement String sql = " &#123;?= call func_getsal(?)&#125;"; CallableStatement state = conn.prepareCall(sql); //4.封装参数 //注册返回类型参数 state.registerOutParameter(1, OracleTypes.NUMBER); //设置第二个参数 state.setInt(2, 7788); //5.执行SQL state.execute(); //6.获取结果 int totalsal = state.getInt(1); System.out.println("年薪 : ====" +totalsal); //7.释放资源 state.close(); conn.close(); &#125; 3）通过游标输出结果集 1234567891011121314151617181920212223242526272829303132333435/** * 通过游标输出结果集 * @throws Exception */ public void test3() throws Exception&#123; //注册驱动 Class.forName("oracle.jdbc.driver.OracleDriver"); //2.获取连接 String url = "jdbc:oracle:thin:@106.13.43.205:1521:orcl"; String username = "canghe"; String password = "canghe"; Connection conn = DriverManager.getConnection(url, username,password); //3.获取执行SQL的statement String sql = "&#123;call proc_getemps(?)&#125;"; CallableStatement call = conn.prepareCall(sql); //接口 --- &gt; 对象 --&gt;实现类的名称 System.out.println(call.getClass().getName()); OracleCallableStatement oracleCall = (OracleCallableStatement)call; //4.注册输出类型的参数 call.registerOutParameter(1, OracleTypes.CURSOR); //5.执行SQL call.execute(); //6.获取执行的结果 ResultSet resultSet = oracleCall.getCursor(1); while(resultSet.next())&#123; int empno = resultSet.getInt("empno"); String name = resultSet.getString("ename"); System.out.println(empno +" ==== "+name); &#125; //7.释放资源 resultSet.close(); call.close(); conn.close(); &#125; 二十、触发器1234567891011121314151617181920212223触发器: 当用户执行了 insert | update | delete 这些操作之后, 可以触发一系列其它的动作/业务逻辑 作用 : 在动作执行之前或者之后,触发业务处理逻辑 插入数据,做一些校验 语法: create [or replace] trigger 触发器的名称 before | after insert | update | delete on 表名 [for each row] declare begin end; 触发器的分类: 语句级触发器: 不管影响多少行, 都只会执行一次 行级触发器: 影响多少行,就触发多少次 :old 代表旧的记录, 更新前的记录 :new 代表的是新的记录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120--新员工入职之后,输出一句话: 欢迎加入黑马程序员create or replace trigger tri_test1afterinserton empdeclarebegin dbms_output.put_line('欢迎加入黑马程序员');end;insert into emp(empno,ename) values(9527,'HUAAN');--数据校验, 星期六老板不在, 不能办理新员工入职--在插入数据之前--判断当前日期是否是周六--如果是周六,就不能插入create or replace trigger tri_test2beforeinsert on empdeclare --声明变量 vday varchar2(10);begin --查询当前 select trim(to_char(sysdate,'day')) into vday from dual; --判断当前日期: if vday = 'saturday' then dbms_output.put_line('老板不在,不能办理入职'); --抛出系统异常 raise_application_error(-20001,'老板不在,不能办理入职'); end if;end;insert into emp(empno,ename) values(9528,'HUAAN2');--更新所有的工资 输出一句话create or replace trigger tri_test3afterupdateon emp for each rowdeclarebegin dbms_output.put_line('更新了数据');end;update emp set sal = sal+10;--判断员工涨工资后的工资一定要大于涨工资前的工资/* 200 --&gt; 100 触发器 : before 旧的工资 新的工资 如果旧的工资大于新的工资 , 抛出异常,不让它执行成功 触发器中不能提交事务,也不能回滚事务 */create or replace trigger tri_updatesalbeforeupdateon empfor each rowdeclarebegin if :old.sal &gt; :new.sal then raise_application_error(-20002,'旧的工资不能大于新的工资'); end if;end;update emp set sal = sal + 10;select * from emp;update emp set sal = sal - 100;/* 模拟mysql中ID的自增属性 auto_increment insert into person(null,'张三'); 触发器: pid=1 insert pid=1 序列 : create sequence seq_person_pid; */create table person( pid number primary key, pname varchar2(20) );insert into person values(null,'张三'); create sequence seq_person_pid;--触发器create or replace trigger tri_add_person_pidbeforeinserton personfor each rowdeclarebegin dbms_output.put_line(:new.pname); --给新记录 pid 赋值 select seq_person_pid.nextval into :new.pid from dual;end;insert into person values(null,'张三'); select * from person; 二十一、数据库设计二十一、数据库优化1.优化SQL:提升sql语句的执行效率​ 1) 查询语句中尽量不使用”*”​ 2) 查询语句中尽量将筛选效果好的条件放在前面​ 3) 可以使用连接查询替代子查询时, 尽量使用连接查询​ 4) 将模糊查询条件尽量放在后面​ 5) 将带有索引的字段条件放在前面​ 6) 可以使用in/not in/between替代的场合,就替代使用​2.优化索引​ 1) 不能随意添加​ 2) 为使用量大的字段添加3.优化表分区(分区表)​ 根据指定字段将数据表的数据(数据巨大时), 划分成多个分区.​ 查询时, 首先判断数据所在分区, 再检索数据​​4.优化系统 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery 知识]]></title>
    <url>%2F2019%2F04%2F13%2FjQuery%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(入)中，欢迎有兴趣的童鞋们关注。 一、jQuery概述1、什么是jQuery？jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。 2、jQuery的核心特性jQuery的核心特性可以总结为：具有独特的链式语法和短小清晰的多功能接口；具有高效灵活的css选择器，并且可对CSS选择器进行扩展；拥有便捷的插件扩展机制和丰富的插件。jQuery兼容各种主流浏览器，如IE 6.0+、FF 1.5+、Safari 2.0+、Opera 9.0+等 3、JQuery的作用: 写更少的代码,做更多的事情: write Less ,Do more 将我们页面的JS代码和HTML页面代码进行分离 二、jQuery入门1、JQ的语法结构1、页面加载完成事件 $(document)..ready(function(){}) $(document).ready()与window.onload类似，但也有区别 window.onload $(document).ready() 执行时机 必须等待网页中所有的内容加载完毕后（包括图片、flash、视频等）才能执行 网页中所有DOM文档结构绘制完毕后即刻执行，可能与DOM元素关联的内容（图片、flash、视频等）并没有加载完 编写个数 同一页面不能同时编写多个 同一页面能同时编写多个 简化写法 无 $(function(){ $(selector).action() $()工厂函数，将dom对象转换为JQ对象 selector：选择器 action()：方法，有事件处理方法 2、JQ的开发步骤:123456789101. 导入JQ相关的文件&lt;script type="text/javascript" src="js/jquery-1.11.0.js"&gt;&lt;/script&gt;通过选择器选择对哪个对象进行操作2. 文档加载完成事件: $(function) : 页面初始化的操作: 绑定事件, 启动页面定时器 $(function () &#123;&#125;——简写$(document)..ready(function()&#123;&#125;) _ 一般写法3. 确定相关操作的事件用JQ选择器选定要绑定事件的按钮或者元素，通过.事件的方法绑定时间，里面再嵌套一个函数4. 事件触发函数5. 函数里面再去操作相关的元素 3、JS和JQ文档流加载区别1234567891011121314151617181920212223242526272829&lt;script&gt; //js文档加载完成的事件 window.onload = function()&#123; alert("window.onload 111"); &#125; window.onload = function()&#123; alert("window.onload 222"); &#125; /*文档加载完成的事件*/ jQuery(document).ready(function()&#123; alert("jQuery(document).ready(function()"); &#125;); /* jQuery 简写成 $ */ $(document).ready(function()&#123; alert("$(document).ready(function()"); &#125;); /* 最简单的写法 */ $(function()&#123; alert("$(function()&#123;"); &#125;); &lt;/script&gt; js会覆盖，而JQ不会覆盖 脚本从上到下执行 onload事件是在页面先加载完再执行， JQ中的页面加载完成事件在页面加载完成后执行但是速度比onload要快，所以脚本文件一般写在页面最底部 3、JQ和JS之间的转换 JQ对象,只能调用JQ的属性和方法 JS对象 只能调用JS的属性和方法 12345678910111213141516171819function changeJS()&#123; var div = document.getElementById("div1");// div.innerHTML = "JS成功修改了内容" //将JS对象转成JQ对象 $(div).html("转成JQ对象来修改内容") &#125; $(function()&#123; //给按钮绑定事件 $("#btn2").click(function()&#123; //找到div1// $("#div1").html("JQ方式成功修改了内容"); //将JQ对象转成JS对象来调用 var $div = $("#div1");// var jsDiv = $div.get(0); var jsDiv = $div[0]; jsDiv.innerHTML="jq转成JS对象成功"; &#125;); &#125;); 4、JQ操作样式1、css（）方法 单个样式：css(“属性”,”属性值”) 多个样式：css(“属性”:”属性值”,”属性”:”属性值”); 2、addClass()方法：在括号内直接写类名即可，不用加点 样式多的时候使用 链式操作（选择器选择了一个元素.next()代表下一个元素，children（”a”)代表下一个名字是a的子元素）和隐式迭代 5、JQ常用方法mouseover():鼠标悬浮 mouseout():鼠标移出 show()：显示 hide()：隐藏 index()方法，用于获取对应元素在父级中的下标 123456789101112$(".nav ul li").click(function()&#123; var index = $(".nav ul li").index(this); $(".nav ul li:eq(" + index + ") dt").toggle( function()&#123; $(".nav ul li:eq(" + index + ") dd").slideDown(); &#125;, function () &#123; $(".nav ul li:eq(" + index + ") dd").slideUp(); &#125; ) &#125;); 三、JQuery中的选择器 1、基本选择器 ID选择器 : #ID的名称 类选择器: 以 . 开头 .类名 元素（标签）选择器: 标签的名称 通配符（全局）选择器: * 并集选择器: 选择器1，选择器2 案例： 12345678910111213141516171819202122232425262728293031323334&lt;!-- - ID选择器 : #ID的名称 - 类选择器: 以 . 开头 .类名 - 元素选择器: 标签的名称 - 通配符选择器: * - 选择器,选择器: 选择器1,选择器2 --&gt; &lt;script&gt; //文档加载事件,页面初始化的操作 $(function()&#123; //初始化操作: 给按钮绑定事件 $("#btn1").click(function()&#123; $("#two").css("background-color","palegreen"); &#125;); //找出mini类的所有元素 $("#btn2").click(function()&#123; $(".mini").css("background-color","palegreen"); &#125;); $("#btn3").click(function()&#123; $("div").css("background-color","palegreen"); &#125;); $("#btn4").click(function()&#123; $("*").css("background-color","palegreen"); &#125;); /*选择器分组*/ //找出mini类 和 span元素 $("#btn5").click(function()&#123; $(".mini,span").css("background-color","palegreen"); &#125;); &#125;); &lt;/script&gt; 2、层级选择器 子元素选择器: 选择器1 &gt; 选择器2（只能是儿子） 后代选择器: 选择器1 儿孙 相邻兄弟选择器 : 选择器1 + 选择器2 : 找出紧挨着的同辈元素（第一个弟弟） 通用兄弟选择器: 选择器1~ 选择器2 : 找出所有选择器1之后的同辈元素 123456789101112131415161718192021&lt;script&gt; //文档加载事件,页面初始化的操作 $(function()&#123; //初始化操作: 给按钮绑定事件 //找出body下面的子div $("#btn1").click(function()&#123; $("body &gt; div").css("background-color","palegreen"); &#125;); //找出body下面的所有div $("#btn2").click(function()&#123; $("body div").css("background-color","palegreen"); &#125;); $("#btn3").click(function()&#123; $("#one+div").css("background-color","palegreen"); &#125;); $("#btn4").click(function()&#123; $("#two~div").css("background-color","palegreen"); &#125;); &#125;); &lt;/script&gt; 3、属性选择器 a[name]含有属性名为name的元素 a[name=”value”]有属性名为name的属性值为value元素 a[name^=”value”]含有属性名为name的属性值以value开头元素 a[name$=”value”]含有属性名为name的属性值以value结尾元素 a[name*=”value”]含有属性名为name的属性值包含value的元素 4、JQ中的基本过滤器通过特定的过滤规则来筛选出所需的元素 基本过滤选择器(索引一律从0开始) ::even：选取索引为偶数的元素 ::odd：选取索引为奇数的元素 eq（index）：选取索引为index的元素 :gt（index）：选取索引大于index的元素 :lt（index）：选取索引小于index的元素 :header：选取所有标题元素（h1-h6） :focus：选取当前获取焦点的元素 :animated：选取所有动画 可见性过滤选择器s hidden：选择所有隐藏的元素（能选到display-none、hide（）、type=“hidden” visible：选择所有可见的元素 表单对象 内容/子元素过滤选择器 特殊符号的转义：\ 选择器的书写规范很严格，多一个空格或少一个空格，都会影响选择器的效果 12345678910111213141516171819202122232425&lt;script&gt; $(function()&#123; /&lt;script&gt; //文档加载事件,页面初始化的操作 $(function()&#123; //初始化操作: 给按钮绑定事件 //过滤出所有div中第一个元素 $("#btn1").click(function()&#123; $("div:first").css("background-color","palegreen"); &#125;); //过滤出所有div中偶数位的div $("#btn2").click(function()&#123; $("div:even").css("background-color","palegreen"); &#125;); $("#btn3").click(function()&#123; $("div:odd").css("background-color","palegreen"); &#125;); $("#btn4").click(function()&#123; $("div:gt(2)").css("background-color","palegreen"); &#125;); &#125;);&lt;/script&gt; 5、JQ中的属性选择器123456789101112$(function()&#123; //找到有name属性的input $("#btn1").click(function()&#123; $("input[name]").attr("checked",true); &#125;); $("#btn2").click(function()&#123; $("input[name='accept']").attr("checked",true); &#125;); $("#btn3").click(function()&#123; $("input[name='newsletter'][value='Hot Fuzz']").attr("checked",true); &#125;); &#125;); 5、JQ中的表单过滤器:selected :checked JQ中用的是submit（）方法提交表单 JS用的是onsubmit=“return login 123456&lt;script&gt; //1.文档加载事件 $(function()&#123; $(":text").css("background-color","pink"); &#125;);&lt;/script&gt; 四、JQ中常用函数及遍历数组12345678910111213141516171819202122232425262728293031$(function) : 文档加载完成的事件css() : 修改css样式prop() : 修改属性/ 获取属性html() : 修改innerHTMLappend : 给自己添加子节点appendTo : 将自己添加到别人家,给自己找一个爹prepend : 在自己最前面添加子节点after : 在自己后面添加一个兄弟empty : 清空所有子节点遍历子元素children()方法可以用来获取元素的所有子元素遍历同辈元素next()用于获取紧邻匹配元素之后的元素prev()用于获取紧邻匹配元素之前的元素slibings()用于获取位于匹配元素前面和后面的所有同辈元素遍历前辈元素parent()获取元素的父级元素parents()：元素元素的祖先元素each( ) ：规定为每个匹配元素规定运行的函数$(cities).each(function(i,n)&#123; &#125;)$.each(arr,function(index,element)&#123; &#125;);end()将当前对象向上一级返回,：结束当前链条中的最近的筛选操作，并将匹配元素集还原为之前的状态，如$("ul li").first().css("color","red").end().last()选择的是ul下面的最后一个li 五、JQ中的事件和动画效果1、事件 1、基础事件 鼠标事件 click（）：鼠标点击 mouseover/mouseout：鼠标悬浮/离开（被选元素+子元素） mouseenter/mouseleave:鼠标悬浮/离开(被选元素) 键盘事件 keydown /keyup：键盘按下和松开 keypress：键盘按下产生可打印的字符时 按下回车键触发的特效 12345$(document).keydown(function(even)&#123; if(even.keyCode==13)&#123; alert("确认要提交吗？) &#125;&#125;) window事件 resize（）：浏览器事件，调整窗口大小时，完成页面特效 表单事件 常用于搜索框，未点击搜索框时，有提示信息，点击搜索框时候提示信息就消失了 鼠标聚焦：focus 失去焦点：blur 2、复合事件 鼠标光标悬停 hover()方法相当于mouseover与mouseout事件的组合 hover(fn1,fn2) 鼠标连续点击 toggle()方法用于模拟鼠标连续click事件 123456789101112131415161718191、toggle():与show( )和hide( )方法作用一样，点击显示，再点击隐藏2、toggle(fn1,fn2,...),仅支持1.8.0以上版本点击几次就有几个function $("input:first").toggle( function()&#123; $("div").css("background","red"); &#125;, function()&#123; $("div").css("background","blue"); &#125;, function()&#123; $("div").css("background","green"); &#125; );3、toggleClass（）可以对样式进行切换，前提是先要在css样式中写上相应的类样式，如：.red $("input:last").click(function()&#123; $("p").toggleClass("red"); &#125;); 3、绑定和移出事件 绑定：on/bind (on和bind都可以用作事件绑定，但是on绑定事件对于新增元素也有效) 1234567891、绑定单个事件：on("click",function()&#123;&#125;)2、绑定多个事件on(&#123; "click":a=function()&#123;&#125;, "click":b=funtioon()&#123;&#125;&#125;) 移出绑定off/unbind 12345移出绑定前需要对绑定的事件命名1、移出所有绑定的事件 off()2、移出指定名字的事件off("click",a) 2、动画效果 show()显示 hide()隐藏 slideUp使元素逐步缩短直至隐藏 slideDown可以使元素逐步延伸显示 fadeIn fadeOut animate : 自定义动画： $(selector).animate({params},speed,callback) params：必须，定义形成动画的CSS属性 stop： 无参：停止当前 一个参数：停止所有 两个参数：停止所有，并回到动画最终的位置 六、jQuery中的DOM操作1、css操作 添加样式 css()，单个样式css(“name”,”value”)，多个样式：css(“{name1”:”value1”,”name2”,”value2”}) addClass：添加类样式，多个用空格隔开 height：设置或返回匹配元素的高度 width：设置或返回匹配元素的宽度 offset：返回以像素为单位的top和left坐标。仅对可见元素有效 offsetParent：返回最近的已定位祖先元素。定位元素指的是元素的CSSposition值被设置为relative、absolute或fixed的元素 position：返回第一个匹配元素相对于父元素的位置 scrollLeft：参数可选。设置或返回匹配元素相对滚动条左侧的偏移 scrollTop：参数可选。设置或返回匹配元素相对滚动条顶 12345678910111213141516171819制作页面小广告随滚动条滚动$(document).ready(function()&#123; //获取初识位置 var topEle=parseInt($("#adver").css("top")); var leftEle=parseInt($("#adver").css("left")); //滚轮滚动事件 $(window).scroll(function () &#123; //获取该变量 var changeTop=$(this).scrollTop(); var changeLeft=$(this).scrollLeft(); //得到改变后的位置 var endTop=changeTop+topEle+"px"; var endLeft=changeLeft+leftEle+"px"; $("#adver").css(&#123;"top":endTop,"left":endLeft&#125;); &#125;)&#125;) 移除样式 removeClass 切换样式 toggleClass（需要和hover一起使用） 判断是否包含某样式 haseClass 2、HTML代码操作123html()：获取元素的html代码html("&lt;div class='content'&gt;…&lt;/div&gt;");：设置元素中的HTML代码 3、标签内容操作123text();：获取元素中的文本内容text("&lt;div class='content'&gt;…&lt;/div&gt;");text和html 的区别：text不会去解析HTML标签，只会解析文本 4、属性和属性值操作1234val()无参代表获取value值，有值即表示设置value的值att()获取属性attr("class","blua")代表设置class属性RemoveAttr()：移出属性 5、节点操作 创建节点 1$()工厂函数可直接创建节点 插入节点 123456789101、有父子元素的插入将儿子F加到父亲E的最后（父E,子F）E.append(F)：F.append(E)：将儿子F加到父亲E的最前面（父E,子F）E.prepend(F)：F.prependTo(E)2、插入同辈节点A.after(B)：将B插到A的后面(beforeD代表前)A.insertAfter(B)：将A插到B的后面(insertbeforeD代表前) 删除节点 remove：删除整个节点，包括结构 empty：清空节点里面的内容，但结构保留 detach：删除整个节点，但是保留事件 替换节点 replaceWith(同append) replaceAll(同appendTo) 复制节点 clone()：纯粹复制节点 clone(true)：节点里面绑定的事件也会被复制 六、使用JQuery完成页面定时弹出广告1、 需求分析当用户打开界面，3秒钟之后弹出广告，这个广告显示5秒钟，隐藏广告 2、 技术分析定时器: setTimeout 显示和隐藏: style.display = “block/none” 3、步骤分析 导入JQ的文件 编写JQ的文档加载事件 启动定时器 setTimeout(“”,3000); 编写显示广告的函数 在显示广告里面再启动一个定时器 编写隐藏广告的函数 4、代码实现1234567891011121314&lt;script&gt; //显示广告 function showAd()&#123; $("#img1").slideDown(2000); setTimeout("hideAd()",3000); &#125; //隐藏广告 function hideAd()&#123; $("#img1").slideUp(2000); &#125; $(function()&#123; setTimeout("showAd()",3000); &#125;); &lt;/script&gt; 七、使用JQ完成表格的隔行换色1、需求分析在我们的实际开发过程中,我们的表格如果所有的行都是一样的话,很容易看花眼,所以我们需要让我们的表格隔行换色 2、技术分析获取所有行 table.rows 遍历所有行 根据行号去修改每一行的背景颜色: bgColor ​ style.backgroundColor = “red” 3、步骤分析 导入JQ的包 文档加载完成函数: 页面初始化 获得所有的行 : 元素选择器 根据行号去修改颜色 5、代码实现123456789 $(function()&#123; //获得所有的行 : 元素选择器 $("tbody &gt; tr:even").css("background-color","#CCCCCC"); //修改基数行 $("tbody &gt; tr:odd").css("background-color","#FFF38F");// $("tbody &gt; tr").css("background-color","#FFF38F"); &#125;); 八、使用JQuery完成表单的全选全不选功能以及隔行换色1、需求分析在我们对表格处理的时,有些情况下,我们需要对表格进行批量处理,，隔行换色 2、代码实现:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.0.js"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $("tr:even:gt(0)").css("background-color","#CCCCCc"); //鼠标点击后触发 $("tr:odd").mousedown(function()&#123; $("tr:odd").css("background-color","red"); &#125;); //通过鼠标在元素上移动 $("tr:odd").mousemove(function()&#123; $("tr:odd").css("background-color","yellow"); &#125;); //mouseout事件在鼠标从元素上离开后会触发 $("tr:odd").mouseout(function()&#123; $("tr:odd").css("background-color","blue"); &#125;); //为元素绑定函数，点击 $("#cheack1").click(function()&#123; //全选和取消全选 $("input[type='checkbox']:gt(0)").prop("checked",this.checked); $("body &gt; table &gt; tbody &gt; tr:nth-child(2) &gt; td:nth-child(1) &gt; input[type="checkbox"]") &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;table border="1px" width="300px" cellpadding="0" cellspacing="0"&gt; &lt;tr&gt; &lt;th&gt;&lt;input type="checkbox" id="cheack1"/&gt;&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;爱好&lt;/th&gt; &lt;/tr&gt; &lt;tr align="center"&gt; &lt;td&gt;&lt;input type="checkbox"/&gt;&lt;/td&gt; &lt;td &gt;江彬&lt;/td&gt; &lt;td&gt;24&lt;/td&gt; &lt;td&gt;编程&lt;/td&gt; &lt;/tr&gt; &lt;tr align="center"&gt; &lt;td&gt;&lt;input type="checkbox"/&gt;&lt;/td&gt; &lt;td&gt;初识&lt;/td&gt; &lt;td&gt;22&lt;/td&gt; &lt;td&gt;看书&lt;/td&gt; &lt;/tr&gt; &lt;tr align="center"&gt; &lt;td&gt;&lt;input type="checkbox"/&gt;&lt;/td&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;26&lt;/td&gt; &lt;td&gt;鞋子&lt;/td&gt; &lt;/tr&gt; &lt;tr align="center"&gt; &lt;td&gt;&lt;input type="checkbox"/&gt;&lt;/td&gt; &lt;td&gt;王五&lt;/td&gt; &lt;td&gt;23&lt;/td&gt; &lt;td&gt;看电影&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 九、使用JQ完成省市联动效果1、需求分析在我们的注册表单中,通常我们需要知道用户的籍贯,需要一个给用选择的项,当用户选中了省份之后,列出省下面所有的城市 2、技术分析 准备工作 : 城市信息的数据 添加节点 : appendChild (JS) append : 添加子元素到末尾 appendTo : 给自己找一个爹,将自己添加到别人家里 prepend : 在子元素前面添加 after : 在自己的后面添加一个兄弟 遍历的操作: 3、步骤分析 导入JQ的文件 文档加载事件:页面初始化 进一步确定事件: change事件 函数: 得到当前选中省份 得到城市, 遍历城市数据 将遍历出来的城市添加到城市的select中 4、代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;省市联动效果制作&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.0.js"&gt;&lt;/script&gt; &lt;script&gt; /* 准备工作 : 准备数据 */ var provinces = [ ["深圳市","东莞市","惠州市","广州市"], ["长沙市","岳阳市","株洲市","湘潭市"], ["厦门市","福州市","漳州市","泉州市"] ]; $(function () &#123; $("#province").change(function()&#123; var citys=provinces[this.value]; //清空城市信息 $("#city").empty(); //遍历城市信息 $(citys).each(function(i,n)&#123; $("#city").append("&lt;option&gt;"+n+"&lt;/option&gt;"); &#125;) &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--选择省份--&gt;&lt;select name="sheng" id="province"&gt; &lt;option value="1"&gt;请选择&lt;/option&gt; &lt;option value="0"&gt;广东&lt;/option&gt; &lt;option value="1"&gt;湖南&lt;/option&gt; &lt;option value="2"&gt;福建&lt;/option&gt;&lt;/select&gt;&lt;!--选择城市--&gt;&lt;select name="city" id="city"&gt;&lt;/select&gt;&lt;/body&gt;&lt;/html&gt; 十、使用JQ完成下拉列表左右选择1、代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.11.0.js" &gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; //双击添加至右边 $("#leftSelect option").dblclick(function()&#123; $("#rightSelect").append($("#leftSelect option:selected")); &#125;); $("#a1").click(function()&#123; //找到被选中的那一项 //将被选中项添加到右边 $("#rightSelect").append($("#leftSelect option:selected")); &#125;); //将左边所有商品移动到右边 $("#a2").click(function()&#123; $("#rightSelect").append($("#leftSelect option")); &#125;); //将右边商品点击选中放入左边 $("#b1").click(function()&#123; $("#leftSelect").append($("#rightSelect option:selected")) &#125;) //将右边所有商品选中放入左边 $("#b2").click(function()&#123; $("#leftSelect").append($("#rightSelect option")) &#125;) //双击添加至左边 $("#rightSelect option").dblclick(function()&#123; $("#leftSelect").append($("#rightSelect option:selected")) &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;table border="1px" width="400px"&gt; &lt;tr&gt; &lt;td&gt;分类名称&lt;/td&gt; &lt;td&gt;&lt;input type="text" value="手机数码"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;分类描述&lt;/td&gt; &lt;td&gt;&lt;input type="text" value="这里面都是手机数码"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;分类商品&lt;/td&gt; &lt;td&gt; &lt;!--左边--&gt; &lt;div style="float: left;"&gt; 已有商品&lt;br/&gt; &lt;select multiple="multiple" id="leftSelect"&gt; &lt;option&gt;华为&lt;/option&gt; &lt;option&gt;小米&lt;/option&gt; &lt;option&gt;锤子&lt;/option&gt; &lt;option&gt;oppo&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; &lt;a href="#" id="a1"&gt; &amp;gt;&amp;gt; &lt;/a&gt; &lt;br/&gt; &lt;a href="#" id="a2"&gt; &amp;gt;&amp;gt;&amp;gt; &lt;/a&gt; &lt;/div&gt; &lt;!--右边--&gt; &lt;div style="float: right;"&gt; 未有商品&lt;br/&gt; &lt;select multiple="multiple" id="rightSelect"&gt; &lt;option&gt;苹果6&lt;/option&gt; &lt;option&gt;肾7&lt;/option&gt; &lt;option&gt;诺基亚&lt;/option&gt; &lt;option&gt;波导&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; &lt;a href="#" id="b1"&gt; &amp;lt;&amp;lt; &lt;/a&gt; &lt;br/&gt; &lt;a href="#" id="b2"&gt; &amp;lt;&amp;lt;&amp;lt; &lt;/a&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2"&gt; &lt;input type="submit" value="提交"/&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 十一、JQ完成表单表单验证123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118$(document).ready(function () &#123; //失焦事件 $("#fname").blur(checkFname); $("#lname").blur(checklname); $("#sname").blur(checkSname); $("#pass").blur(checkPassword); $("#email").blur(checkEmail); //聚焦 //表单提交 $("#formRegister").submit(function()&#123; if(!checkFname())&#123; return false; &#125;else if(!checklname())&#123; return false; &#125;else if(!checkSname())&#123; return false; &#125;else if(!checkPassword())&#123; return false; &#125;else if(!checkEmail())&#123; return false; &#125; return true; &#125;) //验证名字 function checkFname()&#123; if($("#fname").val()=="")&#123; $("#spanfname").html("名字不能为空").css("color","red"); return false; &#125;else&#123; $("#spanfname").html(""); &#125; return true; &#125;; //验证姓氏 function checklname()&#123; if($("#lname").val()=="")&#123; $("#spanlname").html("姓氏不能为空").css("color","red"); return false; &#125;else&#123; $("#spanlname").html(""); &#125; return true; &#125;; //验证登录名 function checkSname()&#123; var sname=$("#sname").val(); var reg=/^[a-z0-9_]$/; if(sname=="")&#123; $("#spansname").html("登录名不能为空").css("color","red"); return false; &#125;else if(reg.test(sname)==false)&#123; $("#spansname").html("登录名格式不正确").css("color","red"); return false; &#125;else&#123; $("#spansname").html(""); &#125; return true; &#125;; //验证密码 function checkPassword()&#123; var psd=$("#pass").val(); //if(psd=="")&#123; // $("#spanpass").html("密码不能为空").css("color","red"); // return false; //&#125;else if(psd.length&lt;6)&#123; // $("#spanpass").html("密码不能少于6位").css("color","red"); // return false; //&#125;else&#123; // $("#spanpass").html(""); //&#125; var reg=/^\w&#123;6&#125;$/; if(psd=="")&#123; $("#spanpass").html("密码不能为空").css("color","red"); return false; &#125;else if(reg.test(psd)==false)&#123; $("#spanpass").html("密码不能少于6位").css("color","red"); return false; &#125;else&#123; $("#spanpass").html(""); &#125; return true; &#125;; //验证邮箱 function checkEmail()&#123; var email=$("#email").val(); //if(email=="")&#123; // $("#spanemail").html("不能为空").css("color","red"); // return false; //&#125;else if(email.indexOf("@")==-1)&#123; // $("#spanemail").html("必须含有@符号").css("color","red"); // return false; //&#125;else if(email.indexOf(".")==-1) &#123; // $("#spanemail").html("必须含有.符号").css("color", "red"); // return false; //&#125;else&#123; // $("#spanemail").html(""); //&#125; var reg=/^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]&#123;2,6&#125;)$/; if(reg.test(email)==false)&#123; $("#spanemail").html("邮箱格式不正确").css("color","red"); return false; &#125;else&#123; $("#spanemail").html(""); &#125; return true; &#125;;&#125;) 补充：使用HTML5进行表单验证 123456789101112131415161718192021222324252627282930313233343536373839404142/** * JS代码 Created by zongjuan.wang on 2016/7/6. */$(document).ready(function()&#123; $("#submit").click(function()&#123; var u=document.getElementById("uName"); if(u.validity.valueMissing==true)&#123;//输入为空 u.setCustomValidity("昵称不能为空");//自定义错误提示信息 &#125; else if(u.validity.patternMismatch==true)&#123;//输入内容格式与正则表达式不匹配 u.setCustomValidity("昵称必须是6~10位的英文和数字"); &#125; else&#123; u.setCustomValidity(""); &#125; var pwd=document.getElementById("pwd"); if(pwd.validity.valueMissing==true)&#123; pwd.setCustomValidity("密码不能为空"); &#125; else if(pwd.validity.patternMismatch==true)&#123; pwd.setCustomValidity("密码必须是6~16位的英文和数字"); &#125; else&#123; pwd.setCustomValidity(""); &#125; var email=document.getElementById("email"); if(email.validity.valueMissing==true)&#123; email.setCustomValidity("邮箱不能为空"); &#125; else if(email.validity.typeMismatch==true)&#123; email.setCustomValidity("邮箱格式不正确"); &#125; else&#123; email.setCustomValidity(""); &#125; &#125;)&#125;) html代码片段 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!doctype html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="Generator" content="EditPlus®"&gt; &lt;meta name="Author" content=""&gt; &lt;meta name="Keywords" content=""&gt; &lt;meta name="Description" content=""&gt; &lt;title&gt;仿QQ注册&lt;/title&gt; &lt;link href="css/style.css" rel="stylesheet"/&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;h2 class="reg-top"&gt;&lt;/h2&gt; &lt;div class="reg-box"&gt; &lt;div class="reg-main"&gt; &lt;h3&gt;注册账号&lt;/h3&gt; &lt;form action="index.html" method="post" class="reg-form"&gt; &lt;div class="reg-input"&gt; &lt;label&gt;&lt;i&gt;*&lt;/i&gt;昵称：&lt;/label&gt; &lt;input type="text" id="uName" required placeholder="英文、数字长度为6-10个字符" pattern="[a-zA-Z0-9]&#123;6,10&#125;" /&gt; &lt;/div&gt; &lt;div class="reg-input"&gt; &lt;label&gt;&lt;i&gt;*&lt;/i&gt;密码：&lt;/label&gt; &lt;input type="password" id="pwd" required placeholder="长度为6-16个字符" pattern="[a-zA-Z0-9]&#123;6,16&#125;"/&gt; &lt;/div&gt; &lt;div class="reg-input"&gt; &lt;label&gt;手机号码：&lt;/label&gt; &lt;input type="text" pattern="^1[34578][0-9]&#123;9&#125;$"/&gt; &lt;span id="tel-tip"&gt;忘记密码时找回密码使用&lt;/span&gt; &lt;/div&gt; &lt;div class="reg-input"&gt; &lt;label&gt;&lt;i&gt;*&lt;/i&gt;邮箱：&lt;/label&gt; &lt;input type="email" required id="email"/&gt; &lt;/div&gt; &lt;div class="reg-input"&gt; &lt;label&gt;年龄：&lt;/label&gt; &lt;input type="number" min="12"/&gt; &lt;/div&gt; &lt;div class="submit-box"&gt; &lt;input type="submit" id="submit" value="立即注册" &gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="js/jquery-1.12.4.js"&gt;&lt;/script&gt; &lt;script src="js/reg.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 十二、正则表达式1、声明1var reg=/^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]&#123;2,6&#125;)$/; 2、test方法1if(reg.test(email)==false)&#123; 3、手册及常用正则表达式http://tool.oschina.net/uploads/apidocs/jquery/regexp.html 4、String对象与正则表达式 方法 描述 match（） 找到一个或多个正则表达式的匹配 search（） 检索与正则表达式相匹配的值 replace（） 替换与正则表达式相匹配的字符串 split（） 把字符串分割成字符串数组 g代表全局匹配，i代表忽略大小写 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>JavaWeb前端基础</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse 配置 Servlet 模板]]></title>
    <url>%2F2019%2F04%2F13%2FEclipse%E9%85%8D%E7%BD%AEServlet%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[有时候新建servlet时候会生成很多我们不是想要的东西，每一次都去复制黏贴，手动删除我们不想要的东西，那么如何设置专属自己的模板呢？只需要输入短短几个字，然后ALT+/即可： 这里以Eclipse4.5.2版本为例： 1.打开Eclilpse，Window-&gt;Preferences 2.Java-&gt;Editor-&gt;Templates-&gt;New 配置如图： Pattern内容如下：1234567891011121314151617package $&#123;enclosing_package&#125;;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse; public class $&#123;primary_type_name&#125; extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.getWriter().write("hello haohao..."); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 勾选上“Use code formatter”-&gt;Apply-&gt;OK3.重启Eclipse 4.使用Alt+/来快速匹配出模板，创建出简单清晰的Servlet 原文：https://blog.csdn.net/czkct/article/details/78750478 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>eclipse</category>
      </categories>
      <tags>
        <tag>eclipse</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 基础知识]]></title>
    <url>%2F2019%2F04%2F13%2FJavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(ru)中，欢迎有兴趣的童鞋们关注。 一、概述1、 JavaScript概述和特点概述：是一种基于对象和事件驱动的脚本语言 特点：交互、脚本语言，解释性语言，边执行边解释 2、什么是脚本语言? java源代码 ——&gt; 编译成.class文件 ——-&gt; java虚拟机中才能执行 脚本语言: 源码 ———— &gt; 解释执行，js由我们的浏览器来解释执行 HTML: 决定了页面的框架 CSS: 用来美化我们的页面 JS: 提供用户的交互的 3、JS的组成: ECMAScript : 核心部分 ,定义js的语法规范，是一种语法标准 DOM： document Object Model 文档对象模型 , 主要是用来管理页面的 BOM：Browser Object Model 浏览器对象模型, 前进,后退,页面刷新, 地址栏, 历史记录, 屏幕宽高 4、JavaScript基本结构1234 &lt;script type="text/javascript"&gt; javascript语句 &lt;/script&gt;如果要引入外部js脚本，直接在script右面添加一个src属性即可 二、JS语法1、语法变量弱类型: var i = true 区分大小写 语句结束之后的分号 ,可以有,也可以没有，最好写 写在script标签 2、JS的数据类型: 基本类型 string split:：分割 join：拼接字符串 number boolean undefine：未定义 null 注意：undefine==null定义为是相等的 引用类型 对象, 内置对象 常用内置对象有： Array、String、Math、Date Date内置对象： 按照：2018年11月12日22：3：59：格式显示，注意获得年使用getFullYear（）方法 123456789var date=new Date(); var year=date.getFullYear(); var month=date.getMonth(); var day = date.getDate(); var hour=date.getHours(); var minute=date.getMinutes(); var second=date.getSeconds(); var ele=document.getElementById("datetime"); ele.innerHTML=year+"年"+month+"月"+day+"日"+hour+"："+minute+"："+second+"："; typeof操作符来检测变量的数据类型 创建数组 var arr=[“a”,”b”,”c”] var arr = new Array(“a”,”b”,”c”) 数组sort方法：是排序 push方法是向后添加元素，返回新数组的长度，直接将原数组打印即可 类型转换 js内部自动转换 通过函数转换：parseInt（）转换为整数 parseInt(“aaa123”)=NAN parseInt(“123aaa”)=123 parseFloat（）转换为浮点数 3、JS的运算符和语句 运算符和java 一样 “===” 全等号: 值和类型都必须相等 == 值相等就可以了 语句和java 一样 123==和===的区别==不会严格区分数据类型===会严格区分数据类型 123“1”==true 正确&quot;0&quot;==false 正确“true”=true 错误 4、JS的输出 alert() 直接弹框 document.write() 向页面输出 console.log() 向控制台输出 innerHTML: 向页面输出 获取页面元素: document.getElementById(“id的名称”); window.location=”页面地址”，让窗口的地址跳到指定页面去 prompt（）可以是一个参数或者两个参数，弹出窗口，让用户输入值，有返回值，需要对返回值进行强制类型转换的时候需要用到部分常用的系统函数 5、JS声明变量:var 变量的名称 = 变量的值 6、JS声明函数var 函数的名称 = function(){ ​ } function 函数的名称(){ ​ } js常用的系统函数 parseInt（）转换为整数 parseFloat（）转换为浮点数 isNaN（）：贩毒案非数字 eval（），计算表达式的值 7、创建对象 Object 1234var 对象名 = new Object（）属性：对象名.属性名=“”；方法：对象名.showName=function()&#123;&#125;调用方法：对象名.showName(); ECMAScript提供的一种原生引用类型 可以通过Object引用类型的实例创建一个对象 可以为对象定义属性和方法 Object实例本身不具备多少功能，一般在应用程序中存储和传递数据 使用Object创建对象 123456789101112131415161718192021&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; //使用object创建对象 var user = new Object(); //对象的属性 user.name="张三"; user.psd="12345566"; //对象的方法（函数） user.showInfo=function()&#123; document.write(this.name+"-"+this.psd) &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" value="点我啊" onclick="user.showInfo()"/&gt;&lt;/body&gt;&lt;/html&gt; 对象字面量方式创建对象 对象字面量是对象定义的一种简写方式 会简化创建包含大量属性的对象的过程 在为函数传递大量可选参数时，可考虑使用对象字面量 创建代码实现 1234567891011121314151617&lt;script type="text/javascript"&gt; //使用对象字面量创建对象 var user=&#123; name="张三"; psd="12334"; showInfo:function()&#123; document.write(this.name+"-"+this.psd) &#125; &#125; //使用对象字面量创建对象的第二种方式 var user2=&#123;&#125;; user2.name="李四"; user2.psd="123"; user2.showInfo= function () &#123; document.write(this.name+"-"+this.psd) &#125; &lt;/script&gt; 工厂模式创建对象 工厂模式是软件工程领域的一种设计模式 抽象了创建对象的过程 通过函数封装创建对象的细节 代码实现 12345678910//使用object创建对象 var user = new Object(); //对象的属性 user.name="张三"; user.psd="12345566"; //对象的方法（函数） user.showInfo=function()&#123; document.write(this.name+"-"+this.psd) &#125; var user1=createUser("hhh","12312"); 弊端：看不出类型——解决构造函数 ​ 函数重复，浪费资源——解决：原型 构造函数 构造函数一般以大写字符开头 构造函数也是函数，只不过可以用来创建对象 与工程模式对比 没有显式创建对象 直接将属性和方法赋给了this对象 没有return 123456789101112&lt;script type="text/javascript"&gt; //使用构造函数t创建对象 function User(name,psd)&#123; //定义对象属性 this.name="沾伞"; this.psd="12312"; //定义对象方法 this.showInfo=function()&#123; document.write(this.name+"-"+this.psd) &#125; &#125;&lt;/script&gt; 原型prototype 每个函数都有一个prototype（原型）属性 是一个指针，指向一个对象 这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法 instanceof判断对象的原类型 代码实现 123456789101112131415161718//定义无参构造函数 function Flower()&#123; &#125; //原型属性和方法 Flower.prototype.name="长春花"; Flower.prototype.genera="夹竹桃科 长春花属"; Flower.prototype.showName=function()&#123; alert(this.name); &#125; //构建实例对象 var f1 = new Flower(); var f2 = new Flower(); //实例对象修改属性值 f2.name="哈哈哈"; //实例对象调用原型方法 f1.showName(); f2.showName(); 用混合方式构造对象 构造函数+prototype构造函数：属性 原型prototype：方法 12345678910//使用构造函数t创建对象 function User(name,psd)&#123; //定义对象属性 this.name="沾伞"; this.psd="12312"; &#125; //原型prototype：方法 User.prototype.showInfo=function()&#123; document.write(this.name+"-"+this.psd) &#125; 8、继承1、 原型链 一个原型对象是另一个原型对象的实例（dog.protptype=new Animal(); 相关的原型对象层层递进，就构成了实例与原型的链条，就是原型链 2、对象继承 借用构造函数 apply([thisOjb[,argArray]]) 应用某一对象的一个方法，用另一个对象替换当前对象 call([thisObj[,arg1[,arg2[, [,argN]]]]]) n调用一个对象的一个方法，以另一个对象替换当前对象 ​ Animal.call(this,cloth) 组合继承（做伪经典继承） 12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt; //构造函数Person function Person(name,chinese,math)&#123; this.name=name; this.chinese=chinese; this.math=math; &#125; //构造函数Person方法 Person.prototype.showName=function()&#123; return this.name; &#125; Person.prototype.showChinese=function()&#123; return this.chinese; &#125; Person.prototype.showMath=function()&#123; return this.math; &#125; //构造函数Student function Student(name,chinese,math,age)&#123; Person.call(this,name,chinese,math); this.age=age; &#125; //实现继承 Student.prototype=new Person(); //构造函数Student方法 Student.prototype.showAge=function()&#123; return this.age; &#125; //创建Student实例 var student=new Student("张三",90,80,16); document.write("姓名："+student.showName()+"&lt;br/&gt;") document.write("语文："+student.showChinese()+"&lt;br/&gt;") document.write("数学："+student.showMath()+"&lt;br/&gt;") document.write("年龄："+student.showAge()+"&lt;br/&gt;")&lt;/script&gt; 9、在网页中引入JavaScript的方式1、内部：用script标签，可以放在任意位置，习惯可放置在html的最后 2、行内：直接放在HTML标签中 3、外部：调用外部用script标签，属性src=“”，type=text/JavaScript 10、JS程序调试1、用浏览器F12调试，F10跳过函数,F11进去方法里，watch可以监控变量 2、alert进行标记是比较实用的调试方式，在需要标记的地方做标记，如果能执行到标记的位置，那么就会弹出窗口 11、事件onload：页面加载事件 onclick：点击事件 onkeydown：键盘按下事件 12、BOM——浏览器对象BOM是浏览器对象模型，可以移动窗口，改变状态栏中的文本，执行其他与页面内容不直接相关的操作。 BOM可实现功能： u弹出新的浏览器窗口 u移动、关闭浏览器窗口以及调整窗口的大小 u页面的前进、后退 A、Window对象 属性 history：有关客户访问过的URL的信息 location：有关当前URL的信息， 1window.location="http://www.baidu.com"; 方法 prompt() 显示可提示用户输入的对话框，可有一个参数或者两个参数，两个参数时，第二个参数代表的是默认输入信息，有返回值，点击确定返回用户输入的值，点击取消返回null alert() 为只含有一个确定按钮的警告框仅有一个参数，无返回值 confirm() 显示一段消息以及含有确定和取消按钮的对话框，返回值为布尔类型，常用于if -else语句 close() 关闭浏览器窗口 open() 在页面弹出一个新的浏览器敞口 1window.open("http://www.baidu.com","_blank","width=100px,height=100px") setTimout() 定时函数：仅会计时一次 setInterval() 定时函数：多次计时 1setInterval(“adadas()”，1000) B、History对象 方法 back()：后退 forward()：前进 go(1)：同forward，负数代表后退 C、Location对象 属性：href：设置或者返回完整的URL 方法 reload：重新加载 replace：用新的文档替换当前文档，不能振兴后退操作 align：用新的文档替换当前文档，能振兴后退操作 D、Document对象 属性 referrer：返回载入当前文档的URL（谁把我加载进来的） URL：返回当前文档的URL 方法 getElementById：通过id获取某一对象 getElementsByName：通过name获取某一对象 getElementsByTagName：通过标签名获取某一对象 write：向文档写文本 12345获得对象后需要对属性进行一系列操作，如可setAtrrbute等设置属性值，扩展：tofixed（2）代表保留两位小数，常用的对象属性有：1、value：值2、innerHTML：改变对象的所有显示属性，会解析HTML标签3、innerTEXT：改变对象的所有显示属性，不会解析HTML标签4、chected：复选框的属性值，让其为true，代表已选 13、DOM—文档对象模型 DOM分类： 1、DOM core：DOM核心，包含getElement方法等 2、HTML DOM：用来操作节点 3、CSS DOM：用来操作样式 节点信息： nodeName：节点名字 nodeValue：节点值 nodeType：节点类型 节点和节点的关系： 父节点：parentNode（parentElementNode父元素节点） 首个节点：firstChild 最后一个节点：lastChild 下一个节点：nextsibling 上一个节点：previousSibling 子节点集合childNode 操作节点： 操作节点属性：getAttribute(“属性名”) setAttribute(“属性名”,”属性值”) 创建和插入节点节点： 123createElement( tagName)A.appendChild( B)、insertBefore( A,B )cloneNode(deep) 清楚和替换节点： 1removeChild(N)、replaceChild(newN,oldN) 操作节点样式：style属性（样式少的时候用，可读写 className属性（在css样式中已经写好，通过className操作） 页面事件： 1、onload页面加载事件 2、onscroll用于博做页面垂直和水平的滚动 制作带关闭按钮的广告 1234567891011121314151617181920212223242526272829303132333435//关闭按钮关闭广告function adv_close()&#123; var closeEle=document.getElementById("close").firstElementChild; var floatEle=document.getElementById("float").firstElementChild; closeEle.style.display="none"; floatEle.style.display="none";&#125;//当滚动条向下或向右移动时，图片和关闭按钮随滚动条移动，相对于浏览器的位置固定//获取原始位置：top leftvar adver=document.getElementById("float");var initLeft=0;var initTop=0;/** * 1.获取小广告初始位置的top和left */function initLocation()&#123; if(adver.currentStyle)&#123; initLeft=parseInt(adver.style.left); initTop=parseInt(adver.style.top); &#125;else&#123; initLeft=parseInt(document.defaultView.getComputedStyle(adver,null).left); initTop=parseInt(document.defaultView.getComputedStyle(adver,null).top); &#125;&#125;function scrollCount()&#123; //2.获取鼠标滚动的距离 var leftChange= document.documentElement.scrollLeft||document.body.scrollLeft; var topChange= document.documentElement.scrollTop||document.body.scrollTop; //3.重新为属性赋值 adver.style.top=topChange+initTop+"px"; adver.style.left=leftChange+initLeft+"px"; //console.log(topChange+initTop+"px");&#125;window.onload=initLocation;//onload加载事件，调用方法window.onscroll=scrollCount;//鼠标滚动事件，调用方法 制作论坛发帖： 1234567891011121314151617181920212223242526272829303132//获得发帖的div对象var postEle=document.getElementsByClassName("post")[0];//点击发帖function pushsth()&#123; //修改CSS属性，使其显示出来 postEle.style.display="block";&#125;//发布function publish()&#123; //获取标题 var title=document.getElementsByClassName("title")[0].value; //获取板块 var section=document.getElementsByTagName("select")[0].value; //获取时间 var date = new Date(); var year=date.getFullYear(); var month=date.getMonth(); var day=date.getDate(); var dateTime=year+"年"+month+"月"+day+"日"; //将li中内容添加进入ul上 var ulEle=document.getElementsByTagName("ul")[0]; ulEle.innerHTML=" &lt;li&gt;"+ "&lt;div&gt;&lt;img src='images/tou01.jpg' /&gt;&lt;/div&gt;"+ "&lt;h1&gt;"+title+"&lt;/h1&gt;"+ " &lt;p&gt;"+ " &lt;span&gt;板块："+section+"&lt;/span&gt; &lt;span&gt;发布时间："+dateTime+"&lt;/span&gt;"+ " &lt;/p&gt;" " &lt;/li&gt;" //隐藏发帖板块 postEle.style.display="none";&#125; 注意：要在成对的双引号之间加一个参数，可以用“++“，只需要把参数放在++之间即可！ 14、内置对象String（字符串）对象 Date（日期）对象 Array（数组）对象 Boolean（逻辑）对象 Math（算数）对象 RegExp对象 三、JS的开发步骤 确定事件 通常事件都会出发一个函数 函数里面通常都会去操作页面元素,做一些交互动作 四、用js完成表单验证1、代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; /* 1. 确认事件: 表单提交事件 onsubmit事件 2. 事件所要触发的函数: checkForm 3. 函数中要干点事情 1. 校验用户名, 用户不能为空, 长度不能小于6位 1.获取到用户输入的值 */ function checkForm()&#123; //获取用户名输入项 var inputObj = document.getElementById("username"); //获取输入项的值 var uValue = inputObj.value;// alert(uValue); //用户名长度不能6位 "" if(uValue.length &lt; 6 )&#123; alert("对不起,您的长度太短!"); return false; &#125; //密码长度大于6 和确认必须一致 //获取密码框输入的值 var input_password = document.getElementById("password"); var uPass = input_password.value; if(uPass.length &lt; 6)&#123; alert("对不起,您还是太短啦!"); return false; &#125; //获取确认密码框的值 var input_repassword = document.getElementById("repassword"); var uRePass = input_repassword.value; if(uPass != uRePass)&#123; alert("对不起,两次密码不一致!"); return false; &#125; //校验手机号 var input_mobile = document.getElementById("mobile"); var uMobile = input_mobile.value; // if(!/^[1][3578][0-9]&#123;9&#125;$/.test(uMobile))&#123; alert("对不起,您的手机号无法识别!"); return false; &#125; //校验邮箱: /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(\.[a-zA-Z0-9_-])+/ var inputEmail = document.getElementById("email"); var uEmail = inputEmail.value; if(!/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(\.[a-zA-Z0-9_-])+/.test(uEmail))&#123; alert("对不起,邮箱不合法"); return false; &#125; return true; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="JS开发步骤.html" onsubmit="return checkForm()"&gt; &lt;div&gt;用户名:&lt;input id="username" type="text" /&gt;&lt;/div&gt; &lt;div&gt;密码:&lt;input id="password" type="password" /&gt;&lt;/div&gt; &lt;div&gt;确认密码:&lt;input id="repassword" type="password" /&gt;&lt;/div&gt; &lt;div&gt;手机号码:&lt;input id="mobile" type="number" /&gt;&lt;/div&gt; &lt;div&gt;邮箱:&lt;input id="email" type="text" /&gt;&lt;/div&gt; &lt;div&gt;&lt;input type="submit" value="注册" /&gt;&lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 五、JS完成自动播放轮播图1、需求有一组图片, 每隔3秒钟,就去切换一张,最终是一直在不停切换 切换图片: 每个三秒钟做一件事: setInterval : 每隔多少毫秒执行一次函数 setTimeout: 多少毫秒之后执行一次函数 clearInterval取消定时 clearTimeout取消定时 2、步骤分析: 确定事件: 文档加载完成的事件 onload 事件要触发 : init() 函数里面要做一些事情:(通常会去操作元素,提供交互) 开启定时器: 执行切换图片的函数 changeImg() changeImg() 获得要切换图片的那个元素 3、代码实现12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; var index=0 function changeImage()&#123; var img= document.getElementById("first"); var curindex=index%3+1; img.src="images/"+curindex+".jpg"; index=index+1; &#125; function init()&#123; setInterval("changeImage()",1000); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body onload="init()"&gt;&lt;img src="images/1.jpg" id="first"/&gt;&lt;/body&gt;&lt;/html&gt; 六、完成页面定时弹出广告1、需求分析一般网页，当我们刚打开的时候，它会5秒之后，显示一个广告，让我们看5秒钟，然后他的广告就自动消失了！ 2、技术分析 定时器 setInterval : 每隔多少毫秒执行一次函数 setTimeout: 多少毫秒之后执行一次函数 clearInterval clearTimeout 显示广告 img.style.display = “block” 隐藏广告 img.style.display = “none” 3、步骤分析 确定事件: 页面加载完成的事件 onload 事件要触发函数: init() init函数里面做一件事: 启动一个定时器 : setTimeout() 显示一个广告 再去开启一个定时5秒钟之后,关闭广告 4、代码实现123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; function out()&#123; var img=document.getElementById("first"); img.style.display="none"; &#125; function hide()&#123; var img=document.getElementById("first"); //弹出广告 img.style.display="block"; //显示5秒自动关闭 setTimeout("out()",5000); &#125; function init()&#123; setTimeout("hide()",2000); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body onload="init()"&gt;&lt;img src="images/1.jpg" id="first" style="display:none"/&gt;&lt;/body&gt;&lt;/html&gt; 七、完成表单的校验1、需求分析之前我们做了一个简单的表单校验，每当用户输入出错的时候，我们是弹出了一个对话框，提示用户去修改。这样的用户体验效果非常不好好。现在就是需要来对他进行一个修改，当用户输入信息有问题的时候，我们就再输入框的后面给他一个友好提示。 2、技术分析【HTML中innerHTML属性】 【JS中的常用事件】 onfocus 事件: 获得焦点事件 onblur : 失去焦点 onkeyup : 按键抬起事件 3、 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 引入外部的js文件 --&gt; &lt;script type="text/javascript" src="../js/regutils.js" &gt;&lt;/script&gt; &lt;script&gt; /* 1. 确定事件 : onfocus 2. 事件要驱动函数 3. 函数要干一些事情: 修改span的内容 */ function showTips(spanID,msg)&#123; //首先要获得要操作元素 span var span = document.getElementById(spanID); span.innerHTML = msg; &#125; /* 校验用户名: 1.事件: onblur 失去焦点 2.函数: checkUsername() 3.函数去显示校验结果 */ function checkUsername()&#123; //获取用户输入的内容 var uValue = document.getElementById("username").value; //对输入的内容进行校验 //获得要显示结果的span var span = document.getElementById("span_username"); if(uValue.length &lt; 6)&#123; //显示校验结果 span.innerHTML = "&lt;font color='red' size='2'&gt;对不起,太短&lt;/font&gt;"; return false; &#125;else&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;恭喜您,可用&lt;/font&gt;"; return true; &#125; &#125; /* 密码校验 */ function checkPassword()&#123; //获取密码输入 var uPass = document.getElementById("password").value; var span = document.getElementById("span_password"); //对密码输入进行校验 if(uPass.length &lt; 6)&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;对不起,太短&lt;/font&gt;"; return false; &#125;else&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;恭喜您,够用&lt;/font&gt;"; return true; &#125; &#125; /* 确认密码校验 * */ function checkRePassword()&#123; //获取密码输入 var uPass = document.getElementById("password").value; //获取确认密码输入 var uRePass = document.getElementById("repassword").value; var span = document.getElementById("span_repassword"); //对密码输入进行校验 if(uPass != uRePass)&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;对不起,两次密码不一致&lt;/font&gt;"; return false; &#125;else&#123; span.innerHTML = ""; return true; &#125; &#125; /* 校验邮箱 * */ function checkMail()&#123; var umail = document.getElementById("email").value; var flag = checkEmail(umail); var span = document.getElementById("span_email"); //对邮箱输入进行校验 if(flag)&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;恭喜您,可用&lt;/font&gt;"; return true; &#125;else&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;对不起,邮箱格式貌似有问题&lt;/font&gt;"; return false; &#125; &#125; function checkForm()&#123; var flag = checkUsername() &amp;&amp; checkPassword() &amp;&amp; checkRePassword() &amp;&amp; checkMail(); return flag; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="../01-自动轮播图片/图片自动轮播.html" onsubmit="return checkForm()" &gt; 用户名:&lt;input type="text" id="username" onfocus="showTips('span_username','用户名长度不能小于6')" onblur="checkUsername()" onkeyup="checkUsername()" /&gt;&lt;span id="span_username"&gt;&lt;/span&gt;&lt;br /&gt; 密码:&lt;input type="password" id="password" onfocus="showTips('span_password','密码长度不能小于6')" onblur="checkPassword()" onkeyup="checkPassword()"/&gt;&lt;span id="span_password"&gt;&lt;/span&gt;&lt;br /&gt; 确认密码:&lt;input type="password" id="repassword" onfocus="showTips('span_repassword','两次密码必须一致')" onblur="checkRePassword()" onkeyup="checkRePassword()" /&gt;&lt;span id="span_repassword"&gt;&lt;/span&gt;&lt;br /&gt; 邮箱:&lt;input type="text" id="email" onfocus="showTips('span_email','邮箱格式必须正确')" onblur="checkMail()" /&gt;&lt;span id="span_email"&gt;&lt;/span&gt;&lt;br /&gt; 手机号:&lt;input type="text" id="text" /&gt;&lt;br /&gt; &lt;input type="submit" value="提交" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 八、表格隔行换色1、需求分析我们商品分类的信息太多，如果每一行都显示同一个颜色的话会让人看的眼花，为了提高用户体验，减少用户看错的情况，需要对表格进行隔行换色 2、步骤分析确定事件: 文档加载完成 onload 事件要触发函数: init() 函数:操作页面的元素要操作表格中每一行 动态的修改行的背景颜色 3、代码实现1234567891011121314151617&lt;script &gt; function init()&#123; //得到表格 var tab = document.getElementById("tab"); //得到表格中每一行 var rows = tab.rows; //便利所有的行,然后根据奇数 偶数 for(var i=1; i &lt; rows.length; i++)&#123; var row = rows[i]; //得到其中的某一行 if(i%2==0)&#123; row.bgColor = "yellow"; &#125;else&#123; row.bgColor = "red" &#125; &#125; &#125;&lt;/script&gt; 九、复选框的全选和全不选1、需求分析商品分类界面中，当我们点击全选框的时候，我们希望选中所有的商品，当我们取消掉的时候，我们希望不选中所有的商品 2、技术分析事件 : onclick点击事件 3、 步骤分析全选和全不选步骤分析: 1.确定事件: onclick 单机事件2.事件触发函数: checkAll()3.函数要去做一些事情: 获得当前第一个checkbox的状态 获得所有分类项的checkbox 修改每一个checkbox的状态 4、代码实现123456789101112131415function checkAll()&#123;// 获得当前第一个checkbox的状态 var check1 = document.getElementById("check1"); //得到当前checked状态 var checked = check1.checked;// 获得所有分类项的checkbox// var checks = document.getElementsByTagName("input"); var checks = document.getElementsByName("checkone");// alert(checks.length); for(var i = 0; i &lt; checks.length; i++)&#123;// 修改每一个checkbox的状态 var checkone = checks[i]; checkone.checked = checked; &#125; &#125; 十、HTML中的DOM操作一些常用的 HTML DOM 方法： getElementById(id) - 获取带有指定 id 的节点（元素） appendChild(node) - 插入新的子节点（元素） removeChild(node) - 删除子节点（元素） 一些常用的 HTML DOM 属性： innerHTML - 节点（元素）的文本值 parentNode - 节点（元素）的父节点 childNodes - 节点（元素）的子节点 attributes - 节点（元素）的属性节点 查找节点：getElementById() 返回带有指定 ID 的元素。getElementsByTagName() 返回包含带有指定标签名称的所有元素的节点列表（集合/节点数组）。getElementsByClassName() 返回包含带有指定类名的所有元素的节点列表。 增加节点：createAttribute() 创建属性节点。createElement() 创建元素节点。createTextNode() 创建文本节点。insertBefore() 在指定的子节点前面插入新的子节点。appendChild() 把新的子节点添加到指定节点。 删除节点：removeChild() 删除子节点。replaceChild() 替换子节点。 修改节点：setAttribute() 修改属性setAttributeNode() 修改属性节点 十一、省市联动效果1、需求分析在网站中选择省份的时候，在右边的城市选择中会跳出对应的城市信息，达到省市联动的效果 2、技术分析利用dom操作 3、代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; /* 准备工作 : 准备数据 */ var provinces = [ ["深圳市","东莞市","惠州市","广州市"], ["长沙市","岳阳市","株洲市","湘潭市"], ["厦门市","福州市","漳州市","泉州市"] ]; /* 1. 确定事件: onchange 2. 函数: selectProvince() 3. 函数里面要搞事情了 得到当前操作元素 得到当前选中的是那一个省份 从数组中取出对应的城市信息 动态创建城市元素节点 添加到城市select中 */ function selectProvince()&#123; var province = document.getElementById("province"); //得到当前选中的是哪个省份 //alert(province.value); var value = province.value; //从数组中取出对应的城市信息 var cities = provinces[value]; var citySelect = document.getElementById("city"); //清空select中的option citySelect.options.length = 0; for (var i=0; i &lt; cities.length; i++) &#123;// alert(cities[i]); var cityText = cities[i]; //动态创建城市元素节点 &lt;option&gt;东莞市&lt;/option&gt; //创建option节点 var option1 = document.createElement("option"); // &lt;option&gt;&lt;/option&gt; //创建城市文本节点 var textNode = document.createTextNode(cityText) ;// 东莞市 //将option节点和文本内容关联起来 option1.appendChild(textNode); //&lt;option&gt;东莞市&lt;/option&gt; // 添加到城市select中 citySelect.appendChild(option1); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--选择省份--&gt; &lt;select onchange="selectProvince()" id="province"&gt; &lt;option value="-1"&gt;--请选择--&lt;/option&gt; &lt;option value="0"&gt;广东省&lt;/option&gt; &lt;option value="1"&gt;湖南省&lt;/option&gt; &lt;option value="2"&gt;福建省&lt;/option&gt; &lt;/select&gt; &lt;!--选择城市--&gt; &lt;select id="city"&gt;&lt;/select&gt; &lt;/body&gt;&lt;/html&gt; 十二、使用JS控制下拉列表左右选择1、需求分析:在我们的分类管理中,我们要能够去修改我们的分类信息,当我们一点修改的时候,跳转到一个可以编辑的页面,这里面能够修改分类的名称,分类的描述,以及分类的商品 2、 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 步骤分析 1. 确定事件: 点击事件 :onclick事件 2. 事件要触发函数 selectOne 3. selectOne要做一些操作 (将左边选中的元素移动到右边的select中) 1. 获取左边Select中被选中的元素 2. 将选中的元素添加到右边的Select中就可以 --&gt; &lt;script&gt; function selectOne()&#123;// 1. 获取左边Select中被选中的元素 var leftSelect = document.getElementById("leftSelect"); var options = leftSelect.options; //找到右侧的Select var rightSelect = document.getElementById("rightSelect"); //遍历找出被选中的option for(var i=0; i &lt; options.length; i++)&#123; var option1 = options[i]; if(option1.selected)&#123; // 2. 将选中的元素添加到右边的Select中就可以 rightSelect.appendChild(option1); &#125; &#125; &#125; //将左边所有的商品移动到右边 function selectAll()&#123;// 1. 获取左边Select中被选中的元素 var leftSelect = document.getElementById("leftSelect"); var options = leftSelect.options; //找到右侧的Select var rightSelect = document.getElementById("rightSelect"); //遍历找出被选中的option for(var i=options.length - 1; i &gt;=0; i--)&#123; var option1 = options[i]; rightSelect.appendChild(option1); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;table border="1px" width="400px"&gt; &lt;tr&gt; &lt;td&gt;分类名称&lt;/td&gt; &lt;td&gt;&lt;input type="text" value="手机数码"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;分类描述&lt;/td&gt; &lt;td&gt;&lt;input type="text" value="这里面都是手机数码"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;分类商品&lt;/td&gt; &lt;td&gt; &lt;!--左边--&gt; &lt;div style="float: left;"&gt; 已有商品&lt;br /&gt; &lt;select multiple="multiple" id="leftSelect" ondblclick="selectOne()"&gt; &lt;option&gt;华为&lt;/option&gt; &lt;option&gt;小米&lt;/option&gt; &lt;option&gt;锤子&lt;/option&gt; &lt;option&gt;oppo&lt;/option&gt; &lt;/select&gt; &lt;br /&gt; &lt;a href="#" onclick="selectOne()"&gt; &amp;gt;&amp;gt; &lt;/a&gt; &lt;br /&gt; &lt;a href="#" onclick="selectAll()"&gt; &amp;gt;&amp;gt;&amp;gt; &lt;/a&gt; &lt;/div&gt; &lt;!--右边--&gt; &lt;div style="float: right;"&gt; 未有商品&lt;br /&gt; &lt;select multiple="multiple" id="rightSelect"&gt; &lt;option&gt;苹果6&lt;/option&gt; &lt;option&gt;肾7&lt;/option&gt; &lt;option&gt;诺基亚&lt;/option&gt; &lt;option&gt;波导&lt;/option&gt; &lt;/select&gt; &lt;br /&gt; &lt;a href="#"&gt; &amp;lt;&amp;lt; &lt;/a&gt; &lt;br /&gt; &lt;a href="#"&gt; &amp;lt;&amp;lt;&amp;lt; &lt;/a&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2"&gt; &lt;input type="submit" value="提交"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 十三、使用JS实现页面上动态实时时钟代码展示：两个定时函数的调用 12345678910111213141516171819202122232425262728293031323334&lt;body onload="shoowTime()"&gt;&lt;div id="datetime" &gt;&lt;/div&gt;&lt;input type="button" id="first" value="点击" onclick="closeTime()"/&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; //全局标量，标记变量，点击停止或者开始 var flag=true; //计时函数 var time=setInterval("shoowTime()",1000); //显示时间 function shoowTime()&#123; var date=new Date(); var year=date.getFullYear(); var month=date.getMonth(); var day = date.getDate(); var hour=date.getHours(); var minute=date.getMinutes(); var second=date.getSeconds(); var ele=document.getElementById("datetime"); ele.innerHTML=year+"年"+month+"月"+day+"日"+hour+"："+minute+"："+second+"："; &#125; //点击开始或者停止计时 function closeTime()&#123; if(flag==true)&#123; clearInterval(time); flag=false; &#125;else&#123; setInterval("shoowTime()",1000); flag=true; &#125; &#125;&lt;/script&gt; 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>JavaWeb前端基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c3p0 连接池的用法]]></title>
    <url>%2F2019%2F04%2F13%2Fc3p0%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(ru)中，欢迎有兴趣的童鞋们关注。 c3p0连接池的用法1、导入c3p0jar包c3p0-0.9.1.2.jar 2、xml配置文件在src的目录下, 创建一个名称为 c3p0-config.xml的配置文件, 配置信息如下: 1）最基本配置*四个连接数据库必须的参数） 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;c3p0-config&gt; &lt;default-config&gt; &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql://106.13.43.205:3306/test&lt;/property&gt; &lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;aaaaa123&lt;/property&gt; &lt;/default-config&gt; &lt;/c3p0-config&gt; 2）复杂的配置信息 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;c3p0-config&gt;&lt;default-config&gt; &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql://localhost:3306/test&lt;/property&gt; &lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;123456&lt;/property&gt; &lt;!--当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。Default:3 --&gt; &lt;property name="acquireIncrement"&gt;5&lt;/property&gt; &lt;!--初始化的连接数，取值应在minPoolSize与maxPoolSize之间。Default: 3--&gt; &lt;property name="initialPoolSize"&gt;10&lt;/property&gt; &lt;!--连接池中保留的最小连接数--&gt; &lt;property name="minPoolSize"&gt;5&lt;/property&gt; &lt;!--连接池中保留的最大连接数。Default:15 --&gt; &lt;property name="maxPoolSize"&gt;20&lt;/property&gt; &lt;!--定义在从数据库获取新连接失败后重复尝试的次数。Default: 30 --&gt; &lt;property name="acquireRetryAttempts"&gt;30&lt;/property&gt; &lt;!--两次连接中间隔时间，单位毫秒。Default: 1000 --&gt; &lt;property name="acquireRetryDelay"&gt;1000&lt;/property&gt; &lt;!--连接关闭时默认将所有未提交的操作回滚。Default: false --&gt; &lt;property name="autoCommitOnClose"&gt;false&lt;/property&gt; &lt;/default-config&gt; &lt;/c3p0-config&gt; 3、创建数据源DataSourceUtils（工具类）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.canghe.utils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import javax.sql.DataSource;import com.mchange.v2.c3p0.ComboPooledDataSource;public class DataSourceUtils &#123; private static DataSource dataSource = new ComboPooledDataSource(); private static ThreadLocal&lt;Connection&gt; tl = new ThreadLocal&lt;Connection&gt;(); // 直接可以获取一个连接池 public static DataSource getDataSource() &#123; return dataSource; &#125; // 获取连接对象 public static Connection getConnection() throws SQLException &#123; Connection con = tl.get(); if (con == null) &#123; con = dataSource.getConnection(); tl.set(con); &#125; return con; &#125; // 开启事务 public static void startTransaction() throws SQLException &#123; Connection con = getConnection(); if (con != null) &#123; con.setAutoCommit(false); &#125; &#125; // 事务回滚 public static void rollback() throws SQLException &#123; Connection con = getConnection(); if (con != null) &#123; con.rollback(); &#125; &#125; // 提交并且 关闭资源及从ThreadLocall中释放 public static void commitAndRelease() throws SQLException &#123; Connection con = getConnection(); if (con != null) &#123; con.commit(); // 事务提交 con.close();// 关闭资源 tl.remove();// 从线程绑定中移除 &#125; &#125; // 关闭资源方法 public static void closeConnection() throws SQLException &#123; Connection con = getConnection(); if (con != null) &#123; con.close(); &#125; &#125; public static void closeStatement(Statement st) throws SQLException &#123; if (st != null) &#123; st.close(); &#125; &#125; public static void closeResultSet(ResultSet rs) throws SQLException &#123; if (rs != null) &#123; rs.close(); &#125; &#125;&#125; 4、使用DButils进行连接并对数据库进行操作12345678QueryRunner runner = new QueryRunner(DataSourceUtils.getDataSource()); String sql = "select * from product"; List&lt;Product&gt; productList = null; try &#123; productList = runner.query(sql, new BeanListHandler&lt;Product&gt;(Product.class)); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>c3p0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DBCP 连接池的用法]]></title>
    <url>%2F2019%2F04%2F13%2FDBCP%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%92%8C%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%8C%89%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(ru)中，欢迎有兴趣的童鞋们关注。 一、连接池介绍1、连接池介绍 实际上就是存放连接的池子(容器) 在开发中“获得连接”或“释放资源”是非常消耗系统资源的两个过程 为了解决此类性能问题，通常情况我们采用连接池技术，来共享连接Connection。 这样我们就不需要每次都创建连接、释放连接了，这些操作都交给了连接池 2、连接池概念规范和DataSource（数据源）接口A、连接池概念规范 不用自己来创建Connection，而是通过池来获取Connection对象 使用完Connection后，调用Connection的close()方法也不会真的关闭Connection，而是把Connection“归还”给池 连接池技术可以完成Connection对象的再次利用 B、DataSource接口 Java为数据库连接池提供了公共的接口：javax.sql.DataSource 各个厂商需要让自己的连接池实现这个接口。这样应用程序可以方便的切换不同厂商的连接池 常见的连接池：DBCP、C3P003DBCP连接池介绍 3、DBCP连接池介绍 DBCP也是一个开源的连接池，是Apache Common成员之一，在企业开发中也比较常见，tomcat内置的连接池 tomcat是javaweb服务器，把我们写好的class文件放在Tomcat软件中，软件开启的时候会开启端口，根据不同功能返回不同结果 二、连接池如何使用1、导入jar包 jar包介绍 mysql-connector-java-5.1.37-bin.jar：数据库驱动 commons-dbutils-1.6.jar：提供QueryRunner类方便进行增删改查操作 commons-dbcp-1.4.jar： commons-pool-1.5.6.jar：提供高效的数据库连接池技术 b: 导入jar包 在项目根路径下建立文件夹lib 拷贝以上jar包，选定拷贝的jar包/右键/Build Path/Add to Build Path 三、BasicDataSource类的使用连接池jar包中,定义好一个类 BasicDataSource，实现类数据源的规范接口 javax.sql.DataSource 1、BasicDataSource类的常见配置分类 属性 描述必须项​ driverClassName 数据库驱动名称​ url 数据库的地址​ username 用户名​ password 密码基本项（扩展）​ maxActive 最大连接数量​ minIdle 最小空闲连接​ maxIdle 最大空闲连接（空闲连接即没有使用到的连接）​ initialSize 初始化连接 2、使用DBCP实现数据库连接池工具类示例代码123456789101112131415161718192021222324252627282930package Util;import javax.sql.DataSource;import org.apache.commons.dbcp.BasicDataSource;public class JDBCUtils &#123; //创建出BasicDataSource类对象 private static BasicDataSource datasource= new BasicDataSource(); //静态代码块,对象BasicDataSource对象中的配置,自定义 static &#123; //数据库连接信息,必须的 datasource.setDriverClassName("com.mysql.jdbc.Driver"); datasource.setUrl("jdbc:mysql://localhost:3306/day33_user"); datasource.setUsername("root"); datasource.setPassword("aaaaa123"); //对象连接池中的连接数量配置,可选的 datasource.setInitialSize(10);//初始化的连接数 datasource.setMaxActive(8);//最大连接数量 datasource.setMaxIdle(5);//最大空闲数 datasource.setMinIdle(1);//最小空闲 &#125; //定义静态方法,返回BasicDataSource类的对象 public static DataSource getDataSource() &#123; return datasource; &#125;&#125; 3、测试写好的工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package ui;import java.sql.SQLException;import java.util.List;import javax.management.RuntimeErrorException;import javax.naming.spi.Resolver;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.ArrayListHandler;import Util.JDBCUtils;public class QueryRunnerDemo &#123; public static void main(String[] args) &#123;// select(); insert(); &#125; //QueryRunner类对象,写在类成员位置 private static QueryRunner qr= new QueryRunner(JDBCUtils.getDataSource()); //定义2个方法,实现数据表的添加,数据表查询 //数据表查询 public static void select() &#123; try &#123; String sql = "SELECT * FROM users"; List&lt;Object[]&gt; list =qr.query(sql, new ArrayListHandler()); //遍历对象数组集合 for(Object[] objs:list) &#123; for(Object obj:objs) &#123; System.out.print(obj); &#125; System.out.println(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); throw new RuntimeException("数据查询失败"); &#125; &#125; //数据表添加数据 public static void insert() &#123; try &#123; String sql="INSERT INTO users (username,PASSWORD) VALUES (?,?)"; Object[] params = &#123;"c","3"&#125;; int result=qr.update(sql, params); System.out.println(result); &#125; catch (SQLException e) &#123; e.printStackTrace(); throw new RuntimeException("插入数据失败"); &#125; &#125; &#125; 四、登录注册案例分析1、分析 a: 登录 调用另一个类的方法,传递用户名和密码 导数据表中查询是否有用户 如果有，告诉用户登录成功 b: 注册 接收键盘输入的用户名和密码 调用另一个类的方法,传递用户名和密码 查询用户名是否存在，存在就告诉用户注册失败，不存在执行数据库的insert操作 2、实现步骤 创建数据库和数据表 分别建立dao、entity、mgr、service、ui、util包，各自作用如下： | dao | entity | mgr | service | ui | util || :—————————————————————————————: | :———————————————————————: | :———————————————————————————-: | :—————————————————————————————: | :———————————————————: | :—————————————————————————————: || 对应数据库层，和数据库打交道 | 实体包 | 管理包 | 逻辑层包 | 用户界面包 | 工具类 || 包括实现类和接口，其中实现类在dao下面新建一个impl包存放（UserDao、UserDaoImpl） | 和数据表对应，有构造方法以及set、get方法（User） | 定义用户管理操作，一系列的输入输出都在这里完成（Usermgr） | 包含逻辑层接口和接口的实现类，是直接面向用户的（UserService、UserServiceImpl） | 实际中是图形化界面HTML等，这里用test代替 | 一系列的工具，这里有JDBCUtils，通过连接池来进行数据库连接操作 | 在项目下面建立lib文件夹，导入四个jar包，并build path 按照架构进行编程 3、各个包中具体类源码 dao 123456789101112package dao;/** * 对用户操作的接口 * @author Administrator * */public interface UsersDao &#123; //登录 public Object[] login(String username,String password); //注册 public boolean registr(String username,String password);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package dao.impl;import java.sql.SQLException;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.ArrayHandler;import org.apache.commons.dbutils.handlers.ScalarHandler;import dao.UsersDao;import util.JDBCUtils;/** * 对用户操作的实体类 * @author Administrator * */public class UsersDaoImpl implements UsersDao&#123; //创建QueryRunner类的对象,构造方法中,传递工具类中获取的数据源 private QueryRunner queryRunner = new QueryRunner(JDBCUtils.getDataSource()); /** * 创建登录功能 * 用户名和密码,作为数据表users的查询条件,查询表结果集 */ @Override public Object[] login(String username, String password) &#123; try &#123; String sql="SELECT * FROM users WHERE username=? AND PASSWORD=?"; Object[] params = &#123;username,password&#125;; Object[] result = queryRunner.query(sql, new ArrayHandler(), params); return result; &#125; catch (SQLException e) &#123; e.printStackTrace(); throw new RuntimeException("登录查询失败"); &#125; &#125; /** * 创建注册功能 * 接收用户的输入用户名和密码 * 检查用户名是否被占 * 将用户输入的用户名,作为users表查询条件 * 如果有结果集,说明用户名已经有了 * 如果没有结果集,用户名可以使用, 用户名和密码insert 写入到数据表 */ @Override public boolean registr(String username, String password) &#123; try &#123; String sql = "SELECT username FROM users WHERE username=?"; //调用qr对象方法query查询结果集,ScalarHandler 一个结果集 String user=queryRunner.query(sql, new ScalarHandler&lt;String&gt;(), username); if(user !=null) return false; //用户名可以使用 //把用户名和密码放入数据库 sql="INSERT INTO users (username,PASSWORD) VALUES (?,?)"; Object[] params = &#123;username,password&#125;; queryRunner.update(sql, params); return true; &#125; catch (SQLException e) &#123; e.printStackTrace(); throw new RuntimeException("注册失败"); &#125; &#125; &#125; entity 1234567891011121314151617181920212223242526package entity;public class User &#123; private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public User(String username, String password) &#123; super(); this.username = username; this.password = password; &#125; public User() &#123; super(); &#125;&#125; mgr 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package mgr;import java.util.Scanner;import service.UsersService;import service.impl.UsersServiceImpl;//用户管理类public class UsersMgr &#123; Scanner input = new Scanner(System.in); UsersService usersService = new UsersServiceImpl(); private String username; private String password; /** * 主菜单 */ public void menu() &#123; boolean flag = true; do &#123; System.out.println("*****欢迎进入苍何的登录系统*****"); System.out.println("1、登录"); System.out.println("2、注册"); System.out.println("3、退出"); System.out.print("请选择："); int option = input.nextInt(); switch (option) &#123; case 1: login(); break; case 2: register(); break; case 3: System.exit(0); default: flag = false; break; &#125; &#125; while (flag); &#125; public void login() &#123; System.out.print("请输入您的用户名："); username = input.next(); System.out.print("请输入您的密码："); password = input.next(); boolean success = usersService.login(username, password); if (success) &#123; System.out.println("登录成功，欢迎进入"); &#125; else &#123; System.out.println("用户名或密码错误"); &#125; &#125; public void register() &#123; System.out.print("请输入您的用户名："); username = input.next(); System.out.print("请输入您的密码："); password = input.next(); boolean success = usersService.register(username, password); if(success) &#123; System.out.println("注册成功"); &#125;else &#123; System.out.println("用户名已存在，请重新注册"); &#125; &#125;&#125; service 123456package service;//逻辑层接口public interface UsersService &#123; public boolean login(String username,String password); public boolean register(String username,String password);&#125; 12345678910111213141516171819202122package service.impl;import dao.UsersDao;import dao.impl.UsersDaoImpl;import service.UsersService;public class UsersServiceImpl implements UsersService&#123; UsersDao usersDao = new UsersDaoImpl(); @Override public boolean login(String username, String password) &#123; Object[] result =usersDao.login(username, password); if(result.length ==0) return false; return true; &#125; @Override public boolean register(String username, String password) &#123; return usersDao.registr(username, password); &#125;&#125; ui 1234567891011package ui;import mgr.UsersMgr;public class UserOperator &#123; public static void main(String[] args) &#123; UsersMgr usersMgr = new UsersMgr(); usersMgr.menu(); &#125; &#125; util 123456789101112131415161718192021222324252627282930package util;import javax.sql.DataSource;import org.apache.commons.dbcp.BasicDataSource;public class JDBCUtils &#123; //创建出BasicDataSource类对象 private static BasicDataSource datasource= new BasicDataSource(); //静态代码块,对象BasicDataSource对象中的配置,自定义 static &#123; //数据库连接信息,必须的 datasource.setDriverClassName("com.mysql.jdbc.Driver"); datasource.setUrl("jdbc:mysql://localhost:3306/day33_user"); datasource.setUsername("root"); datasource.setPassword("aaaaa123"); //对象连接池中的连接数量配置,可选的 datasource.setInitialSize(10);//初始化的连接数 datasource.setMaxActive(8);//最大连接数量 datasource.setMaxIdle(5);//最大空闲数 datasource.setMinIdle(1);//最小空闲 &#125; //定义静态方法,返回BasicDataSource类的对象 public static DataSource getDataSource() &#123; return datasource; &#125;&#125; 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DBUtils 工具类操作数据库]]></title>
    <url>%2F2019%2F04%2F13%2FDBUtils%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(ru)中，欢迎有兴趣的童鞋们关注。 一、DButils工具类介绍和三个核心类1、DButils工具类介绍 DBUtils是java编程中的数据库操作实用工具，小巧简单实用。 DBUtils封装了对JDBC的操作，简化了JDBC操作，可以少写代码。 DBUtils就是JDBC的简化开发工具包。需要项目导入commons-dbutils-1.6.jar才能够正常使用DBUtils工具。 DButils相当于之前写的BaseDao，而且比其更实用，提供了一系列方法对数据库进行更加复杂的操作 2、Dbutils三个核心功能（核心类）介绍 QueryRunner中提供对sql语句操作的API. update(Connection conn, String sql, Object… params) ，用来完成表数据的增加、删除、更新操作 query(Connection conn, String sql, ResultSetHandler rsh, Object… params) ，用来完成表数据的查询操作 ResultSetHandler接口，用于定义select操作后，怎样封装结果集. DbUtils类，它就是一个工具类,定义了关闭资源与事务处理的方法 二、QueryRunner类的update方法介绍 update(Connection conn, String sql, Object… params) ，用来完成表数据的增加、删除、更新操作 使用QueryRunner类,实现对数据表的insert delete update 调用QueryRunner类的方法 update (Connection con,String sql,Object…param) Object…param 可变参数,Object类型,SQL语句会出现?占位符 数据库连接对象,自定义的工具类传递 1、QueryRunner类实现insert添加数据案例代码 1234567891011121314/* * 定义方法,使用QueryRunner类的方法update向数据表中,添加数据 */ public static void insert()throws SQLException&#123; //创建QueryRunner类对象 QueryRunner qr = new QueryRunner(); String sql = "INSERT INTO sort (sname,sprice,sdesc)VALUES(?,?,?)"; //将三个?占位符的实际参数,写在数组中 Object[] params = &#123;"体育用品",289.32,"购买体育用品"&#125;; //调用QueryRunner类的方法update执行SQL语句 int row = qr.update(con, sql, params); System.out.println(row); DbUtils.closeQuietly(con); &#125; 2、QueryRunner类实现update修改数据案例代码 123456789101112131415/* * 定义方法,使用QueryRunner类的方法update将数据表的数据修改 */ public static void update()throws SQLException&#123; //创建QueryRunner类对象 QueryRunner qr = new QueryRunner(); //写修改数据的SQL语句 String sql = "UPDATE sort SET sname=?,sprice=?,sdesc=? WHERE sid=?"; //定义Object数组,存储?中的参数 Object[] params = &#123;"花卉",100.88,"情人节玫瑰花",4&#125;; //调用QueryRunner方法update int row = qr.update(con, sql, params); System.out.println(row); DbUtils.closeQuietly(con); &#125; 3、QueryRunner类实现delete删除数据案例代码 123456789101112131415161718/* * 定义方法,使用QueryRunner类的方法delete将数据表的数据删除 */public static void delete()throws SQLException&#123; //创建QueryRunner类对象 QueryRunner qr = new QueryRunner(); //写删除的SQL语句 String sql = "DELETE FROM sort WHERE sid=?"; //调用QueryRunner方法update int row = qr.update(con, sql, 8); System.out.println(row); /* * 判断insert,update,delete执行是否成功 * 对返回值row判断 * if(row&gt;0) 执行成功 */ DbUtils.closeQuietly(con);&#125; 三、JavaBean类JavaBean就是一个类，在开发中常用封装数据。具有如下特性 需要实现接口：java.io.Serializable ，通常实现接口这步骤省略了，不会影响程序。 提供私有字段：private 类型 字段名; 提供getter/setter方法： 提供无参构造 四、DBUtils工具类结果集处理的方式QueryRunner实现查询操作：query(Connection conn, String sql, ResultSetHandler rsh, Object… params) ，用来完成表数据的查询操作 ArrayHandler ArrayListHandler BeanHandler BeanListHandler ColumnListHandler ScalarHandler MapHandler MapListHandler 将结果集中的第一条记录封装到一个Object[]数组中，数组中的每一个元素就是这条记录中的每一个字段的值 将结果集中的每一条记录都封装到一个Object[]数组中，将这些数组在封装到List集合中。 将结果集中第一条记录封装到一个指定的javaBean中。 将结果集中每一条记录封装到指定的javaBean中，将这些javaBean在封装到List集合中 将结果集中指定的列的字段值，封装到一个List集合中 它是用于单数据。例如select count(*) from 表操作。 将结果集第一行封装到Map集合中,Key 列名, Value 该列数据 将结果集第一行封装到Map集合中,Key 列名, Value 该列数据,Map集合存储到List集合 五、QueryRunner的方法query实现查询操作 调用QueryRunner类方法query(Connection con,String sql,ResultSetHandler r, Object..params) ResultSetHandler r 结果集的处理方式,传递ResultSetHandler接口实现类 Object..params SQL语句中的?占位符 注意: query方法返回值,返回的是T 泛型, 具体返回值类型,跟随结果集处理方式变化 1、结果集第一种处理方法, ArrayHandler将结果集的第一行存储到对象数组中 Object[]，,只返回结果集的第一行 1234567891011public static void arrayHandler() throws SQLException &#123; QueryRunner qr = new QueryRunner(); String sql = "SELECT * FROM master"; // 调用方法query执行查询,传递连接对象,SQL语句,结果集处理方式的实现类 // 返回对象数组 Object[] result = qr.query(conn, sql, new ArrayHandler()); // 遍历数组 for (Object obj : result) &#123; System.out.print(obj); &#125; &#125; 2、结果集第二种处理方法,ArrayListHandler将结果集的每一行,封装到对象数组中, 出现很多对象数组,对象数组存储到List集合 123456789101112131415public static void arrayListHandler() throws SQLException &#123; QueryRunner qr = new QueryRunner(); String sql = "SELECT * FROM master"; // 调用query方法,结果集处理的参数上,传递实现类ArrayListHandler // 方法返回值 每行是一个对象数组,存储到List List&lt;Object[]&gt; result = qr.query(conn, sql, new ArrayListHandler()); // 遍历集合 for (Object[] objs : result) &#123; // 遍历对象数组 for (Object obj : objs) &#123; System.out.print(obj + " "); &#125; System.out.println(); &#125; &#125; 3、结果集第三种处理方法,BeanHandler将结果集的第一行数据,封装成JavaBean对象 注意: 被封装成数据到JavaBean对象,，Master类必须有空参数构造 12345678public static void beanHandler() throws SQLException &#123; QueryRunner qr = new QueryRunner(); String sql = "SELECT * FROM master"; // 调用方法,传递结果集实现类BeanHandler // BeanHandler(Class&lt;T&gt; type) Master master = qr.query(conn, sql, new BeanHandler&lt;Master&gt;(Master.class)); System.out.println(master); &#125; 4、结果集第四种处理方法, BeanListHandler结果集每一行数据,封装JavaBean对象 多个JavaBean对象,存储到List集合 123456789public static void beanListHander() throws SQLException &#123; QueryRunner qr = new QueryRunner(); String sql = "SELECT * FROM master"; // 调用方法query,传递结果集处理实现类BeanListHandler List&lt;Master&gt; list = qr.query(conn, sql, new BeanListHandler&lt;Master&gt;(Master.class)); for (Master m : list) &#123; System.out.println(m); &#125; &#125; 5、结果集第五种处理方法,ColumnListHandler 结果集,指定列的数据,存储到List集合,指定咧的所有数据如name列就会返回所有的名字，List 每个列数据类型不同 12345678910public static void columnListHandler()throws SQLException&#123; QueryRunner qr = new QueryRunner(); String sql = "SELECT * FROM master "; //调用方法 query,传递结果集实现类ColumnListHandler //实现类构造方法中,使用字符串的列名 List&lt;Object&gt; list =qr.query(conn, sql, new ColumnListHandler&lt;Object&gt;("name")); for(Object o:list) &#123; System.out.println(o); &#125; &#125; 6、结果集第六种处理方法,ScalarHandler对于查询后,只有1个结果,返回一个结果 1234567public static void scalarHandler()throws SQLException&#123; QueryRunner qr = new QueryRunner(); String sql = "SELECT COUNT(*) FROM Master"; //调用方法query,传递结果集处理实现类ScalarHandler long count = qr.query(conn, sql, new ScalarHandler&lt;Long&gt;()); System.out.println(count); &#125; 7、结果集第七种处理方法,MapHandler将结果集第一行数据,封装到Map集合中,只有第一行，Map&lt;键,值&gt; 键:列名 值:这列的数据 1234567891011public static void mapHandler()throws SQLException&#123; QueryRunner qr = new QueryRunner(); String sql = "SELECT * FROM master"; //调用方法query,传递结果集实现类MapHandler //返回值: Map集合,Map接口实现类, 泛型 Map&lt;String,Object&gt; map = qr.query(conn, sql, new MapHandler()); //遍历Map集合 for(String key:map.keySet()) &#123; System.out.println(key+"\t"+map.get(key)); &#125; &#125; 8、结果集第八种处理方法,MapListHandler将结果集每一行存储到Map集合,键:列名,值:数据，Map集合过多,存储到List集合，集合里面嵌套集合， map集合有一个有序的map集合，在hashmap子类linkedHashmap，打印map.getClass即可找到是因为内部类继承了linkedHashmap，是有顺序的 12345678910111213public static void mapListHandler()throws SQLException&#123; QueryRunner qr = new QueryRunner(); String sql = "SELECT * FROM master"; //调用方法query,传递结果集实现类MapListHandler //返回值List集合, 存储的是Map集合 List&lt;Map&lt;String,Object&gt;&gt; list =qr.query(conn, sql, new MapListHandler()); for(Map&lt;String,Object&gt;map:list) &#123; for(String key:map.keySet()) &#123; System.out.print(key+map.get(key)); &#125; System.out.println(); &#125; &#125; 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>DBUtils</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate 之进阶1——主键生成策略和事务管理]]></title>
    <url>%2F2019%2F04%2F13%2FHibernate%E4%B9%8B%E8%BF%9B%E9%98%B61%E2%80%94%E2%80%94%E4%B8%BB%E9%94%AE%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5%E5%92%8C%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(jing)续(chang)更(duan)新(geng)中，欢迎有兴趣的童鞋们关注。 一、持久化类的编写规则1、什么是持久化？将内存中的数据永久保存到关系型数据库中 2、什么是持久化类？java中的类和数据库表建立了映射关系 3、持久化类的编写规则 无参构造方法 属性需要私有，对私有属性提供公共的set和get方法 属性精良使用包装类型（防止基本数据类型默认值为0造成的问题 要有一个唯一标识OID与表的主键对应 不能使用ffinal修饰（延迟加载代理对象继承了持久化类） 二、Hibernate主键生成策略1、主键的类型1）自然主键 ​ 实体中具体属性（如省份证id） 2）代理主键（开发常用） ​ 主键本身不是持久化类中的具体属性 2、主键生成策略 increment long\short\int类型，hibernate中的自增长，只允许在单线程中使用 identity long\short\int类型，利用的是数据库的自增长，如mysql sequence long\short\int类型，序列，如oracle native 本地策略，在identity和sequence中进行自动切换 uuid 适合字符串，会产生随机的字符串 assigned hibernate放弃主键管理，需哟啊月用户手动设置 foreign 一对一主键对应 三、Hibernate持久化类的三中状态1、瞬时态无唯一标识UID 不被session管理 数据库重女无记录 new对象的时候产生 2、持久态有UUID 被session管理 持久化对象可自动更新数据库 1234567891011121314@Test /** * hibernate主键生成策略，以及持久态会自动更新数据表 */ public void demo2() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction();// Customer customer = new Customer();// customer.setCust_name("脏三"); Customer customer = session.get(Customer.class, 1l); customer.setCust_source("小广告");// session.save(customer); transaction.commit(); &#125; 3、托管态有OID 未被session管理 四、Hibernate的一级缓存1、什么是缓存缓存是计算机领域非常通用的概念，介于应用程序和永久性数据存储器（如硬盘上文件或数据库）之间，缓存是将数据放在内存中，降低应用程序直接读写数据库的频率，从而提高应用的运行性能。 2、Hibernate中的缓存1）以及缓存 session级别的缓存，hibernate自带缓存，且不可取消 2）二级缓存 sessionFactory级别缓存，需要手动配置才可生效 3、Hibernate一级缓存1）一级缓存的内部结构 在Session接口的实现中包含一系列java集合，构成了缓存 快照区：当事务提交时，比较缓存和快照区中数据，当一致的时候不会发送update方法，不一致才会发送update语句，这也解释了为什么hibernate中的持久化类的持久态为什么可以自动更新数据库 4、缓存的清空session.close() session.clar()：清除所有缓存 session.evict：清除指定缓存 五、Hibernate的事务管理1、什么是事务逻辑上的一组操作，组成这组操作的各个单元，要么一起成功，要么一起失败 2、事务的四个特性ACID 1）原子性（A）： 不可分割的单元 2）一致性（C） 保证数据整体保持一致状态 3）隔离性（I） 一个事务的执行不受其他事务的影响 4）持久性（D） 执行完毕后，数据存到数据库 3、事务的并发问题1）脏读 ​ 一个事务读取到另一个事务未提交的数据 2）不可重复读 一个事务读到了另一个事务已经提交的update的数据，导致在同一个事务中的多次查询结果不一致 3）虚读 一个事务读到了另一个事务已经提交的insert的数据，导致在同一个事务中的多次查询结果不一致 4、事务的蛤蜊级别为了解决事务并发的问题 1）读未提交（Read Uncommited） 不能解决以上读问题 2）已读提交（Read Commitied） 解决脏读，oracle默认 3）可重复读（Rwpeatable Read） 解决脏读和不可重复读，mysql默认 4）序列化（Serializable） 能解决所有事务并发的问题，但是效率较低 5、Hibernate事务管理考虑到事务是事务应该在sercice层实现，保证调用不同的dao但是是同一个session，可以在工具类中通过sessionFactory对象的getCurrentSession() 方法获得与线程绑定的session，且该session不需要关闭 1）先在核心配置文件中配置 1234&lt;!--指定session管理方式 --&gt; &lt;property name=&quot;hibernate.current_session_context_class&quot;&gt; thread &lt;/property&gt; 2）在工具类中修改 123public static Session getCurrentSession() &#123; return sessionFactory.getCurrentSession(); &#125; 六、Hibernate的其他API1、Query通过.createQuery（HQL）产生Query,调用query的list（）方法执行查询 1）基本查询 1234567891011121314@Test/** * 利用query查询所有数据 */public void demo3() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); Query query = session.createQuery("from Customer"); List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer.getCust_name()); &#125; transaction.commit();&#125; 2）条件查询 12345678910111213141516@Test/** * 利用query条件查询 */public void demo4() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); Query query = session.createQuery("from Customer where cust_name=? and cust_source=?"); query.setString(0, "张三"); query.setString(1, "小广告"); List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; transaction.commit();&#125; 3）分页查询 12345678910111213141516@Test/** * 分页查询 */public void demo5() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); Query query = session.createQuery("from Customer"); query.setFirstResult(2); query.setMaxResults(2); List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; transaction.commit();&#125; 2、 Criteria是一个完全面型对象，可扩展的条件查询API，QBC查询 1）查询所有记录 1234567891011121314@Test /** * Criteria查询所有记录 */ public void demo6() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); Criteria criteria = session.createCriteria(Customer.class); List&lt;Customer&gt; list = criteria.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; transaction.commit(); &#125; 2）条件查询 12345678910111213141516@Test/** * Criteria条件查询 */public void demo7() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); Criteria criteria = session.createCriteria(Customer.class); criteria.add(Restrictions.eq("cust_name", "张三")); criteria.add(Restrictions.eq("cust_source", "小广告")); List&lt;Customer&gt; list = criteria.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; transaction.commit();&#125; 3）分页查询 12345678910111213141516@Test/** * Criteria条件查询 */public void demo8() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); Criteria criteria = session.createCriteria(Customer.class); criteria.setFirstResult(2); criteria.setMaxResults(2); List&lt;Customer&gt; list = criteria.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; transaction.commit();&#125; 3、SQLQuery用于接收sql语句进行查询 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>JavaEE框架</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate 之进阶3——查询方式]]></title>
    <url>%2F2019%2F04%2F13%2FHibernate%E4%B9%8B%E8%BF%9B%E9%98%B63%E2%80%94%E2%80%94%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(jing)续(chang)更(duan)新(geng)中，欢迎有兴趣的童鞋们关注。 一、OID查询根据对象的OID，即数据表中的主键进行查询某一个特定的对象，比如get和load方法 1、get方式1Customer customer = session.get(Customer.class,1l); 2、load方式1Customer customer = session.load(Customer.class,1l); 3、get和load的区别 load采用的是延迟加载 load返回的是一个代理对象（通过集成持久化类），而get返回的是一个真实对象 当查不到结果时，get返回的是null，而load会报异常 二、对象导航检索对象导航检索：Hibernate根据一个已经查询到的对象，获得其关联的对象的一种查询方式。 12345LinkMan linkMan = session.get(LinkMan.class,1l);Customer customer = linkMan.getCustomer();Customer customer = session.get(Customer.class,2l);Set&lt;LinkMan&gt; linkMans = customer.getLinkMans(); 三、HQL检索HQL查询：Hibernate QueryLanguage，Hibernate的查询语言，是一种面向对象的方式的查询语言，语法类似SQL。通过session.createQuery()，用于接收一个HQL进行查询方式 1、 HQL的简单查询123456789101112131415@Test /** * HQL的简单查询——查询所有客户 * Hibernate中不支持*的写法 */ public void demo2() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); Query query = session.createQuery("from Customer"); List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; transaction.commit(); &#125; 2、HQL别名查询123456789101112131415@Test /** * HQL别名查询 * Hibernate中不支持*的写法 */ public void demo3() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); Query query = session.createQuery("select C from Customer C"); List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; transaction.commit(); &#125; 3、HQL排序查询12345678910111213@Test /** * HQL排序查询（默认升序asc，降序用desc */ public void demo4() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); List&lt;Customer&gt; list = session.createQuery("from Customer order by cust_id desc").list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; transaction.commit(); &#125; 4、HQL条件查询12345678910111213141516@Test/** * HQL条件查询——按位置绑定，类似于sql */public void demo6() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); Query query = session.createQuery("from Customer where cust_name=? and cust_source=?"); query.setParameter(0, "客户1"); query.setParameter(1, "小广告"); List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; transaction.commit();&#125; 1234567891011121314151617@Test /** * HQL条件查询——按名称查询 */ public void demo7() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); Query query = session.createQuery("from Customer where cust_name= :aaa and cust_source= :bbb"); //为参数赋值 query.setParameter("aaa", "客户1"); query.setParameter("bbb", "小广告"); List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; transaction.commit(); &#125; 5、HQL投影查询1234567891011121314151617181920212223242526272829303132@Test /** * HQL投影查询——查询对象的某个或者某些属性 * 需要为类起一个别名 */ public void demo8() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); Query query = session.createQuery("select C.cust_name,C.cust_source from Customer C"); List&lt;Object[]&gt; list = query.list(); for (Object[] objects : list) &#123; System.out.println(Arrays.toString(objects)); &#125; transaction.commit(); &#125; @Test /** * HQL投影查询——查询对象的某个或者某些属性并将这些属性放入对象中封装 * 利用持久化类提供特定的构造方法 */ public void demo9() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); Query query = session.createQuery("select new Customer(cust_name,cust_source) from Customer"); List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; transaction.commit(); &#125; 6、HQL分页查询1234567891011121314151617@Test /** * HQL分页查询 * */ public void demo10() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); Query query = session.createQuery("from LinkMan"); query.setFirstResult(10); query.setMaxResults(10); List&lt;LinkMan&gt; list = query.list(); for (LinkMan linkMan : list) &#123; System.out.println(linkMan); &#125; transaction.commit(); &#125; 7、HQL统计查询12345678910111213@Test /** * HQL统计查询 * 聚合函数 * */ public void demo11() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); Object object = session.createQuery("select count(*) from Customer").uniqueResult(); System.out.println(object); transaction.commit(); &#125; 8、HQL分组统计查询12345678910111213141516@Test /** * HQL分组统计查询 * group by * */ public void demo12() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); List&lt;Object[]&gt; list = session.createQuery("select cust_source,count(*) from Customer group by cust_source" + " having count(*)&gt;=2").list(); for (Object[] objects : list) &#123; System.out.println(Arrays.toString(objects)); &#125; transaction.commit(); &#125; 9、HQL多表查询 1234567891011121314151617181920212223242526272829@Test /** * HQL多表查询——普通内连接 */ public void demo13() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); List&lt;Object[]&gt; list = session.createQuery("from Customer c inner join c.linkMan").list(); for (Object[] objects : list) &#123; System.out.println(Arrays.toString(objects)); &#125; transaction.commit(); &#125; @Test /** * HQL多表查询——迫切内连接a * 在inner join后面加fetch，通知Hibernate，可以将另一个对象的数据封装到该对象中 * 在from之前加上distinct */ public void demo14() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); List&lt;Customer&gt; list = session.createQuery("select distinct c from Customer c inner join fetch c.linkMan").list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; transaction.commit(); &#125; 四、QBC检索 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>JavaEE框架</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate 之进阶2——表操作和多对多配置]]></title>
    <url>%2F2019%2F04%2F13%2FHibernate%E4%B9%8B%E8%BF%9B%E9%98%B62%E2%80%94%E2%80%94%E8%A1%A8%E6%93%8D%E4%BD%9C%E5%92%8C%E5%A4%9A%E5%AF%B9%E5%A4%9A%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(jing)续(chang)更(duan)新(geng)中，欢迎有兴趣的童鞋们关注。 一、数据库表与表之间的关系1、一对多关系1）一个部门对应多个员工、客户和联系人、商品和分类 2）建表原则 在多的一方创建外键，指向一的一方的主键 2、多对多关系1）学生和课程、用户和角色 2）建表原则 创建一个中间表，中间表至少有两个字段分别作为指向多对多双方的主键 3、一对一关系1）公司和注册地址 2）建表原则 唯一外键对应：模拟一对多关系，在多的一方创建外键约束，并加唯一约束； 主键对应：两个主键关联 二、Hibernate一对多关系配置1、建表根据一对多建表原则建表 2、实体类1）在一的一方需要添加多的对象的集合 1private Set&lt;LinkMan&gt; linkMan = new HashSet&lt;LinkMan&gt;(); 2）在多的一方设置一的一方的对象属性 1private Customer customer; 3、持久化类的映射配置1）在一的一方配置 12345678910111213141516171819&lt;!-- 配置一对多的映射：放置的多的一方的集合 --&gt; &lt;!-- set标签 ： * name ：多的一方的对象集合的属性名称。 * cascade：级联 * inverse：放弃外键维护权。 --&gt; &lt;set name="linkMans" cascade="save-update" inverse="true"&gt; &lt;!-- key标签 * column：多的一方的外键的名称。 --&gt; &lt;key column="lkm_cust_id"/&gt; &lt;!-- one-to-many标签 * class :多的一方的类的全路径 --&gt; &lt;one-to-many class="com.itheima.hibernate.domain.LinkMan"/&gt; &lt;/set&gt; 2）多的一方配置 12345678&lt;!-- 配置多对一的关系：放置的是一的一方的对象 --&gt; &lt;!-- many-to-one标签 * name :一的一方的对象的属性名称。 * class :一的一方的类的全路径。 * column :在多的一方的表的外键的名称。 --&gt; &lt;many-to-one name="customer" class="com.itheima.hibernate.domain.Customer" column="lkm_cust_id"/&gt; 4、核心配置文件的配置需要将映射文件都放入核心配置中来 5、一对多的级联操作正常未作其他配置的前提下，必须保存两个才可以进行执行，否则就会报瞬时对象异常 1）级联保存或更新 保存客户级联联系人： 在客户的映射中的set标签中加cascade属性，值为save-update，为了避免产生多余的sql语句，通常在一的一方的set中添加属性inverse=”true”，放弃外键维护 12 保存联系人级联客户@Test​ /*​ 级联保存——保存一的一方（保存客户，级联联系人）​ */​ public void demo2() {​ ​ Session session = HibernateUtils.getCurrentSession();​ ​ Transaction transaction = session.beginTransaction();​ ​ 12345678910111213 Customer customer = new Customer(); customer.setCust_name("客户1"); LinkMan linkMan = new LinkMan(); linkMan.setLkm_name("联系人1"); customer.getLinkMan().add(linkMan); linkMan.setCustomer(customer); session.save(customer); transaction.commit();&#125; 在联系人的配置文件中cascade *通过级联操作可以测试对象的导航，判断发送几条sql语句 6、级联删除在JDBC或者数据库中，有主外键关系的数据表，要先删除从表，再删除主表，在hibernate中科技设置级联删除，删除某一方就可以将级联的也删除掉 1）删除客户级联删除联系人 在客户的配置文件的set中的cascade中新加值delete 7、cascade和inverse区别cascade是级联操作设置 inverse是维护外键的设置 8、测试对象的导航123456789101112131415161718192021222324252627282930@Test /** * 测试对象的导航 * 前提：在两边均设置了：cascade="save-update" */ public void demo4() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); Customer customer = new Customer(); customer.setCust_name("客户1"); LinkMan linkMan1 = new LinkMan(); linkMan1.setLkm_name("联系人1"); LinkMan linkMan2 = new LinkMan(); linkMan2.setLkm_name("联系人2"); LinkMan linkMan3 = new LinkMan(); linkMan3.setLkm_name("联系人3"); linkMan1.setCustomer(customer); customer.getLinkMan().add(linkMan2); customer.getLinkMan().add(linkMan3); // session.save(linkMan1);//发送4条insert语句// session.save(customer);//发送3条insert语句 session.save(linkMan2);//发送1条insert语句 transaction.commit(); &#125; 三、Hibernate的多对多关系映射1、建表多对多关系一定要建立中间表 2、创建实体在两边的实体中都要添加另一方的set集合作为一个属性 3、创建映射12345678910111213141516171819&lt;!-- 建立与角色的多对多的映射关系 --&gt; &lt;!-- set标签 * name ：对方的集合的属性名称。 * table ：多对多的关系需要使用中间表，放的是中间表的名称。 --&gt; &lt;set name="roles" table="sys_user_role" cascade="save-update,delete" &gt; &lt;!-- key标签： * column ：当前的对象对应中间表的外键的名称。 --&gt; &lt;key column="user_id"/&gt; &lt;!-- many-to-many标签： * class ：对方的类的全路径 * column ：对方的对象在中间表中的外键的名称。 --&gt; &lt;many-to-many class="com.itheima.hibernate.domain.Role" column="role_id"/&gt; &lt;/set&gt; 4、多对多的级联保存或更新同样未设置级联操作的时候只保存一方是会抛异常的，注意多对多关系，一定要有一方放弃外键维护，通常是被动方放弃外键维护，这里可以是角色方放弃外键维护inverse=“true” 1）保存用户级联保存角色 在用户的一方的映射文件中配置set的一个cascade属性，值是sava-update 并将逐渐交给该类维护 123456789101112131415161718192021@Test /** * 设置了级联关系的，仅保存用户就可以级联保存角色 */ public void demo2() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); //创建一个用户 User user = new User(); user.setUser_name("用户1"); //创建一个角色 Role role = new Role(); role.setRole_name("角色1"); //设置双向关联关系 user.getRoles().add(role); role.getUsers().add(user); //保存用户即可级联保存用户对应的角色 session.save(user); //提交 transaction.commit(); &#125; 2）保存角色激烈保存用户 在角色的映射中的set加cascade属性，并且维护外键 5、多对多级联删除（基本用不上）6、给用户选择角色1234567891011121314151617&#125;@Test/** * 给用户选择角色（为1号用户添加3号角色） */public void demo5() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); //查1号用户 User user = session.get(User.class, 1l); //查询3号角色 Role role = session.get(Role.class, 3l); //设置一号用户添加3号角色 user.getRoles().add(role); //提交 transaction.commit();&#125; 7、给用户改选角色1234567891011121314151617181920@Test /** * 给用户改选角色（给2号用户选的2号角色改为1号角色 */ public void demo6() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); //查2号用户 User user = session.get(User.class, 2l); //查询2号角色 Role role2 = session.get(Role.class, 2l); //查询1号角色 Role role1 = session.get(Role.class, 1l); //先将2号用户的2号角色删除 user.getRoles().remove(role2); //再重新给二号用户添加1号角色 user.getRoles().add(role1); //提交 transaction.commit(); &#125; 8、给用户删除角色12345678910111213141516@Test /** * 给用户删除角色（给2号用户删除1号角色） */ public void demo7() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); //查2号用户 User user = session.get(User.class, 2l); //查询1号角色 Role role1 = session.get(Role.class, 1l); //先将2号用户的2号角色删除 user.getRoles().remove(role1); //提交 transaction.commit(); &#125; 四、QBC查询、1、 QBC简单查询1234567891011121314@Test /** * QBC简单查询 */ public void demo1() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); Criteria criteria = session.createCriteria(Customer.class); List&lt;Customer&gt; list = criteria.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; transaction.commit(); &#125; 2、 QBC条件查询123456789101112131415@Test /** * QBC条件查询 */ public void demo2() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); Criteria criteria = session.createCriteria(Customer.class); criteria.add(Restrictions.eq("cust_name", "客户1")); List&lt;Customer&gt; list = criteria.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; transaction.commit(); &#125; 3、QBC排序查询12345678910111213141516171819202122232425@Test /** * QBC排序查询 * 等于 eq * 大于 gt * 大于等于 ge * 小于 lt * 小于等于 le * 不等于 ne * like * in * and * or */ public void demo3() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); Criteria criteria = session.createCriteria(Customer.class); criteria.addOrder(Order.desc("cust_id")); List&lt;Customer&gt; list = criteria.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; transaction.commit(); &#125; 4、QBC分页查询1234567891011121314151617@Test/** * QBC分页查询 */public void demo4() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); Criteria criteria = session.createCriteria(Customer.class); criteria.setFirstResult(0); criteria.setMaxResults(2); List&lt;Customer&gt; list = criteria.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; transaction.commit();&#125; 5、 QBC统计查询1234567891011121314151617181920@Test/** * QBC统计查询 * 习惯用HQL */public void demo5() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); Criteria criteria = session.createCriteria(Customer.class); /** * add() 在where后面的条件 * addOrder() 排序 * setProjection 聚合函数和group by having */ criteria.setProjection(Projections.rowCount()); Object obj = criteria.uniqueResult(); System.out.println(obj); transaction.commit();&#125; 6、离线条件查询123456789101112131415161718@Test /** * 离线条件查询 * 在SSH整合和多条件结合查询的时候用的多 */ public void demo6() &#123; DetachedCriteria detachedCriteria = DetachedCriteria.forClass(Customer.class); detachedCriteria.add(Restrictions.eq("cust_name", "客户1")); Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); Criteria criteria = detachedCriteria.getExecutableCriteria(session); List&lt;Customer&gt; list = criteria.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; transaction.commit(); &#125; 五、SQL检索写sql语句 123456789101112131415161718192021222324252627282930@Test /** * SQL查询出放在Object[]数组中 */ public void demo1() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); List&lt;Object[]&gt; list = session.createSQLQuery("select * from cst_Customer").list(); for (Object[] objects : list) &#123; System.out.println(Arrays.toString(objects)); &#125; transaction.commit(); &#125; @Test /** * SQL查询数据封装到对象中 */ public void demo2() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); SQLQuery sqlQuery = session.createSQLQuery("select * from cst_Customer"); sqlQuery.addEntity(Customer.class); List&lt;Customer&gt; list = sqlQuery.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; transaction.commit(); &#125; 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>JavaEE框架</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate 之进阶4——抓取策略]]></title>
    <url>%2F2019%2F04%2F13%2FHibernate%E4%B9%8B%E8%BF%9B%E9%98%B64%E2%80%94%E2%80%94%E6%8A%93%E5%8F%96%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(jing)续(chang)更(duan)新(geng)中，欢迎有兴趣的童鞋们关注。 一、Hibernate优化处理1、缓存2、抓取策略前面已经整理过Hibernate的一级缓存，二级缓存实际开发中用Redis替代 二、延迟加载的概述1、什么是延迟加载延迟加载：lazy（懒加载）。执行到该行代码的时候，不会发送语句去进行查询，在真正使用这个对象的属性的时候才会发送SQL语句进行查询 2、延迟加载的分类 抓取策略往往会和关联级别的延迟加载一起使用，优化语句。 三、抓取策略1、抓取策略概述 fetch主要控制sql的格式，是采用连接方式还是普通查询，lazy控制的是延迟加载 2、&lt;set&gt;上的fetch和lazy 不同的值会产生不同的组合效果，需要可自行配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108@Test /** * 抓取策略默认值 * fetch="select" lazy="truw" * 默认情况下，会发送两条sql语句（查客户、查联系人） */ public void demo1() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); //查询一号客户 Customer customer = session.get(Customer.class, 1l);//发送一条sql语句 //查询1号客户对应的联系人 Set&lt;LinkMan&gt; linkMan = customer.getLinkMan(); //打印联系人 for (LinkMan linkMan2 : linkMan) &#123;//发送一条sql System.out.println(linkMan2); &#125; transaction.commit(); &#125; @Test /** * 抓取策略默认值 * fetch="select" lazy="false" * 会连续发送两条sql语句，而且是查所有 */ public void demo2() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); //查询一号客户 Customer customer = session.get(Customer.class, 1l);//发送2条sql语句,一条查客户，一条查联系人 //查询1号客户对应的联系人，打印联系人个数 System.out.println(customer.getLinkMan().size()); transaction.commit(); &#125; @Test /** * 抓取策略默认值 * fetch="select" lazy="extra" * 想要什么查什么，极其懒惰 */ public void demo3() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); //查询一号客户 Customer customer = session.get(Customer.class, 1l);//发送1条sql语句 //查询1号客户对应的联系人，打印联系人个数 System.out.println(customer.getLinkMan().size());//发送仅查个数的sql语句(select count) transaction.commit(); &#125; @Test /** * 抓取策略默认值 * fetch="join" lazy="extra" * 这个时候lazy失效，迫切左外连接 */ public void demo4() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); //查询一号客户 Customer customer = session.get(Customer.class, 1l);//发送1条sql语句，迫切左外连接语句 //查询1号客户对应的联系人，打印联系人个数 System.out.println(customer.getLinkMan().size());//不发送语句了 transaction.commit(); &#125; @SuppressWarnings("unchecked") @Test /** * 抓取策略默认值 * fetch="subselect" lazy="true" * 子查询，延迟加载 */ public void demo5() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); //查询所有号客户 List&lt;Customer&gt; list = session.createQuery("from Customer").list();//发送一条sql语句 for (Customer customer : list) &#123; System.out.println(customer.getCust_name()); System.out.println(customer.getLinkMan().size());//发送一条子查询语句 &#125; transaction.commit(); &#125; @SuppressWarnings("unchecked") @Test /** * 抓取策略默认值 * fetch="subselect" lazy="false" * 这个时候lazy失效，迫切左外连接 */ public void demo7() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); //查询所有号客户 List&lt;Customer&gt; list = session.createQuery("from Customer").list();//发送一条sql语句查客户，和发送子查询语句 for (Customer customer : list) &#123; System.out.println(customer.getCust_name()); System.out.println(customer.getLinkMan().size()); &#125; transaction.commit(); &#125; 3、&lt;many-to-one&gt;上的fetch和lazy 12345678910111213141516171819202122232425262728293031323334353637383940414243@Test /** * 默认值 * fetch="select" lazy="proxy" */ public void demo1() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); LinkMan linkMan = session.get(LinkMan.class, 1l);//发送一条sql语句 System.out.println(linkMan.getLkm_name()); System.out.println(linkMan.getCustomer().getCust_name());//发送sql语句 transaction.commit(); &#125; @Test /** * 默认值 * fetch="select" lazy="false" */ public void demo2() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); LinkMan linkMan = session.get(LinkMan.class, 1l);//发送2条sql语句，没有延迟加载 System.out.println(linkMan.getLkm_name()); System.out.println(linkMan.getCustomer().getCust_name()); transaction.commit(); &#125; @Test /** * 默认值 * fetch="join" lazy="false" * 和lazy无关，迫切左外连接 * proxy和另外一方class上的lazy是true还是false，默认是true */ public void demo3() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); LinkMan linkMan = session.get(LinkMan.class, 1l);//发送2条sql语句，迫切左外连接 System.out.println(linkMan.getLkm_name()); System.out.println(linkMan.getCustomer().getCust_name()); transaction.commit(); &#125; 4、批量抓取一批关联对象一起抓取，batch-size 比如像通过查询所有客户的同时获得所有联系人的信息，如果不采用批量抓取，会导致多次访问数据库，执行效率很低 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.canghe.test;/** * Hibernate的批量抓取 * @author Administrator * */import java.util.List;import java.util.Set;import org.hibernate.Session;import org.hibernate.Transaction;import org.junit.Test;import com.canghe.domain.Customer;import com.canghe.domain.LinkMan;import com.canghe.util.HibernateUtils;public class HibernateDemo12 &#123; @SuppressWarnings("unchecked") @Test /** * 获取客户时批量获取联系人 * 在Customer.hbm.xml中配置betch_size的值为4，代表每四个客户抓取一次，只会发送2条sql语句 */ public void demo1() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); List&lt;Customer&gt; list = session.createQuery("from Customer").list(); for (Customer customer : list) &#123; System.out.println(customer.getCust_name()); Set&lt;LinkMan&gt; linkMan = customer.getLinkMan(); for (LinkMan linkMan2 : linkMan) &#123; System.out.println(linkMan2.getLkm_name()); &#125; &#125; transaction.commit(); &#125; @SuppressWarnings("unchecked") @Test /** * 获取联系人时获取对应的客户 * 在Customer.hbm.xml中的class上配置betch_size的值为4，代表每四个客户抓取一次，只会发送2条sql语句 */ public void demo2() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); List&lt;LinkMan&gt; list = session.createQuery("from LinkMan").list(); for (LinkMan linkMan : list) &#123; Customer customer = linkMan.getCustomer(); System.out.println(customer.getCust_name()); &#125; transaction.commit(); &#125; &#125; 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>JavaEE框架</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2 的Servlet的API和封装]]></title>
    <url>%2F2019%2F04%2F13%2FServlet%E7%9A%84API%26%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(jing)续(chang)更(duan)新(geng)中，欢迎有兴趣的童鞋们关注。 一、 Struts2的Servlet的API的访问1、完全解耦合的方式所谓完全解耦合的方式就是不能获得作用域的对象，不能调用对象的方法，只能对对象中保存的数据进行操作，用到的是ActionContext对象进行操作 这种方式只能获得代表request、session、application的数据的Map*集合，不能操作这些对象的本身的方法。 1234567891011121314151617public class RequestDemo1 extends ActionSupport&#123; @Override public String execute() throws Exception &#123; //接收参数 ActionContext context = ActionContext.getContext(); Map&lt;String, Object&gt; map = context.getParameters(); for (String key : map.keySet()) &#123; String[] values=(String[]) map.get(key); System.out.println(key+Arrays.toString(values)); &#125; //向域对象中存数据 context.put("requestName", "request的值"); context.getSession().put("sessionName", "session的值"); context.getApplication().put("appName", "app的值"); return "success"; &#125;&#125; 2、使用servlet的API的原生方式就是先获得request等对象，然后可以对对象进行一系列的操作，使用的是ServletActionContext对象，可操作域对象的数据和方法 1234567891011121314151617public class RequestDemo2 extends ActionSupport &#123; @Override public String execute() throws Exception &#123; //获取页面参数 HttpServletRequest request = ServletActionContext.getRequest(); Map&lt;String, String[]&gt; map = request.getParameterMap(); for (String key : map.keySet()) &#123; String[] values = map.get(key); System.out.println(key+"\t"+Arrays.toString(values)); &#125; //保存数据 request.setAttribute("reqNam", "request值"); request.getSession().setAttribute("seNam", "session的值"); ServletActionContext.getServletContext().setAttribute("appNam", "app的值"); return "SUCCESS"; &#125;&#125; 3、接口注入的方式实现相关的接口，得到相应的对象 1234567891011121314151617181920212223242526272829public class RequestDemo3 extends ActionSupport implements ServletRequestAware,ServletContextAware&#123; private HttpServletRequest request; private ServletContext context; @Override public String execute() throws Exception &#123; //获取参数 Map&lt;String, String[]&gt; map = request.getParameterMap(); for (String key : map.keySet()) &#123; String[] values = map.get(key); System.out.println(key+"\t"+Arrays.toString(values)); &#125; //保存数据 request.setAttribute("reqNam", "request值"); request.getSession().setAttribute("seNam", "session的值"); context.setAttribute("appNam", "app的值"); return "SUCCESS"; &#125; @Override public void setServletRequest(HttpServletRequest request) &#123; this.request=request; &#125; @Override public void setServletContext(ServletContext context) &#123; this.context=context; &#125;&#125; 二、单利问题Servlet是单例的，多个程序访问同一个Servlet只会创建一个Servlet的实例。Action是多例的，一次请求，创建一个Action的实例（不会出现线程安全的问题）。 三、结果页面配置1、全局结果页面全局结果页面：全局结果页面指的是，在包中配置一次，其他的在这个包中的所有的action只要返回了这个值，都可以跳转到这个页面。 针对这个包下的所有的action的配置都有效。 1234&lt;!-- 全局的页面配置 --&gt; &lt;global-results&gt; &lt;result name="SUCCESS"&gt;/demo1/demo2.jsp&lt;/result&gt; &lt;/global-results&gt; 2、局部结果页面l局部结果页面：局部结果页面指的是，只能在当前的action中的配置有效。 针对当前的action有效。 123&lt;action name="requestDemo1" class="com.canghe.struts2.demo1.RequestDemo1"&gt; /demo1/demo2.jsp &lt;/action&gt; 四、result标签的配置 五、Struts2的数据封装1、属性驱动：提供属性set方法的方式（不常用）编写页面 123456789&lt;h1&gt;1、属性驱动之提供属性set方法的方式&lt;/h1&gt;&lt;form action="$&#123;pageContext.request.contextPath &#125;/userAction1.action" method="post"&gt; 姓名:&lt;input type="text" name="name"/&gt;&lt;br&gt; 密码：&lt;input type="password" name="password"/&gt;&lt;br&gt; 年龄：&lt;input type="text" name="age"/&gt;&lt;br&gt; 出生日期：&lt;input type="text" name="birthday"/&gt;&lt;br&gt; 工资：&lt;input type="text" name="salary"/&gt;&lt;br&gt; &lt;input type="submit" value="提交"/&gt;&lt;/form&gt; 编写Action 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.canghe.struts2.demo2;/** * 数据封装方式一 * 属性驱动，提供属性和get和set方法 */import java.util.Date;import com.canghe.struts2.domain.User;import com.opensymphony.xwork2.ActionSupport;public class UserAction1 extends ActionSupport &#123; //提供对应的属性 private String name; private String password; private Integer age; private Date birthday; private Double salary; //提供属性对应的set方法 public void setName(String name) &#123; this.name = name; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public void setSalary(Double salary) &#123; this.salary = salary; &#125; @Override public String execute() throws Exception &#123; System.out.println(name); System.out.println(password); System.out.println(age); System.out.println(birthday); System.out.println(salary); User user = new User(); user.setName(name); user.setPassword(password); user.setBirthday(birthday); user.setSalary(salary); System.out.println(user); return NONE; &#125;&#125; 2、属性驱动：页面中提供表达式方式页面 123456789&lt;h1&gt;2、页面提供表达式的方式&lt;/h1&gt;&lt;form action="$&#123;pageContext.request.contextPath &#125;/userAction2.action" method="post"&gt; 姓名:&lt;input type="text" name="user.name"/&gt;&lt;br&gt; 密码：&lt;input type="password" name="user.password"/&gt;&lt;br&gt; 年龄：&lt;input type="text" name="user.age"/&gt;&lt;br&gt; 出生日期：&lt;input type="text" name="user.birthday"/&gt;&lt;br&gt; 工资：&lt;input type="text" name="user.salary"/&gt;&lt;br&gt; &lt;input type="submit" value="提交"/&gt;&lt;/form&gt; Action 1234567891011121314151617181920212223package com.canghe.struts2.demo2;/** * 属性驱动之页面中提供表达式方法 */import com.canghe.struts2.domain.User;import com.opensymphony.xwork2.ActionSupport;public class UserAction2 extends ActionSupport &#123; //创建对象 private User user = new User(); public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; @Override public String execute() throws Exception &#123; System.out.println(user); return NONE; &#125;&#125; 3、 模型驱动：采用模型驱动方式（最常用）页面： 12345678&lt;h1&gt;1、模型驱动——采用模型驱动的方式&lt;/h1&gt;&lt;form action="$&#123;pageContext.request.contextPath &#125;/userAction3.action" method="post"&gt; 姓名:&lt;input type="text" name="name"/&gt;&lt;br&gt; 密码：&lt;input type="password" name="password"/&gt;&lt;br&gt; 年龄：&lt;input type="text" name="age"/&gt;&lt;br&gt; 出生日期：&lt;input type="text" name="birthday"/&gt;&lt;br&gt; 工资：&lt;input type="text" name="salary"/&gt;&lt;br&gt; &lt;input type="submit" value="提交"/&gt; Action 12345678910111213141516171819202122package com.canghe.struts2.demo2;import com.canghe.struts2.domain.User;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.ModelDriven;/** * 数据封装方式三：模型驱动 * @author Administrator * */public class UserAction3 extends ActionSupport implements ModelDriven&lt;User&gt;&#123; private User user = new User(); @Override public String execute() throws Exception &#123; return NONE; &#125; @Override public User getModel() &#123; return user; &#125;&#125; l模型驱动方式最常用的方式，缺点：只能同时向一个对象中封装数据，使用第二种可以向多个对象中同时封装数据 4、关于INPUT逻辑视图 1234&lt;!--INPUT错误调准 --&gt; &lt;global-results&gt; &lt;result name="input"&gt;/demo2/demo1.jsp&lt;/result&gt; &lt;/global-results&gt; 当拦截器按照顺序执行，有一个出错，那么就会跳转到INPUT逻辑视图中，所以需配置全局的INPUT跳转 六、Struts2复杂类型数据的封装比如当我们批量添加商品信息的时候，需要将数据进行封装 1、封装数据到List集合中12345678910111213141516171819202122232425package com.canghe.struts2.demo3;import java.util.List;import com.canghe.struts2.domain.Product;/** * 复杂类型的封装放入list集合中 */import com.opensymphony.xwork2.ActionSupport;public class ProductAction1 extends ActionSupport &#123; private List&lt;Product&gt; products; public List&lt;Product&gt; getProducts() &#123; return products; &#125; public void setProducts(List&lt;Product&gt; products) &#123; this.products = products; &#125; @Override public String execute() throws Exception &#123; for (Product product : products) &#123; System.out.println(product); &#125; return NONE; &#125;&#125; JSP页面： 12345678910&lt;h1&gt;list集合的方式封装复杂类型的数据&lt;/h1&gt;&lt;form action="$&#123;pageContext.request.contextPath &#125;/productAction1.action" method="post"&gt; 商品1名称：&lt;input type="text" name="products[0].name"&gt;&lt;br&gt; 商品1价格：&lt;input type="text" name="products[0].price"&gt;&lt;br&gt; 商品2名称：&lt;input type="text" name="products[1].name"&gt;&lt;br&gt; 商品2价格：&lt;input type="text" name="products[1].price"&gt;&lt;br&gt; 商品3名称：&lt;input type="text" name="products[2].name"&gt;&lt;br&gt; 商品3价格：&lt;input type="text" name="products[2].price"&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; 2、封装数据到Map集合中Action： 123456789101112131415161718192021222324252627package com.canghe.struts2.demo3;import java.util.Map;import com.canghe.struts2.domain.Product;/** * 复杂类型数据的封装——Map集合封装数据 */import com.opensymphony.xwork2.ActionSupport;public class ProductAction2 extends ActionSupport &#123; private Map&lt;String,Product&gt; map; public Map&lt;String, Product&gt; getMap() &#123; return map; &#125; public void setMap(Map&lt;String, Product&gt; map) &#123; this.map = map; &#125; @Override public String execute() throws Exception &#123; //遍历map输出产品信息 for (String key : map.keySet()) &#123; Product product = map.get(key); System.out.println(key+"\t"+product); &#125; return NONE; &#125;&#125; JSP页面： 12345678910&lt;h1&gt;Map集合的方式封装复杂类型的数据&lt;/h1&gt;&lt;form action="$&#123;pageContext.request.contextPath &#125;/productAction2.action" method="post"&gt; 商品1名称：&lt;input type="text" name="map['one'].name"&gt;&lt;br&gt; 商品1价格：&lt;input type="text" name="map['one'].price"&gt;&lt;br&gt; 商品2名称：&lt;input type="text" name="map['two'].name"&gt;&lt;br&gt; 商品2价格：&lt;input type="text" name="map['two'].price"&gt;&lt;br&gt; 商品3名称：&lt;input type="text" name="map['three'].name"&gt;&lt;br&gt; 商品3价格：&lt;input type="text" name="map['three'].price"&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; 九、AOP核心思想鞥切面扩展程序，想要增强某一个方法，来一个切面然后配置一下就好了，不需要修改源代码 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>JavaEE框架</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 入门与常用配置]]></title>
    <url>%2F2019%2F04%2F13%2FSpring%E5%85%A5%E9%97%A8%E4%B8%8E%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(jing)续(chang)更(duan)新(geng)中，欢迎有兴趣的童鞋们关注。 一、Spring概述1、什么是SpringSpring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson在其著作 Expert One-On-One J2EE Development and Design 中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。Spring 使用基本的 JavaBean来完成以前只可能由 EJB 完成的事情。然而，Spring 的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何 Java 应用都可以从 Spring 中受益。Spring 的核心是控制反转（IoC）和面向切面（AOP）。简单来说，Spring 是一个分层的 JavaSE/EEfull-stack(一站式) 轻量级开源框架。 Spring涉及到EE开发的三层 WEB 层:Spring MVC. 业务层:Bean 管理:(IOC) 持久层:Spring 的 JDBC 模板.ORM 模板用于整合其他的持久层框架 2、Spring特点 Spring 就是一个大工厂，可以将所有对象创建和依赖关系维护，交给 Spring 管理AOP 编程的支持 Spring 提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能声明式事务的支持 只需要通过配置就可以完成对事务的管理，而无需手动编程方便程序的测试 Spring 对 Junit4 支持，可以通过注解方便的测试 Spring 程序方便集成各种优秀框架 Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz 等）的直接支持降低 JavaEE API 的使用难度 Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等），都提供了封装，使这些 API 应用难度大大降低 二、Spring的IOC1、IOC的底层实现原理IOC：Inversion of Control 控制反转. 指的是 对象的创建权反转(交给)给 Spring.作用是实现了程序的解耦合. 2、IOC和DIIOC :控制反转,将对象的创建权交给了 Spring.DI :Dependency Injection 依赖注入.需要有 IOC 的环境,Spring 创建这个类的过程中,Spring 将类的依赖的属性设置进去. 面向对象中类与类之间的关系： 依赖：如B类方法中需要将A类传入 继承：is a的关系 聚合：has a的关系 三、Spring的工厂1、BeanFactory旧版本，调用getBean方法时，才会实例化类 2、ApplicationContext实现了BeanFactory，加载配置文件的时候就会实例化 实现类： ClassPathXmlApplicationContext :加载类路径下 Spring 的配置文件.FileSystemXmlApplicationContext :加载本地磁盘下 Spring 的配置文件. 四、Spring的相关配置1、bean标签属性id和name配置id :Bean 起个名字. 在约束中采用 ID 的约束:唯一.必须以字母开始，可以使用字母、数字、连字符、下划线、句话、冒号 id:不能出现特殊字符. name:Bean 起个名字. 没有采用 ID 的约束. name:出现特殊字符.如果没有 id 的话 , name 可以当做 id 使用. 整合 struts1 的时候: 2、bean标签属性scopebean的作用范围 singleton :默认值，单例的. prototype :多例的. request :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 request 域中. session :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 session 域中. globalSession :WEB 项目中,应用在 Porlet 环境.如果没有 Porlet 环境那么 globalSession 相当于 session. 3、Bean 的生命周期的配置通过配置标签上的 init-method 作为 Bean 的初始化的时候执行的方法，配置 destroy-method作为 Bean 的销毁的时候执行的方法。销毁方法想要执行，需要是单例创建的 Bean 而且在工厂关闭的时候，Bean 才会被销毁. 五、Spring的bean管理1、 Spring 生成 Bean 的时候三种方式【无参数的构造方法的方式:】 1&lt;bean id=&quot;bean1&quot; class=&quot;cn.itcast.spring.demo3.Bean1&quot;&gt;&lt;/bean&gt; 【静态工厂实例化的方式】 【实例工厂实例化的方式】 2、 Spring 的 Bean 的属性注入1）【构造方法的方式注入属性】 1234&lt;bean id=&quot;car&quot; class=&quot;cn.itcast.spring.demo4.Car&quot;&gt;&lt;constructor-arg name=&quot;name&quot; value=&quot;保时捷&quot;/&gt;&lt;constructor-arg name=&quot;price&quot; value=&quot;1000000&quot;/&gt;&lt;/bean&gt; 如果注入的是对象，value属性要改为ref属性引用另一个 bean 的 id 或 name 2）【set 方法的方式注入属性】 1234&lt;bean id=&quot;car2&quot; class=&quot;cn.itcast.spring.demo4.Car2&quot;&gt;&lt;property name=&quot;name&quot; value=&quot;奇瑞 QQ&quot;/&gt;&lt;property name=&quot;price&quot; value=&quot;40000&quot;/&gt;&lt;/bean&gt; 比较常用，需要在类中提供set方法 如果注入的是对象，value属性要改为ref属性引用另一个 bean 的 id 或 name 3） 名称空间 p 的属性注入的方式 Spring2.x 版本后提供的方式 第一步:引入 p 名称空间 第二步:使用 p 名称空间. 普通属性: p:属性名称=”” 对象类型属性: p:属性名称-ref=”” 12345&lt;!-- p 名称空间的属性注入的方式 --&gt;&lt;bean id=&quot;car2&quot; class=&quot;cn.itcast.spring.demo4.Car2&quot; p:name=&quot; 宝 马 7&quot;p:price=&quot;1200000&quot;/&gt;&lt;bean id=&quot;person&quot; class=&quot;cn.itcast.spring.demo4.Person&quot; p:name=&quot; 思 聪 &quot;p:car2-ref=&quot;car2&quot;/&gt; 4）SpEL 的方式的属性注入 Spring3.x 版本后提供的方式 123456789101112131415161718SpEL：Spring Expression Language.语法:#&#123; SpEL &#125;&lt;!-- SpEL 的注入的方式 --&gt;&lt;bean id="car2" class="cn.itcast.spring.demo4.Car2"&gt;&lt;property name="name" value="#&#123;'奔驰'&#125;"/&gt;&lt;property name="price" value="#&#123;800000&#125;"/&gt;&lt;/bean&gt; &lt;bean id="person" class="cn.itcast.spring.demo4.Person"&gt; &lt;property name="name" value="#&#123;'冠希'&#125;"/&gt; &lt;property name="car2" value="#&#123;car2&#125;"/&gt; &lt;/bean&gt;&lt;bean id="carInfo" class="cn.itcast.spring.demo4.CarInfo"&gt;&lt;/bean&gt;引用了另一个类的属性&lt;bean id="car2" class="cn.itcast.spring.demo4.Car2"&gt;&lt;!-- &lt;property name="name" value="#&#123;'奔驰'&#125;"/&gt; --&gt;&lt;property name="name" value="#&#123;carInfo.carName&#125;"/&gt;&lt;property name="price" value="#&#123;carInfo.calculatePrice()&#125;"/&gt;&lt;/bean&gt; 5）注入复杂类型 1234567891011121314151617181920212223242526272829303132&lt;!-- Spring 的复杂类型的注入===================== --&gt;&lt;bean id=&quot;collectionBean&quot; class=&quot;cn.itcast.spring.demo5.CollectionBean&quot;&gt;&lt;!-- 数组类型的属性 --&gt;&lt;property name=&quot;arrs&quot;&gt;&lt;list&gt;&lt;value&gt;会希&lt;/value&gt;&lt;value&gt;冠希&lt;/value&gt;&lt;value&gt;天property&gt;&lt;!-- 注入 List 集合的数据 --&gt;&lt;property name=&quot;list&quot;&gt;&lt;list&gt;&lt;value&gt;芙蓉&lt;/value&gt;&lt;value&gt;如花&lt;/value&gt;&lt;value&gt;凤姐&lt;/value&gt;&lt;/list&gt;&lt;/property&gt;&lt;!-- 注入 Map 集合 --&gt;&lt;property name=&quot;map&quot;&gt;&lt;map&gt;&lt;entry key=&quot;aaa&quot; value=&quot;111&quot;/&gt;&lt;entry key=&quot;bbb&quot; value=&quot;222&quot;/&gt;&lt;entry key=&quot;ccc&quot; value=&quot;333&quot;/&gt;&lt;/map&gt;&lt;/property&gt;&lt;!-- Properties 的注入 --&gt;&lt;property name=&quot;properties&quot;&gt;&lt;props&gt;&lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt;&lt;prop key=&quot;password&quot;&gt;123&lt;/prop&gt;&lt;/props&gt;&lt;/property&gt;&lt;/bean&gt; 3、分模块开发12345一种:创建工厂的时候加载多个配置文件:ApplicationContext applicationContext = newClassPathXmlApplicationContext("applicationContext.xml","applicationContext2.xml");二种:在一个配置文件中包含另一个配置文件：&lt;import resource="applicationContext2.xml"&gt;&lt;/import&gt; 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>JavaEE框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2 中的拦截器和标签库]]></title>
    <url>%2F2019%2F04%2F13%2FStruts2%E4%B8%AD%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E6%A0%87%E7%AD%BE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(入)中，欢迎有兴趣的童鞋们关注。 一、写在前面的话现在是19年的二月17号，一个很好的日子，可是心情却不是很好。我已经失恋4天，可是我并没有忘记这些回忆。在一起的日子总是短暂的，没有人能命令别人做任何事，只有程序会按照你的想法走，这或许就是生活吧，希望各位均安好！ 二、Struts2中的拦截器1、什么是拦截器2、Struts2的执行流程客户端向服务器发送一个Action的请求，执行核心过滤器（doFilter）方法。在这个方法中，调用executeAction()方法，在这个方法内部调用dispatcher.serviceAction();在这个方法内部创建一个Action代理，最终执行的是Action代理中的execute(),在代理中执行的execute方法中调用ActionInvocation的invoke方法。在这个方法内部递归执行一组拦截器（完成部分功能），如果没有下一个拦截器，就会执行目标Action，根据Action的返回的结果进行页面跳转。3、自定义拦截器 12345678910111213141516/** * 自定义的拦截器一 * @author jt * */public class InterceptorDemo1 extends AbstractInterceptor&#123; @Override public String intercept(ActionInvocation invocation) throws Exception &#123; System.out.println("InterceptorDemo1执行了..."); String obj = invocation.invoke(); System.out.println("InterceptorDemo1执行结束了..."); return obj; &#125;&#125; 4、拦截器的配置 1234567891011121314151617181920212223242526272829303132&lt;package name="demo1" extends="struts-default" namespace="/"&gt; &lt;!-- 定义拦截器========== --&gt; &lt;!-- &lt;interceptors&gt; &lt;interceptor name="interceptorDemo1" class="com.itheima.web.interceptor.InterceptorDemo1"/&gt; &lt;interceptor name="interceptorDemo2" class="com.itheima.web.interceptor.InterceptorDemo2"/&gt; &lt;/interceptors&gt; --&gt; &lt;interceptors&gt; &lt;interceptor name="interceptorDemo1" class="com.itheima.web.interceptor.InterceptorDemo1"/&gt; &lt;interceptor name="interceptorDemo2" class="com.itheima.web.interceptor.InterceptorDemo2"/&gt; &lt;!-- 定义拦截器栈 --&gt; &lt;interceptor-stack name="myStack"&gt; &lt;interceptor-ref name="defaultStack"/&gt; &lt;interceptor-ref name="interceptorDemo1"/&gt; &lt;interceptor-ref name="interceptorDemo2"/&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; &lt;action name="actionDemo1" class="com.itheima.web.action.ActionDemo1"&gt; &lt;result&gt;/demo1/demo1.jsp&lt;/result&gt; &lt;!-- 引入拦截器(一旦引入自定义拦截器，默认拦截器栈的拦截器就不执行了。)=========== --&gt; &lt;interceptor-ref name="myStack"/&gt; &lt;!-- &lt;interceptor-ref name="defaultStack"/&gt; &lt;interceptor-ref name="interceptorDemo1"/&gt; &lt;interceptor-ref name="interceptorDemo2"/&gt; --&gt; &lt;/action&gt; &lt;action name="uiAction" class="com.itheima.web.action.UIAction"&gt; &lt;result name="input"&gt;/demo2/demo3.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; 5、权限拦截器 12345678910111213141516171819202122232425/** * 权限拦截器 * * @author jt */public class PrivilegeInterceptor extends MethodFilterInterceptor &#123; @Override protected String doIntercept(ActionInvocation invocation) throws Exception &#123; // 判断session中是否存在用户数据: User existUser = (User) ServletActionContext.getRequest().getSession().getAttribute("existUser"); // 判断从session中获取的用户的信息是否为空: if(existUser == null)&#123; // 没有登录 // 给出提示信息 ActionSupport actionSupport = (ActionSupport) invocation.getAction(); actionSupport.addActionError("没有登录！没有权限访问！"); // 回到登录页面 return actionSupport.LOGIN; &#125;else&#123; // 已经登录 return invocation.invoke(); &#125; &#125; 权限拦截器的配置 123456789101112131415161718192021222324252627282930&lt;package name="crm" extends="struts-default" namespace="/"&gt; &lt;!-- 定义拦截器 --&gt; &lt;interceptors&gt; &lt;interceptor name="privilegeInterceptor" class="com.itheima.web.interceptor.PrivilegeInterceptor"/&gt; &lt;/interceptors&gt; &lt;global-results&gt; &lt;result name="login"&gt;/login.jsp&lt;/result&gt; &lt;/global-results&gt; &lt;action name="customer_*" class="com.itheima.web.action.CustomerAction" method="&#123;1&#125;"&gt; &lt;result name="findSuccess"&gt;/jsp/customer/list.jsp&lt;/result&gt; &lt;result name="saveUI"&gt;/jsp/customer/add.jsp&lt;/result&gt; &lt;result name="saveSuccess" type="redirectAction"&gt;customer_find.action&lt;/result&gt; &lt;!-- 引入拦截器 --&gt; &lt;interceptor-ref name="privilegeInterceptor"/&gt; &lt;interceptor-ref name="defaultStack"/&gt; &lt;/action&gt; &lt;action name="user_*" class="com.itheima.web.action.UserAction" method="&#123;1&#125;"&gt; &lt;result name="success" type="redirect"&gt;/index.jsp&lt;/result&gt; &lt;!-- 引入拦截器 --&gt; &lt;interceptor-ref name="privilegeInterceptor"&gt; &lt;param name="excludeMethods"&gt;login&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name="defaultStack"/&gt; &lt;/action&gt; &lt;/package&gt; 三、Struts2的标签库1、通用标签库 12345678910&lt;s:set var="i" value="5" scope="request"/&gt;&lt;s:if test="#request.i&gt;3"&gt; i 大于 3&lt;/s:if&gt;&lt;s:elseif test="#request.i&lt;3"&gt; i 小于 3&lt;/s:elseif&gt;&lt;s:else&gt; i 等于 3&lt;/s:else&gt; 1234567891011121314151617181920&lt;s:iterator var="i" value="&#123;'aa','bb','cc'&#125;"&gt; &lt;s:property value="#i"/&gt;&lt;/s:iterator&gt;&lt;hr/&gt;&lt;s:iterator var="entry" value="#&#123;'aaa':'111','bbb':'222','ccc':'333'&#125;"&gt; &lt;s:property value="#entry.key"/&gt;--&lt;s:property value="#entry.value"/&gt;&lt;/s:iterator&gt;&lt;hr/&gt;&lt;s:iterator var="i" begin="1" end="10" step="1"&gt; &lt;s:property value="#i"/&gt;&lt;/s:iterator&gt;&lt;hr/&gt;&lt;s:iterator var="i" begin="100" end="300" step="5" status="status"&gt; &lt;s:if test="#status.count % 3 == 0"&gt; &lt;font color="red"&gt;&lt;s:property value="#i"/&gt;&lt;/font&gt; &lt;/s:if&gt; &lt;s:else&gt; &lt;s:property value="#i"/&gt; &lt;/s:else&gt;&lt;/s:iterator&gt; 2、UI标签库（常用作数据回显） 12345678910111213141516171819202122232425262728293031323334353637&lt;h1&gt;UI标签&lt;/h1&gt;&lt;h3&gt;传统的表单&lt;/h3&gt;&lt;form action="$&#123; pageContext.request.contextPath &#125;/uiAction.action" method="post"&gt; &lt;input type="hidden" name="id"/&gt; 用户名:&lt;input type="text" name="name"/&gt;&lt;br/&gt; 密码:&lt;input type="password" name="password"&gt;&lt;br/&gt; 年龄:&lt;input type="text" name="age"&gt;&lt;br/&gt; 性别:&lt;input type="radio" name="sex" value="男"&gt;男 &lt;input type="radio" name="sex" value="女"&gt;女&lt;br/&gt; 籍贯:&lt;select name="city"&gt; &lt;option value=""&gt;-请选择-&lt;/option&gt; &lt;option value="北京"&gt;北京&lt;/option&gt; &lt;option value="上海"&gt;上海&lt;/option&gt; &lt;option value="深圳"&gt;深圳&lt;/option&gt; &lt;option value="韩国"&gt;韩国&lt;/option&gt; &lt;/select&gt;&lt;br/&gt; 爱好:&lt;input type="checkbox" name="hobby" value="basketball"/&gt;篮球 &lt;input type="checkbox" name="hobby" value="football"/&gt;足球 &lt;input type="checkbox" name="hobby" value="volleyball"/&gt;排球 &lt;input type="checkbox" name="hobby" value="pingpang"/&gt;乒乓球&lt;br/&gt; 介绍:&lt;textarea name="info" cols="8" rows="2"&gt;&lt;/textarea&gt;&lt;br/&gt; &lt;input type="submit" value="提交"/&gt;&lt;/form&gt;&lt;s:debug&gt;&lt;/s:debug&gt;&lt;h3&gt;UI标签的表单&lt;/h3&gt;&lt;s:form action="uiAction" namespace="/" method="post" &gt; &lt;s:hidden name="id" /&gt; &lt;s:textfield name="name" label="用户名"/&gt; &lt;s:password name="password" label="密码" showPassword="true"/&gt; &lt;s:textfield name="age" label="年龄"/&gt; &lt;s:radio list="&#123;'男','女'&#125;" name="sex" label="性别"/&gt; &lt;s:select list="&#123;'北京','上海','深圳','韩国'&#125;" name="city" label="籍贯" headerKey="" headerValue="-请选择-"/&gt; &lt;s:checkboxlist list="#&#123;'basketball':'篮球','football':'足球','volleyball':'排球','pingpang':'乒乓球'&#125;" name="hobby" label="爱好"/&gt; &lt;s:textarea name="info" cols="8" rows="2" label="介绍" &gt;&lt;/s:textarea&gt; &lt;s:submit value="提交"/&gt;&lt;/s:form&gt; 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>JavaEE框架</category>
      </categories>
      <tags>
        <tag>拦截器</tag>
        <tag>标签库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2 入门&常见配置]]></title>
    <url>%2F2019%2F04%2F13%2Fstruts2%E5%85%A5%E9%97%A8%26%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(入)中，欢迎有兴趣的童鞋们关注。 一、Struts2的概述1、什么是Struts2是一个机遇MVC设计模式的web层框架 2、常见的web层框架Struts2 Struts1 Webwork SpringMVC 所有web层框架都有一个特点就是都是基于前端控制器实现的 3、前端控制器模式传统的servlet开发，有一次请求就会对应一个servlet，这样会导致出现很多的servlet，而Struts2的请求都会先经过前端控制器，在前端控制器中实现框架的部分功能，剩下的具体操作要提交到具体的Action中过滤器是最好的前端控制器的实现方式 二、Struts2快速入门1、Struts2开发包目录结构apps：提供Struts2提供的示例程序，其中有一个blank.war可以用来赋值基础的一些jar包 does：Struts2的官方文档，API文档 lib：jar包以及第三方插件类库 src：Struts2的源代码 2、Struts2的开发流程当客户端发送强求过来，先经过前端控制器（核心过滤器StrutsPrepareAndExecuteFilter)过滤器中执行一组拦截器，一组拦截器就会完成部分功能，拦截器执行完成以后，就会执行目标Action，在Action中返回一个结果视图，根据Struts.xml中配置实现页面跳转 3、Action类12345678910111213141516public class CustomerAction extends ActionSupport &#123; /** * 查询客户列表的方法 * @return */ public String findAll() &#123; System.out.println("CustomerAction&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"); //创建业务层类的对象 CutomerService cutomerService = new CutomerServiceImpl(); //调用业务层的方法查询所有客户 List&lt;Customer&gt; list = cutomerService.findAll(); //获得request对象并保存在request中 ServletActionContext.getRequest().setAttribute("list", list); return "findAll"; &#125;&#125; 4、Action类配置Struts2.xml123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN" "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt; &lt;!-- Struts2为了管理Action的配置，通过包进行管理 --&gt; &lt;!-- 配置Struts的包 --&gt; &lt;!-- name包名可以随意取，但是不能有重复 --&gt; &lt;!-- 继承了struts-default的包 --&gt; &lt;package name="crm" extends="struts-default" namespace="/"&gt; &lt;!-- 配置Action --&gt; &lt;!-- name需要和访问的路径对应起来 这里访问的是hello.action--&gt; &lt;action name="customer_*" class="com.canghe.web.action.CustomerAction" method="&#123;1&#125;"&gt; &lt;!-- 配置页面的跳转 --&gt; &lt;result name="findAll" &gt;/jsp/customer/list.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 5、配置前端控制器（核心过滤器）123456789&lt;!-- Struts2的核心过滤器配置 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 三、Struts2的常见配置1、eclipse中xml的did配置这样写配置文件到 时候会有提示（不是联网的时候） 2、Struts2配置文件的加载顺序 加载顺序 一般在struts.xml中进行配置 3、Action的配置1）package标签配置 lpackage标签称为包，这个包与Java中的包的概念不一致。包为了更好管理action的配置。 2）action标签配置 4、Struts2常量配置 5、分模块开发的配置实际开发中分模块发开进行的Struts.xml每个人各自配置，然后需要整合到主struts.xml配置中使用的 是include标签，将各个模块的xml配置整合进来 四、Action的访问1、Action的写法1）Action类是POJO类 POJO就是不继承任何类也不识闲任何借口 的普通类 只需要写一个有返回String的execute方法 123456789101112package com.canghe.strutts.demo1;/** * struts入门的action类 * @author Administrator * */public class HelloAction &#123; public String execute() &#123; System.out.println("helloAction 执行了 。。。"); return "success"; &#125;&#125; 2） Action类实现一个Action的接口 12345678910111213141516package com.canghe.strutts.demo2;/** * Action实现Action接口 * 里面有五个逻辑视图名称 */import com.opensymphony.xwork2.Action;public class ActionDemo2 implements Action&#123; @Override public String execute() throws Exception &#123; System.out.println("ActionDemo2执行&lt;&lt;&lt;&lt;&lt;"); return null; &#125;&#125; 3） Action类继承ActionSupport类 1234567891011package com.canghe.strutts.demo2;import com.opensymphony.xwork2.ActionSupport;public class ActionDemo3 extends ActionSupport&#123; @Override public String execute() throws Exception &#123; System.out.println("Action方式三&lt;&lt;&lt;&lt;&lt;&lt;"); return NONE; &#125;&#125; 实际开发中，常用继承ActionSupport的方式写Action，里面含有数据校验、国际化操作的一系列方法 2、Action的访问1）通过method设置 配置： 1234&lt;action name="userFind" class="com.canghe.strutts.demo3.StrutsDemo1" method="find"&gt;&lt;/action&gt; &lt;action name="userUpdate" class="com.canghe.strutts.demo3.StrutsDemo1" method="update"&gt;&lt;/action&gt; &lt;action name="userDelete" class="com.canghe.strutts.demo3.StrutsDemo1" method="update"&gt;&lt;/action&gt; &lt;action name="userSaves" class="com.canghe.strutts.demo3.StrutsDemo1" method="save"&gt;&lt;/action&gt; 页面“ 12345&lt;h3&gt;method方式设置Action的访问&lt;/h3&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/userFind.action"&gt;查找用户&lt;/a&gt;&lt;br&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/userUpdate.action"&gt;修改用户&lt;/a&gt;&lt;br&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/userDelete.action"&gt;删除用户&lt;/a&gt;&lt;br&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/userSaves.action"&gt;保存用户&lt;/a&gt;&lt;br&gt; Action类： 12345678910111213141516171819202122package com.canghe.strutts.demo3;import com.opensymphony.xwork2.ActionSupport;public class StrutsDemo1 extends ActionSupport&#123; public String find() &#123; System.out.println("查找用户&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"); return NONE; &#125; public String update() &#123; System.out.println("修改用户&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"); return NONE; &#125; public String delete() &#123; System.out.println("删除用户&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"); return NONE; &#125; public String save() &#123; System.out.println("保存用户&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"); return NONE; &#125;&#125; 2）通过通配符的方式访问（常用） 页面访问连接写法： 12345&lt;h3&gt;通配符方式设置Action的访问&lt;/h3&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/product_find.action"&gt;查找用户&lt;/a&gt;&lt;br&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/product_update.action"&gt;修改用户&lt;/a&gt;&lt;br&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/product_delete.action"&gt;删除用户&lt;/a&gt;&lt;br&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/product_save.action"&gt;保存用户&lt;/a&gt;&lt;br&gt; 配置文件的写法： 12&lt;!-- 通过通配符的方式配置 --&gt; &lt;action name="product_*" class="com.canghe.strutts.demo3.StrutsDemo2" method="&#123;1&#125;"&gt;&lt;/action&gt; 还有一种更抽象的写法 3）动态方法访问 12&lt;!-- 开启动态方法访问 --&gt; &lt;constant name="struts.enable.DynamicMethodInvocation" value="true"&gt;&lt;/constant&gt; 12&lt;!-- 通过动态访问的方式访问action --&gt; &lt;action name="customer" class="com.canghe.strutts.demo3.StrutsDemo3"&gt;&lt;/action&gt; 12345&lt;h3&gt;动态访问设置Action的访问&lt;/h3&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/customer!find.action"&gt;查找用户&lt;/a&gt;&lt;br&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/customer!update.action"&gt;修改用户&lt;/a&gt;&lt;br&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/customer!delete.action"&gt;删除用户&lt;/a&gt;&lt;br&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/customer!save.action"&gt;保存用户&lt;/a&gt;&lt;br&gt; 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>JavaEE框架</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 注解IOC和AOP]]></title>
    <url>%2F2019%2F04%2F13%2F%E6%B3%A8%E8%A7%A3IOC%E5%92%8CAOP%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(ru)中，欢迎有兴趣的童鞋们关注。 一、Spring的bean管理（注解方式）1、配置组件扫描扫描类下的注解，哪些包下的类需要使用IOC注解 12&lt;!-- Spring 的注解开发:组件扫描(类上注解: 可以直接使用属性注入的注解) --&gt;&lt;context:component-scan base-package="com.itheima.spring.demo1"/&gt; 2、在类上添加注解1234567@Component(value="userDao")public class UserDaoImpl implements UserDao &#123;@Overridepublic void sayHello() &#123;System.out.println("Hello Spring Annotation...");&#125;&#125; 相当于在xml中用bean标签配置类 二、Spring的bean管理常用注解1、@Component:组件.(作用在类上)12345Spring 中提供@Component 的三个衍生注解:(功能目前来讲是一致的)* @Controller :WEB 层* @Service :业务层* @Repository :持久层这三个注解是为了让标注类本身的用途清晰，Spring 在后续版本会对其增强 2、属性注入的注解:(使用注解注入的方式,可以不用提供 set 方法.)1234567@Value :用于注入普通类型.@Autowired :自动装配:* 默认按类型进行装配.* 按名称注入:* @Qualifier:强制使用名称注入.@Resource 相当于:* @Autowired 和@Qualifier 一起使用. 3、Bean 的作用范围的注解@Scope: singleton:单例 prototype:多例 4、 Bean 的生命周期的配置@PostConstruct :相当于 init-method@PreDestroy :相当于 destroy-method 三、注解和xml对bean管理区别1、区别XML 和注解: XML :结构清晰. 注解 :开发方便.(属性注入.)实际开发中还有一种 XML 和注解整合开发: 注意：注解方式的这个类是自己提供，但是xml的话可以适用所有类 2、两种方式结合Bean 有 XML 配置.但是使用的属性使用注解注入. 在没有扫描下，使用属性注入的注解，需要加上这个配置 1&lt;context:annotation-config&gt; 四、AOP的概述1、什么是AOPAOP是指面向切面编程，是oop的延续，可以为业务逻辑的各个部分进行隔离，解决oop开发遇到的问题，使得业务间的耦合性降低 2、AOP特点可以对程序，或者通俗的说是对类的方法进行增强，在不修改源代码的条件下 AOP可以进行权限校验，日志记录，性能监控，事务控制 3、AOP的底层实现原理底层利用了代理机制 Spring 的 AOP 的底层用到两种代理机制： JDK 的动态代理 :针对实现了接口的类产生代理. Cglib 的动态代理 :针对没有实现接口的类产生代理. 应用的是底层的字节码增强的技术 生成当前类的子类对象. 4、Spring底层AOP的实现原理1）JDK 动态代理增强一个类中方法 123456789101112131415161718192021public class MyJDKProxy implements InvocationHandler &#123;private UserDao userDao;public MyJDKProxy(UserDao userDao) &#123;this.userDao = userDao;&#125;// 编写工具方法：生成代理：public UserDao createProxy()&#123;UserDao userDaoProxy = (UserDao)Proxy.newProxyInstance(userDao.getClass().getClassLoader(),userDao.getClass().getInterfaces(), this);return userDaoProxy;&#125;@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable&#123;if("save".equals(method.getName()))&#123;System.out.println("权限校验================");&#125;return method.invoke(userDao, args);&#125;&#125; 2）Cglib 动态代理增强一个类中的方法 12345678910111213141516171819202122232425262728public class MyCglibProxy implements MethodInterceptor&#123;private CustomerDao customerDao;public MyCglibProxy(CustomerDao customerDao)&#123;this.customerDao = customerDao;&#125;// 生成代理的方法:public CustomerDao createProxy()&#123;// 创建 Cglib 的核心类:Enhancer enhancer = new Enhancer();// 设置父类:enhancer.setSuperclass(CustomerDao.class);// 设置回调:enhancer.setCallback(this);// 生成代理：CustomerDao customerDaoProxy = (CustomerDao) enhancer.create();return customerDaoProxy;&#125;@Overridepublic Object intercept(Object proxy, Method method, Object[] args, MethodProxymethodProxy) throws Throwable &#123;if("delete".equals(method.getName()))&#123;Object obj = methodProxy.invokeSuper(proxy, args);System.out.println("日志记录================");return obj;&#125;return methodProxy.invokeSuper(proxy, args);&#125;&#125; 五、AOP 的开发中的相关术语1、连接点Joinpoint可以被拦截到的点，在 spring 中,这些点指的是方法,因为 spring 只支持方法类型的连接点。 2、切入点Pointcut真正被拦截到的点，就是我们真正需要去增强的方法 3、通知/增强Advice就是为切入点增强功能的那些个方法，比如权限校验方法等.通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能) 4、切面Aspect是切入点和通知（引介）的结合 5、引介Introduction引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方法或 Field.，是类层面的 6、目标对象Target:代理的目标对象 7、织入Weaving是指把增强应用到目标对象来创建新的代理对象的过程，spring 采用动态代理织入， 8、代理Proxy一个类被 AOP 织入增强后，就产生一个结果代理类 六、Spring使用 AspectJ 进行 AOP 的开发：XML 的方式1、Spring整合Junit进行单元测试引入Spring-test的jar包，不需要再创建工厂，直接测试 类注解： 12@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml") 依赖注入： @Resource(name=”orderDao”) 2、编写切面类将增强的方法放进来，比如权限校验等 3、通过AOP配置，为目标类生成代理123456789101112&lt;!-- 配置切面类 --&gt;&lt;bean id="myAspectXml" class="cn.itcast.spring.demo3.MyAspectXml"&gt;&lt;/bean&gt;&lt;!-- 进行 aop 的配置 --&gt;&lt;aop:config&gt;&lt;!-- 配置切入点表达式:哪些类的哪些方法需要进行增强 --&gt;&lt;aop:pointcut expression="execution(*cn.itcast.spring.demo3.OrderDao.save(..))" id="pointcut1"/&gt;&lt;!-- 配置切面 --&gt;&lt;aop:aspect ref="myAspectXml"&gt;&lt;aop:before method="before" pointcut-ref="pointcut1"/&gt;&lt;/aop:aspect&gt;&lt;/aop:config&gt; 4、其他增强的配置1234567891011121314151617181920&lt;aop:config&gt; &lt;!-- 表达式配置哪些类的哪些方法需要增强 点点代表任意参数--&gt; &lt;aop:pointcut expression="execution(* com.canghe.demo1.PruductDaoImpl.save(..))" id="pointcut1"/&gt; &lt;aop:pointcut expression="execution(* com.canghe.demo1.PruductDaoImpl.delete(..))" id="pointcut2"/&gt; &lt;aop:pointcut expression="execution(* com.canghe.demo1.PruductDaoImpl.update(..))" id="pointcut3"/&gt; &lt;aop:pointcut expression="execution(* com.canghe.demo1.PruductDaoImpl.find(..))" id="pointcut4"/&gt; &lt;!-- 配置切面 --&gt; &lt;aop:aspect ref="myAspect"&gt; &lt;!-- 配置前置通知 --&gt; &lt;aop:before method="checkPri" pointcut-ref="pointcut1"/&gt; &lt;!-- 配置后置通知 --&gt; &lt;aop:after-returning method="weiteLog" pointcut-ref="pointcut2" returning="result"/&gt; &lt;!-- 配置环绕通知 --&gt; &lt;aop:around method="around" pointcut-ref="pointcut3"/&gt; &lt;!-- 配置异常抛出通知 --&gt; &lt;aop:after-throwing method="afterThrowing" pointcut-ref="pointcut4" throwing="ex" /&gt; &lt;!-- 配最终异知 --&gt; &lt;aop:after method="after" pointcut-ref="pointcut4" /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 七、Spring通知类型和使用每种通知均可获得切入点信息 1、前置通知如权限校验 在目标方法执行之前执行 1&lt;aop:before method=&quot;checkPri&quot; pointcut-ref=&quot;pointcut1&quot;/&gt; 2、后置通知如：日志记录 在目标方法执行之后执行 获得方法的返回值 12&lt;!-- 配置后置通知 --&gt;&lt;aop:after-returning method="weiteLog" pointcut-ref="pointcut2" returning="result"/&gt; 然后将result作为参数传入切面中的通知 3、环绕通知如：性能监控 在目标方法执行前和执行后执行 可以阻止目标方法的执行 在通知类方法要有Object返回值，设置如下： 12345678910/** * 环绕通知——性能监控 * @throws Throwable */ public Object around(ProceedingJoinPoint joinPoint) throws Throwable &#123; System.out.println("环绕通知前=============="); Object object = joinPoint.proceed(); System.out.println("环绕通知后=============="); return object; &#125; 4、异常抛出通知在目标方法执行出现 异常的时候 执行 可得到异常信息， 12345678&lt;!-- 配置异常抛出通知 --&gt; &lt;aop:after-throwing method="afterThrowing" pointcut-ref="pointcut4" throwing="ex" /&gt; /** * 异常抛出通知 */ public void afterThrowing(Throwable ex) &#123; System.out.println("异常抛出通知============="+ex.getMessage()); &#125; 5、最终通知无论目标方法是否出现异常 最终通知都会 执行 12&lt;!-- 配最终异知 --&gt; &lt;aop:after method="after" pointcut-ref="pointcut4" /&gt; layout: posttitle: webstorm 上导入文件中文乱码问题解决categories: JavaWeb前端基础description: webstorm 上导入文件中文乱码问题解决 keywords: JavaEE, HTML,CSS,webstorm本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(入)中，欢迎有兴趣的童鞋们关注。 八、切入点表达式写法execution(表达式) 123456表达式:[方法访问修饰符] 方法返回值 包名.类名.方法名(方法的参数)public * cn.itcast.spring.dao.*.*(..)* cn.itcast.spring.dao.*.*(..)* cn.itcast.spring.dao.UserDao+.*(..)* cn.itcast.spring.dao..*.*(..) 九、AOP核心思想鞥切面扩展程序，想要增强某一个方法，来一个切面然后配置一下就好了，不需要修改源代码 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>JavaEE框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>bean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse 中 tomcat-advanced 以及插件的使用]]></title>
    <url>%2F2019%2F04%2F13%2Feclipse%E4%B8%ADtomcat-advanced%E4%BB%A5%E5%8F%8A%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(ru)中，欢迎有兴趣的童鞋们关注。 一、问题背景今天新需求，需要用到eclipse的tomcat插件，且项目的编译环境为JDK1.7及以下，而我电脑之前的JDK为1.8，tomcat为8，现在也就是要切换JDK版本为1.7且tomcat为7，搞来搞去，搞了一天，必须记录下 二、同一电脑安装不同版本的JDK和tomcat1、网上很多都很玄学百度了下，很多说的很玄学，其实很简单。 2、不同版本JDK同样的安装，只是环境变量配置的时候，修改JAVA_HOME为对应的JDK的安装目录即可，当然还有更简单的切换方法，比如配置AVA_HOME7和AVA_HOME8，然后用AVA_HOME=%AVA_HOME7%这样的方式，告诉你，亲测，没什么软用 3、不同版本tomcat环境变量替换即可 三、eclipse的tomcat插件配置找到eclipse配置下的tomcat，然后选7x，选择tomcat的安装路径，然后下面的apache-tomcat-7.0.41\conf\Catalina\localhost将xml文件加进来，因为公司项目已经配好，具体怎么搞看自己 注意：当项目死活启动说缺少相应jar包，排除其他问题，那么可以考虑，是不是tomcat-advanced这里没有依赖给引进来。&lt;/br&gt;我就是因为这个点，最后项目启动了半天，还是有经验的同事告诉我才解决这个问题。eclipse真是个神奇的东西，各种错误都某明奇妙，走IDEA了准备。 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>eclipse</category>
      </categories>
      <tags>
        <tag>eclipse</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC 操作数据库]]></title>
    <url>%2F2019%2F04%2F13%2FJDBC%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(ru)中，欢迎有兴趣的童鞋们关注。 十、JDBC操作数据库1、JDBC概念JDBC是实现java程序对各种数据库的访问，是一组类和接口，位于java.sql与javax.sql包 2、通过JDBC连接数据库（不优化前）12345678910111213141516171819202122//1、加载驱动 Class.forName("com.mysql.jdbc.Driver"); //2、建立连接 String url="jdbc:mysql://localhost:3306/myschool"; String user ="root" ; String password = "aaaaa123"; con= DriverManager.getConnection(url, user, password); //创建sql语句 String sql ="SELECT studentno,studentName FROM student"; //创建对象 pstm =con.prepareStatement(sql); //执行sql语句 rs=pstm.executeQuery(); //处理结果 System.out.println("编号：\t姓名："); while(rs.next()) &#123; System.out.println(rs.getInt("studentno")+"\t"+rs.getString("studentName")); &#125; //关闭资源 rs.close(); pstm.close(); con.close(); Class.forName() 后加载 反射，事先不知道加载哪个类，运行时进行加载（桥接） 而Student stu =new Student() 先加载类 3、使用JDBC操作数据库（增删改查）（不优化前）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//增加数据import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Timestamp;public class Test3 &#123; public static void main(String[] args) &#123; ResultSet rs =null; PreparedStatement pstm=null; Connection con =null; //1、加载驱动 try &#123; Class.forName("com.mysql.jdbc.Driver"); //2、建立连接 String url="jdbc:mysql://localhost:3306/kgcnews"; String user ="root" ; String password = "aaaaa123"; con= DriverManager.getConnection(url, user, password); //创建sql语句 String sql ="INSERT INTO news_category (NAME,createDate) VALUES (?,?)"; //创建对象 pstm =con.prepareStatement(sql); //给占位符赋值 pstm.setString(1, "哈哈"); pstm.setTimestamp(2, new Timestamp(10)); //执行sql语句 int i=pstm.executeUpdate(); //处理结果 if(i&gt;=1) &#123; System.out.println("增加成功"); &#125;else &#123; System.out.println("未增加"); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; if(null !=pstm) &#123; try &#123; pstm.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(null !=con) &#123; try &#123; con.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 增删改操作类似，只是替换sql语句即可 4、JDBC封装和三层架构1、JDBC的三层架构 表示层 实际开发中的网页或者我们这里的test包，相当于现实中单客户 逻辑业务层 处理逻辑业务，我们这里的service包，相当于现实中的经理 数据处理层 底层处理数据层，这里的dao以及entity包，相当于员工 为什么要进行JDBC封装？主要是因为业务代码和数据访问代码的耦合。这就导致了可读性差、不利于后期修改和维护、不利于代码复用。所以我们采用面向接口编程，可以降低代码之间的耦合性。 2、项目包 3、具体实现步骤 先建entity包，这个包中放实体类，这里我们放pet类,，将数据库表中的字段作为pet的属性，并为其添加set和get方法，以及相应的有参和无参构造方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package entity;public class Pet &#123; private int id; private String name; private int health; private int love; private String strain; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getHealth() &#123; return health; &#125; public void setHealth(int health) &#123; this.health = health; &#125; public int getLove() &#123; return love; &#125; public void setLove(int love) &#123; this.love = love; &#125; public String getStrain() &#123; return strain; &#125; public void setStrain(String strain) &#123; this.strain = strain; &#125; public Pet() &#123; super(); &#125; public Pet(int id, String name, int health, int love, String strain) &#123; super(); this.id = id; this.name = name; this.health = health; this.love = love; this.strain = strain; &#125; &#125; 建dao包，写BaseDao基类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160package dao;/** * 基类 * 1.创建连接对象 * 2.关闭资源 * 3.增加，删除，修改操作 * 4.查询方法 * @author Administrator * */import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.Properties;public class BaseDao &#123; //静态变量可以保证类被加载的时候已经为连接参数赋值，并且只会执行一次 private static String driver =null; private static String url =null; private static String user =null; private static String password =null; /* * 静态代码块 */ static &#123; Properties proper = new Properties(); InputStream is = BaseDao.class.getClassLoader().getResourceAsStream("database.properties"); try &#123; proper.load(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(null!=is) &#123; is.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //为静态代码块赋值 driver=proper.getProperty("driver"); url=proper.getProperty("url"); user=proper.getProperty("user"); password=proper.getProperty("password"); &#125; protected Connection conn =null; protected PreparedStatement pstmt =null; protected ResultSet rs =null; /** * 获取连接对象 * @return */ public Connection getConnection() &#123; try &#123; //1、加载驱动类 Class.forName(driver); //2、创建连接对象 conn=DriverManager.getConnection(url,user,password); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return conn; &#125; /** * 关闭资源 * @param conn * @param pstmt * @param rs */ public void closeAll(Connection conn,PreparedStatement pstmt,ResultSet rs) &#123; try &#123; if(null!=conn) &#123; conn.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; if(null!=pstmt) &#123; pstmt.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; if(null!=rs) &#123; rs.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 增删改操作 * @param sql * @param params * @return */ public int exxcutUpdate(String sql,Object[] params) &#123; this.getConnection(); int result=-1; try &#123; //3、创建prepareStatement对象 pstmt=conn.prepareStatement(sql); //4、为占位符赋值 if(null!=params) &#123; for (int i = 0; i &lt; params.length; i++) &#123; pstmt.setObject(i+1, params[i]); &#125; &#125; //5.调用方法：执行sql语句 result=pstmt.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; this.closeAll(conn, pstmt, rs); &#125; return result; &#125; /** * 查询方法 * @param sql * @param params * @return */ public ResultSet executQuery(String sql,Object... params) &#123; this.getConnection(); try &#123; //3、创建prepareStatement对象 pstmt=conn.prepareStatement(sql); //4、为占位符赋值 if(null!=params) &#123; for (int i = 0; i &lt; params.length; i++) &#123; pstmt.setObject(i+1, params[i]); &#125; &#125; //5.调用方法：执行sql语句 rs=pstmt.executeQuery(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return rs; &#125;&#125; 写数据处理层的接口 123456789101112131415161718192021222324252627282930313233package dao;import java.util.List;import entity.Pet;/** * 接口 * @author Administrator * */public interface PetDao &#123; /** * 查询所有宠物列表 * @return */ public List&lt;Pet&gt; findaLLPet(); /** * 根据编号查询宠物列表 * @param id * @return */ public Pet findAllPetById(int id); /** * 新增宠物 * @param pet * @return */ public int addPet(Pet pet);&#125; 写数据处理层实现类PetDaoImpl，在dao包下面建子包impl 注意建子包要父包名点子包名，然后设置包的显示顺序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package dao.impl;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;import dao.BaseDao;import dao.PetDao;import entity.Pet;/** * 实现类 * @author Administrator * */public class PetDaoImpl extends BaseDao implements PetDao&#123; /** * 查询所有宠物 */ @Override public List&lt;Pet&gt; findaLLPet() &#123; List&lt;Pet&gt; list =null; try &#123; String sql = "SELECT id,NAME,health,love,strain FROM pet"; Object[] params=null; //调用方法 rs=this.executQuery(sql, params); if(null!=rs) &#123; list = new ArrayList&lt;&gt;(); while(rs.next()) &#123; Pet pet =new Pet(); pet.setId(rs.getInt("id")); pet.setName(rs.getString("name")); pet.setHealth(rs.getInt("health")); pet.setLove(rs.getInt("love")); pet.setStrain(rs.getString("strain")); list.add(pet); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; this.closeAll(conn, pstmt, rs); &#125; return list; &#125; /** * 根据id查宠物信息 */ @Override public Pet findAllPetById(int id) &#123; Pet pet=null; try &#123; String sql = "SELECT id,NAME,health,love,strain FROM pet WHERE id=?"; Object[] params= &#123;id&#125;; //调用方法 rs=this.executQuery(sql, params); if(null!=rs) &#123; while(rs.next()) &#123; pet =new Pet(); pet.setId(rs.getInt("id")); pet.setName(rs.getString("name")); pet.setHealth(rs.getInt("health")); pet.setLove(rs.getInt("love")); pet.setStrain(rs.getString("strain")); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; this.closeAll(conn, pstmt, rs); &#125; return pet; &#125; @Override public int addPet(Pet pet) &#123; String sql ="INSERT INTO pet (id,NAME,health,love,strain) VALUES (DEFAULT,?,?,?,?)"; Object[] params= &#123;pet.getName(),pet.getHealth(),pet.getLove(),pet.getStrain()&#125;; int result =-1; try &#123; result=this.exxcutUpdate(sql, params); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; &#125; 建service包，写业务处理层的接口PetService 12345678910111213141516171819package service;import java.util.List;import entity.Pet;/** * 业务逻辑类 * @author Administrator * */public interface PetService &#123; //查询所有宠物信息 public List&lt;Pet&gt; getAllPet(); //查询指定id宠物信息 public Pet getPetById(int id); //注册 public boolean register(Pet pet);&#125; 写业务处理层的实现类PetServiceImpl，在service包下再建一个包叫impl 1234567891011121314151617181920212223242526272829303132333435363738package service.impl;import java.util.List;import dao.PetDao;import dao.impl.PetDaoImpl;import entity.Pet;import service.PetService;/** * 业务逻辑类 实现类 * @author Administrator * */public class PetServiceImpl implements PetService&#123; PetDao petDao = new PetDaoImpl(); //查询所有宠物信息 @Override public List&lt;Pet&gt; getAllPet() &#123; return petDao.findaLLPet(); &#125; //查询指定id宠物信息 @Override public Pet getPetById(int id) &#123; return petDao.findAllPetById(id); &#125; //注册（增加宠物） @Override public boolean register(Pet pet) &#123; int result = petDao.addPet(pet); if(result==-1) &#123; return false; &#125;else &#123; return true; &#125; &#125;&#125; 建表示层测试包test 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package test;import java.util.Scanner;import entity.Pet;import service.PetService;import service.impl.PetServiceImpl;/** * 表示层 * 测试类 * @author Administrator * */public class Test &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); PetService petService= new PetServiceImpl(); Pet pet =null; /*//测试查询所有宠物信息 List&lt;Pet&gt; list =petService.getAllPet(); System.out.println("编号 \t姓名\t健康值\t亲密度\t品种"); for (int i = 0; i &lt; list.size(); i++) &#123; pet=list.get(i); System.out.println(pet.getId()+"\t"+pet.getName()+"\t"+pet.getHealth()+"\t"+pet.getLove()+"\t"+pet.getStrain()); &#125; */ /*//测试查询指定id宠物信息 System.out.print("请输入您要查找的宠物的id："); int id =input.nextInt(); pet=petService.getPetById(id); System.out.println("编号 \t姓名\t健康值\t亲密度\t品种"); System.out.println(pet.getId()+"\t"+pet.getName()+"\t"+pet.getHealth()+"\t"+pet.getLove()+"\t"+pet.getStrain());*/ //注册测试 pet = new Pet(); System.out.print("请输入姓名："); pet.setName(input.next()); System.out.print("请输入健康值："); pet.setHealth(input.nextInt()); System.out.print("请输入亲密度："); pet.setLove(input.nextInt()); System.out.print("请输入亲品种："); pet.setStrain(input.next()); boolean isSuccess=petService.register(pet); if(isSuccess) &#123; System.out.println("注册成功1"); &#125;else &#123; System.out.println("注册失败1"); &#125; &#125;&#125; 4、将相关数据写入配置文件123456789101112131415161718192021222324252627282930313233343536public class BaseDao &#123; //静态变量可以保证类被加载的时候已经为连接参数赋值，并且只会执行一次 private static String driver =null; private static String url =null; private static String user =null; private static String password =null; /* * 静态代码块 */ static &#123; Properties proper = new Properties(); InputStream is = BaseDao.class.getClassLoader().getResourceAsStream(&quot;database.properties&quot;); try &#123; proper.load(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(null!=is) &#123; is.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //为静态代码块赋值 driver=proper.getProperty(&quot;driver&quot;); url=proper.getProperty(&quot;url&quot;); user=proper.getProperty(&quot;user&quot;); password=proper.getProperty(&quot;password&quot;); &#125; &#125; 5、配置文件信息项目右键new一个resouces folder，然后new一个file，名字以.properties作为后缀名，配置文件是键值对形式存在，名字自己宿便取 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/epet?useUnicade=true&amp;characterEncoding=UTF-8user=rootpassword=aaaaa123 6、用到的数据库信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*SQLyog Ultimate v11.24 (32 bit)MySQL - 5.1.47-community : Database - epet------*//*!40101 SET NAMES utf8 */;/*!40101 SET SQL_MODE=''*/;/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;CREATE DATABASE /*!32312 IF NOT EXISTS*/`epet` /*!40100 DEFAULT CHARACTER SET utf8 */;USE `epet`;/*Table structure for table `master` */DROP TABLE IF EXISTS `master`;CREATE TABLE `master` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '序号', `name` varchar(12) DEFAULT NULL COMMENT '姓名', `password` varchar(20) DEFAULT NULL COMMENT '密码', `money` int(11) DEFAULT NULL COMMENT '元宝数', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;/*Data for the table `master` */insert into `master`(`id`,`name`,`password`,`money`) values (1,'jack','1234',2000),(2,'rose','1234',3000),(3,'smith','1234',4000);/*Table structure for table `pet` */DROP TABLE IF EXISTS `pet`;CREATE TABLE `pet` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '序号', `name` varchar(12) DEFAULT NULL COMMENT '昵称', `health` int(11) DEFAULT NULL COMMENT '健康值', `love` int(11) DEFAULT NULL COMMENT '亲密度', `strain` varchar(20) DEFAULT NULL COMMENT '品种', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;/*Data for the table `pet` */insert into `pet`(`id`,`name`,`health`,`love`,`strain`) values (1,'欧欧',80,15,'雪瑞纳'),(5,'亚亚',100,0,'拉布拉多'),(9,'美美',90,66,'雪瑞纳'),(10,'菲菲',90,50,'拉布拉多');/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */; 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE 基础面试题（精简版）]]></title>
    <url>%2F2019%2F04%2F13%2FJavaSE%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E7%B2%BE%E7%AE%80%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(ru)中，欢迎有兴趣的童鞋们关注。 一、java的跨平台原理1、什么是平台 把CPU处理器与操作系统的整体叫平台 2、java跨平台原理 java虚拟机JVM将java文件编译成字节码文件，也就是.class文件，然后运行到不同的平台，对应的系统会将字节码文件转换成对应平台的对应机器码，产生可执行性文件 二、冒泡排序1、概念 N个数字来比较，两两比较小靠前，外层循环N-1，内层循环N-1-i； 2、手写代码 12345678910111213141516171819public class MrpSort&#123; public static void main(String[] args)&#123; int[] arr = &#123;1,4,9,10,45,12,2&#125;; for(int i=0;i&lt;arr.length-1;i++)&#123; for(int j=0;j&lt;arr.length-1-i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; //交换 int temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125; &#125; //遍历数组 for(int a:arr)&#123; System.out.println(a); &#125; &#125;&#125; 三、比较排序1、概念 外层循环, 决定比较的轮次, 决定每轮需要确定的元素的下标，内层循环, 决定每轮比较时, 用于和i进行比较的下标的起止（打擂台的方式） 2、手写代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.array.sort;/** * 比较排序 * @author Administrator * */public class Comparison &#123; public static void main(String[] args) &#123; //声明数组中 int[] arr = new int[20]; //遍历数组, 随机生成元素内容 for (int i = 0; i &lt; arr.length; i++) &#123; //生成1~100的随机数 arr[i] = (int) (Math.random()*100 + 1); &#125; //输出初始内容 System.out.println("原数组内容如下:"); for (int i = 0; i &lt; arr.length; i++) &#123; //输出元素内容 System.out.print(arr[i] + "\t"); //判断是否换行 if(i%5 == 4) &#123; //(i+1)%5==0 System.out.println(); &#125; &#125; System.out.println("==========================================="); /* 升序排列 */ //外层循环, 决定比较的轮次, 决定每轮需要确定的元素的下标 for (int i = 0; i &lt; arr.length-1; i++) &#123; //内层循环, 决定每轮比较时, 用于和i进行比较的下标的起止 for (int j = i+1; j &lt; arr.length; j++) &#123; //比较, 将较小的元素交换到下标i中 if(arr[i] &gt; arr[j]) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; &#125; //输出结果 System.out.println("排序后的数组内容如下:"); for (int i = 0; i &lt; arr.length; i++) &#123; //输出元素内容 System.out.print(arr[i] + "\t"); //判断是否换行 if(i%5 == 4) &#123; //(i+1)%5==0 System.out.println(); &#125; &#125; System.out.println("==========================================="); &#125;&#125; 四、插入排序1、概念 将数组划分成两个部分, 已经排序的部分, 和没有排序的部分，依次从未排序的数组中取出元素, 按照插入算法, 插入已经排序的数组部分，外层循环, 确定每次需要插入的元素的下标，内存循环, 遍历已经排序的数组的所有元素, 与需要插入的元素比较, 确定插入的具体效果 2、手写代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.array.sort;/** * 插入排序 * 基于插入算法的排序 * @author Administrator * */public class Insertion &#123; public static void main(String[] args) &#123; //声明数组中 int[] arr = new int[20]; //遍历数组, 随机生成元素内容 for (int i = 0; i &lt; arr.length; i++) &#123; //生成1~100的随机数 arr[i] = (int) (Math.random()*100 + 1); &#125; //输出初始内容 System.out.println("原数组内容如下:"); for (int i = 0; i &lt; arr.length; i++) &#123; //输出元素内容 System.out.print(arr[i] + "\t"); //判断是否换行 if(i%5 == 4) &#123; //(i+1)%5==0 System.out.println(); &#125; &#125; System.out.println("==========================================="); /* 插入排序, 升序 */ /* * 将数组划分成两个部分, 已经排序的部分, 和没有排序的部分 * 依次从未排序的数组中取出元素, 按照插入算法, 插入已经排序的数组部分 */ //外层循环, 确定每次需要插入的元素的下标 for (int i = 1; i &lt; arr.length; i++) &#123; //内存循环, 遍历已经排序的数组的所有元素, 与需要插入的元素比较, 确定插入的具体效果 for (int j = 0; j &lt; i; j++) &#123; //判断, i下标的元素比j下标的元素小时, 交换 if(arr[i] &lt; arr[j]) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; &#125; //输出结果 System.out.println("排序后的数组内容如下:"); for (int i = 0; i &lt; arr.length; i++) &#123; //输出元素内容 System.out.print(arr[i] + "\t"); //判断是否换行 if(i%5 == 4) &#123; //(i+1)%5==0 System.out.println(); &#125; &#125; System.out.println("==========================================="); &#125;&#125; 五、for、while、do-while区别分四个方面：总的说、结构、特点、适用条件 1、总的来说，都是用来循坏的控制语句 2、do-while在while的括号后面加分号，而while循环的括号后不加分号 3、for和while是先进行循环条件判断，再进入循环体，而do-while是先进入循环体，再执行循环条件，所以do-while至少出现一次。 4、适用条件：for适用于循环次数确定的情况 六、continue、break、return的异同相同点 1、三个关键字都是用来终止循环的关键字，用了关键字会跳出相应的循环 不同点 2、continue是跳出当前循环进入下一个循环，break是退出循环，return是跳出方法，有返回值的话会返回要返回的值 七、==与equals方法的异同相同： 都是用来进行比较操作 不同： 1、==是算术运算符，而equals是Object类的一个方法 2、基本数据类型的比较：只能用==运算符 3、非String类的引用数据类型，如果没有重写是Object类的equals方法，那么两者比较的都是对象的地址 4、String和重写了equals方法的引用数据类型，==比较的还是地址，equals比较的就是值是否相等了。 八、谈一谈封装1、封装的作用 封装是面向对象三大特性之一，用封装有利于保护数据的安全性 2、封装的实现步骤 私有化属性private 关于封装时的属性命名:首字母和第二个字母都不能大写 get/set方法为属性提供一个公开访问的方法 需要对相关属性进行条件设置时，需要在set方法中进行设置 3、javabean 将字段封装成对象 九、谈一谈继承1、继承的作用 继承就是子类继承父类的特征和行为，是用extends关键字，使用继承可以减少代码冗余，提高类和类之间的耦合性 2、子类能从父类继承到啥 广义的说，子类能继承到父类的除构造方法之外的所有，但是只有父类的非私有子类才可以应用 3、java支持的是单根继承，但是可以多重继承 十、谈一谈多态1、多态的作用 多态是同一个行为具有多个不同表现形式或形态的能力，消除类型之间的耦合性，增强代码的可替换性和可扩展性 2、实现多态的前提 继承和实现 方法重写（向上、向下转型） 3、使用方式 父类作为方法的形参传递 父类作为方法返回值 十一、方法重载与方法重写的异同相同点： 1、方法名相同 2、两者均提高了适用范围和灵活性 不同点 1、出现的位置 重载出现在本类中，重写出现在子类 2、参照的目标方法 重载参照的是同类的方法名相同的方法，重写参照的是父类的方法 3、访问修饰符 重载和访问修饰符无关、重写不能严于父类（比如父类用的是protected，那么重写的方法的访问修饰符只能是protected活着public） 4、返回值类型 重载无关、重写必须相同 5、参数列表类型或者数量 重载不同，重写可完全一致或者是其子类类型 6、异常声明 重写不能抛出比父类更多的异常，只能抛出和父类类型一样或是该异常的子类异常 十二、抽象类与接口的异同相同点： 1、都不能被实例化，属于抽象层面 2、都可以含有抽象方法 不同点： 1、关键字不同 抽象类：abstract，接口：interface 2、属性要求不同 接口：public final static，初始值必须赋值，常量必须大写 3、方法 抽象类可以有非抽象方法，接口方法只能是public abstract 4、构造方法 抽象类有构造方法，接口无 5、使用 抽象类单根继承，接口多继承多实现 十三、final、finally、finalize的区别1、final 可修饰类、方法、属性、局部变量 修饰类不能被继承，方法不能被重写，属性时一个常量在申明的时候必须赋值（因为全局变量会有默认值），局部变量可先申明再赋值） 2、finally 是异常处理时候的一个关键字，在try、catch和finally一起使用时，不管怎样最后都会执行，除非调用System.exit(0)才不会执行 3、finalize 垃圾回收的时候使用 十四、在java中如何最有效率的将数值8变成2使用位运算完成 左移&lt;&lt; 右移&gt;&gt; 按位与&amp; 按位或| 按位亦或^ 按位非~ 将数据转换成2进制后再处理. 32位2进制数 4&amp;5=4 4|5=5 100 101 100 1先将8转换为二进制：1000，再将1000右移两位变成10就是2，即8&gt;&gt;2 十五、this与super的异同相同： 都是用来调用属性和方法 不同： 1、调用 的类不同，this调用的是当前类，supper调用的是父类 2、this可以代表当前对象，supper无法代表父类 十六、谈一谈java的异常处理机制1、什么是程序错误 error：程序错误，如内存溢出 逻辑错误：和最后想要的的结果不同 Exception：程序异常 2、try、catch、finally try是核心，代表对可能出现异常的代码块进行异常捕捉，catch代表抓取异常，finally不管怎样都会执行（除了一个） 3、有返回值return时 返回值是基本数据类型时： 最后返回的不会是finally的值 返回值是对象时： 最后返回的是finally的值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.param;public class Test &#123; public static void main(String[] args) &#123; /*int n1 = 5, n2 = 10; cal(n1, n2); System.out.println(n1+","+n2); User user = new User("ÕÅÈý", 10); cal(user); System.out.println(user.getAge());*/ /*int n = 10; System.out.println("n:" + n); System.out.println("result:" + cal(n));;*/ User user = new User("º«Ã·Ã·", 20); System.out.println("result:" + cal(user)); &#125; private static User cal(User u) &#123; try &#123; u.setAge(100); System.out.println("try:" + u); return u; &#125; catch (Exception e) &#123; u.setAge(200); System.out.println("catch:" + u); return u; &#125; finally &#123; u.setAge(1000); System.out.println("finally:" + u); &#125; &#125; private static int cal(int a) &#123; try &#123; a *= 10; System.out.println("try:" + a); int b = 1 / 0; return a; &#125; catch (Exception e) &#123; a += 100; System.out.println("catch:" + a); return a; &#125; finally &#123; a *= 1000; System.out.println("finally:" + a); &#125; &#125; private static void cal(int a, int b) &#123; // System.out.println(a+b); a = 20; b = 50; &#125; /*private static void cal(User u) &#123; // u.setAge(50); u = new User("ÀîËÄ", 60); &#125;*/ &#125; 4、throws和throw throws：抛出异常，避免冗余和重复工作 throws：申明异常，梳理结构 十七、谈一谈java的常见特性1、面向对象 2、异常处理 3、垃圾回收 4、多线程 十八、ArrayList与LinkedList的异同同： 都是属于List接口的具体实现类，都实现了List中常用方法，并且都是有序不唯一的集合 不同： 1、各自的特点和使用场景 ArrayList遍历效率高，对于只需要进行查询操作的集合，用ArrayList集合储存数据更好，因为ArrayList是连续的内存空间结构，所以查的快，但是插入删除效率低； LinkedList插入和删除效率高，查询效率低，因为LinkedList是链式储存，每一个元素都含有三个元素，手拉手示的，插入块 十九、ArrayList与Vector的区别1、线程安全 Vector是同步的线程安全的，ArrayList线程不安全 2、执行效率 线程不安全的执行效率高 3、元素超过初始大小时 当Vector或ArrayList中的元素超过它的初始大小时,Vector会将它的容量翻倍,而ArrayList只增加50%的大小，这样,ArrayList就有利于节约内存空间。 二十、HashMap与HashTable的区别1、线程安全 HashMap线程不安全，HashTable线程安全 2、执行效率 线程不安全的执行效率高 二十一、String、StringBuffer、StringBiulder的异同同： 都是用来存储字符串 不同： 1、从字符串是否可变 String是不可变字符串，后两者均是可变 的 2、从线程安全角度 StringBiulder是安全的，其他都不安全 3、执行效率 StringBiulder比StringBuffer执行效率低 二十二、谈一谈反射1、是什么 反射是一种半动态的代码加载和运行机制，在jvm第一次加载字节码(.class)文件时, 如发现了未知的未经编译的信息, 则会将未知信息和字节码文件返还给编译器,由编译器对未知信息进行二次编译,然后再交由jvm翻译运行 2、比正常的编译在JVM和编译器间多了一个来回 3、获取class类对象的方式： ​ 类名.class ​ 对象名.getClass ​ class.forName()字符串 二十三、谈一谈序列化1、作用 解决互联网传输时，20%平均损失率问题，保证数据完整性 2、如何实现序列化 在实体类中实现serializable ，使用ObjectOutputStream 二十四、线程的生命周期1、新生：new 2、可运行（就绪）：start线程具有了抢夺资源的能力 3、运行：不稳定的状态 4、阻塞：线城失去了抢夺资源的能力，sleep 5、死亡： 自然死亡：线程的run方法执行完 非自然死亡：容易死锁 二十五、线程的调度1、优先级：setPriority 2、sleep（毫秒）： 阻塞的是：调用该方法的线程 能否恢复可运行：能 3、join（） 阻塞的是：别的线程,让本线程先执行 能否恢复可运行：能 4、yield(),礼让 阻塞的是：调用该方法的线程（时间极短，继续枪占资源） 能否恢复可运行：能 5、wait（) 阻塞的是：自己 能否恢复可运行：不能，必须调用notify，两者通常在两个线程之间调用 二十六、程序并发的数据安全(线程锁/线程安全)1、多个用户访问同一数据时，会导致数据出现问题 2、线程同步方式 Synchronized同步方法 Synchronized同步代码块 volatie关键字，申明域变量 创建重入锁对象重入锁对象的操作方法: lock(), unlock() 使用ThreadLocal声明局部变量 二十七、线程死锁 线程在执行过程中非正常死亡, 有几率导致死锁 2个线程在使用自己的资源的同时, 又去调用对方正在使用的资源 二十八、TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，必须要求双方建立连接后才开始通信。 点对点传输，安全 服务器端使用ServerSocket，使用其中的accept()方法监听客户端的请求，并使用Socket的getInputStream()和getOutputStream()方法，获取服务器端的输出流和输入流。 服务器端使用Socket，并使用Socket的getInputStream()和getOutputStream()方法，获取客户端的输出流和输入流。 最后将相应的流和socket关闭即可 二十九、socket基于TCP协议的数据中转的对象，客户端/服务器 位于java.net包，被称为套接字，是网络通信连接的两个端点，是网络驱动层提供给应用程序的一个接口或者一种机制。 三十、XML的常见解析方式1、DOM解析 基于XML的树结构来完成解析，通过获取各个节点的元素对象，来获取XML内容； 创建解析器工厂对象，获得解析器对象，通过解析器对象对xml文件解析获得Document对象，Document对象的方法来获取XML内容。 2、jDOM解析 JDOM是Java和DOM的结合体。利用纯java技术对XML文档实现解析 3、SAX 基于事件解析，占用资源小、内存消耗小 4、DOM4j 是一个开源的库，特点是其中使用大量的接口，使用前需要导入dom4j的jar包。获得SAXReader对象，使用read()方法获得Document对象，通过Document对象获得根节点元素，来获取XML的内容。 三十一、单例-懒汉12345678910111213141516171819202122232425262728293031package com.singleton.lazy;/** * 单例: 通过特殊的编码格式, * 保证该类的实例在一次程序执行过程中只有1个 * 懒汉式 * @author Administrator * */public class Lazy &#123; /* 1. 声明私有的静态属性, 类型为本类类型 */ private static Lazy lazy; /* 2. 隐藏构造方法 */ private Lazy() &#123; &#125; /* 3. 提供一个公共的获取类实例的静态方法 注: 此方法可以选择同步或不同步. */ public synchronized static Lazy getInstance() &#123; /* 4. 判断, lazy属性是否为null */ if(lazy == null) &#123; lazy = new Lazy(); &#125; return lazy; &#125;&#125; 三十二、单例-饿汉1234567891011121314151617181920212223242526package com.singleton.hanger;/** * 单例 * 饿汉式 * @author Administrator * */public class Hanger &#123; /* 1.声明私有的静态属性, 类型为本类类型, * 并在声明的同时实例化 */ private static Hanger hanger = new Hanger(); /* 2. 隐藏构造方法 */ private Hanger() &#123; &#125; /* 3. 提供一个公共的获取类实例的静态方法 注: 此方法可以选择同步或不同步. */ public static Hanger getInstance() &#123; return hanger; &#125;&#125; 三十三、单例-双重锁123456789101112131415161718192021222324252627282930313233343536package com.singleton.dblock;/** * 单例 * 双重锁式 * @author Administrator * */public class DoubleLock &#123; /* 1. 声明私有的静态属性, 类型为本类类型 * 并添加volatile关键字, 设置成域变量 * */ private volatile static DoubleLock doubleLock; /* 2. 隐藏构造方法 */ private DoubleLock() &#123; &#125; /* 3. 提供一个公共的获取类实例的静态方法 */ public static DoubleLock getInstance() &#123; /* 4. 第一次判断 */ if(doubleLock == null) &#123; /* 5. 同步代码块, 并在代码块中进行第二次判断 */ synchronized (DoubleLock.class) &#123; if (doubleLock == null) &#123; doubleLock = new DoubleLock(); &#125; &#125; &#125; return doubleLock; &#125;&#125; 三十四、写出5种java常见的设计模式(常规共23种)1、单例模式。 单例模式对实例个数的控制并节约系统资源. 在它的核心结构中只包含一个被称为单例类的特殊类,通过构造函数私有化和静态块以及提供对外访问的接口来实现. 饿汉模式:单例实例在类的加载中就被创建.不需要判断,安全. private static MySingleton2 mySingleton = new MySingleton2(); 饿汉式 直接创建了对象 懒汉模式:单例实例在第一次使用时被创建.需要if判断,不安全. private static MySingleton2 mySingleton=null 懒汉式 静态块中会进行判断 2、工厂模式 工厂模式主要是为创建对象提供了接口。 应用场景如下： a、 在编码时不能预见需要创建哪种类的实例。 b、 系统不应依赖于产品类实例如何被创建、组合和表达的细节 3、观察者模式(一个学生对应多个老师,一个老师对应多个学生). 定义了对象间一对多的依赖关系，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 应用场景如下： a、对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变。 b、对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。 4、迭代器模式。 迭代器模式提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。 应用场景如下： 当你需要访问一个聚集对象，而且不管这些对象是什么都需要遍历的时候，就应该考虑用迭代器模式。其实stl容器就是很好的迭代器模式的例子。 5、代理模式 为其他对象提供代理来控制对该对象的访问. 应用场景如下: ngnix的反向代理(隐藏服务器)运用的就是代理模式. 三十五、++和—++和—都是java内部的算术运算符，但是在和其他运算符一起参与运算时，++放在前和放在后有顺序问题 1、a++：参与运算的是没有++之前的数字 ++a：参与运算的是++之前的数字 Int a = 1; 实际改变的值 2 3 4 ​ Int b = a++ ++a a++; 参与运算的值 1 3 3 经典面试题 12345678int a = 0;for(int i = 0; i &lt; 6; i++)&#123;实际：1 a = a++;运算：0 System.out.print(a); &#125;输出的是6个0，因为每一次参与运算的a都是0 三十六、&amp;和&amp;&amp;&amp;&amp;是短路与，两个条件，如果前面那个为false，那么直接整个结果就是false，不会走到第二个 &amp;会走到第二个再判断 经典面试案例 123456789int a1 = 7, a2 = 7, b1 = 8, b2 = 8;boolean flag1 = a1++ &gt; b1-- &amp; a1++ &gt; b1++;boolean flag2 = a2++ &gt; b2-- &amp;&amp; a2++ &gt; b2++;a1, b1, a2, b2和flag1和flag2的值 结果是：a1=9，b1=8，flag1=falsea2=8，b2=7，flag1=false 三十七、标识符、变量1、字母、下划线、数字、$（64个） 2、数字不能放开头 3、不能使用关键字 4、不能使用保留字goto、const 5、驼峰命名 6、见名知义 123455. long n = 324174641657646;——错误，要加Lfloat f = 5 / 2;int n = ‘a’;byte b = 127;b++; b = b+ 1; 三十八、APIapplication programming interface​ 应用程序编写接口 三十九、java中48个关键字，和2个保留字关键字： abstract assert boolean break byte casecatch char class continue default dodouble else enum extends final finallyfloat for if implements import intinterface instanceof long native new packageprivate protected public return short staticstrictfp super switch synchronized this throwthrows transient try void volatile while 保留字： goto const 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>Java面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[版本控制工具之 SVN]]></title>
    <url>%2F2019%2F04%2F13%2F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E4%B9%8BSVN%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(ru)中，欢迎有兴趣的童鞋们关注。 前言很久没玩QQ，登录记不住密码了，点开问题，以前设置的问题是：你的梦想是什么？我输入：金钱、爱情、家庭、房子、车子、美女统统都错，究竟以前的梦想是什么？走着走着，或许就已经忘却最初的梦想了！可还是要坚持自己所爱，勇往直前！漫威的《惊奇队长》好想看，可是那个人已走远了，不想去电影院！爱情真是让人可望而不可即的东西。 1、从个人开发到团队协作团队开发必须借助版本控制工具进行开发才能更高效的开发 2、版本控制工具的功能 3、版本控制简介 4、SVN 的工作机制 5、服务器端环境搭建步骤 6、命令行客户端 6.5 查看服务器端文件内容123[root@rich harry]# svn list svn://192.168.70.140/pro_oagood.loghello.txt 6.6 更新操作 7、冲突xxx.r[大版本号]文件：发生冲突时服务器端文件内容 8、Eclipse 的 SVN 插件转换工程类型 9.8 切换分支项目→右键→Team→Swith… 9.9 合并分支工程→右键→Team→Merge… 10、SVN 权限管理 11 查看历史记录 12、TortoiseSVN 13、特别声明感谢尚硅谷封捷老师的精彩视频，此笔记来源于封捷老师，做了部分整理和修改，如有侵权，请告知删除，不可转载！ 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>SVN</category>
      </categories>
      <tags>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将 oracle11 安装到虚拟机并在本机进行远程操控 oracle 数据库（超详细步骤）]]></title>
    <url>%2F2019%2F04%2F13%2F%E5%B0%86oracle11%E5%AE%89%E8%A3%85%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B9%B6%E5%9C%A8%E6%9C%AC%E6%9C%BA%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E6%93%8D%E6%8E%A7oracle%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(ru)中，欢迎有兴趣的童鞋们关注。 文末附所有要用到的资源下载链接 一、背景当我们在安装oracle数据库第一次安装失败时，卸载是一件超级令人头大的事情，而且很多时候根本卸载不干净，而且oracle数据库很大，当我们本机打开的服务过多，会影响机器的运行！这样就急需一个解决办法——那就是将oracle11安装到虚拟机上，并在本机进行远程操控oracle数据库。这样一来，数据库服务将通过虚拟机提供！ 二、什么是虚拟机虚拟机（Virtual Machine）指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。虚拟系统通过生成现有操作系统的全新虚拟镜像，它具有真实windows系统完全一样的功能，进入虚拟系统后，所有操作都是在这个全新的独立的虚拟系统里面进行，可以独立安装运行软件，保存数据，拥有自己的独立桌面，不会对真正的系统产生任何影响 ，而且具有能够在现有系统与虚拟镜像之间灵活切换的一类操作系统。虚拟系统和传统的虚拟机（Parallels Desktop ，Vmware，VirtualBox，Virtual pc）不同在于：虚拟系统不会降低电脑的性能，启动虚拟系统不需要像启动windows系统那样耗费时间，运行程序更加方便快捷；虚拟系统只能模拟和现有操作系统相同的环境，而虚拟机则可以模拟出其他种类的操作系统；而且虚拟机需要模拟底层的硬件指令，所以在应用程序运行速度上比虚拟系统慢得多。 其实说白了就是在计算机中再装了一台虚拟的计算机！ 三、如何安装虚拟机到本机说明：这里我用的是VMware12版本的虚拟机，oracle用的是oracle111、VMware12下载地址链接：https://pan.baidu.com/s/1K0S_558FpZU6OVWQupxe4w提取码：tuu42、VMware12下载步骤https://mp.weixin.qq.com/s/piIadMK80A9iRlCmcvyXaA 四、在虚拟机上安装操作系统有了虚拟机，相当于你的电脑上新加了一台虚拟的计算机，需要安装操作系统，这里我安装的是Win7的版本（建议和我一致的操作系统，因为不同的操作系统可能会导致版本兼容性问题）1、win7系统下载地址：链接：https://pan.baidu.com/s/1G_BpabXfQUCc77GocPgOKg提取码：9dla2、win7系统安装在虚拟机上的步骤：https://mp.weixin.qq.com/s/piIadMK80A9iRlCmcvyXaA（在文章第二部分，看仔细）3、按照步骤安装成功后，你会看到本机上一台虚拟的计算机诞生了，庆祝一下吧！·^_^·可以看到在虚拟机上一样可以上网，装各种软件，而且比本机运行速度快！那么你一定很奇怪怎么进行联网呢？ 五、VMVare虚拟机网络配置这些步骤的目的是为了将虚拟机的IP地址设置成笃定的IP地址，这样在本机连接虚拟机上的数据库时访问的IP地址是固定的！——当然还有一个最重要的目的，就是可以上网装逼喽，哈哈，所以认真跟着做吧！ 1、设置VMVare的默认网关:1）.编辑-&gt;虚拟网络编辑器:2）打开虚拟网络编辑器,点击添加网络：3）选择一个不重复的网络名称4）修改此网络为NAT模式5）特别注意：只能将一个网络设置成NAT模式由于我之前设置了一个网络19位NAT模式，这里以我设置的为例：6）查看该自定义网络相关信息：这里的信息都不需要进行更改2、修改虚拟机的网络适配器为自定义的网络对该虚拟机进行右键——设置点击网络适配器——自定义，选择刚刚设置的网络名称3、设置本地主机的虚拟网卡1）打开本机（是原先自己的计算机不是虚拟机）的网络和共享中心2）点击更改适配器设置3）找到你在虚拟机上新加的网络4）右键属性5）双击：6）选择IP地址7）点击确定网络设置大功告成4、查看虚拟机是否连接上网络打开IE，随便访问一个网址，或者看右下角看是否连接成功5、查看虚拟机的IP地址如果你没记住虚拟机的IP地址，可以在虚拟机的dos窗口下输入命令ipconfig6、查看虚拟机和本机能否正常连接分别在虚拟机和本机的dos窗口下ping一下对方的ip地址即可查看是否连接成功，这里我以在本机查看为例，在虚拟机上查看一样的效果这样代表你已经和你的虚拟机建立连接了，庆祝一下吧！—————————————————————————————— 六、在虚拟机上安装oracle11数据库终于到了最关键的一步，在虚拟机上安装oracle111、新建oracle目录在虚拟机的C盘下新建oracle目录，这将用来存放oracle112、下载oracle11地址（我用的是解压版） 3、解压一起选中这两个压缩包一起解压到当前目录4、将解压后的文件拖人虚拟机将解压后的database文件夹拖入到虚拟机刚刚在C盘下创建的oracle目录下5、打开database文件夹，启动setup6、安装第一步：配置安全更新，这步可将自己的电子邮件地址填写进去（也可以不填写，只是收到一些没什么用的邮件而已）。取消下面的“我希望通过My Oracle Support接受安全更新(W)”。 如图：7、安全选项，直接选择默认创建和配置一个数据库(安装完数据库管理软件后，系统会自动创建一个数据库实例)。 如图：8、系统类，直接选择默认的桌面类就可以了。(若安装到的电脑是，个人笔记本或个人使用的电脑使用此选项) 如图9、 典型安装。 重要步骤。建议只需要将Oracle基目录更新下，目录路径不要含有中文或其它的特殊字符。全局数据库名可以默认，且口令密码，必须要牢记。密码输入时，有提示警告，不符合Oracel建议时不用管。 (因Oracel建议的密码规则比较麻烦， 必须是大写字母加小写字母加数字，而且必须是8位以上。麻烦，可以输入平常自己习惯的短小密码即可) 如图：10、若输入的口令短小简单，安装时会提示如下。直接确认Y继续安装就是了。如图：11、先决条件检查。 安装程序会检查软硬件系统是否满足，安装此Oracle版本的最低要求。 直接下一步就OK 了。如图：12、 概要 安装前的一些相关选择配置信息。 可以保存成文件 或 不保存文件直接点完成即可。如图：13、安装产品 自动进行，不用管。如图：14、 数据库管理软件文件及dbms文件安装完后，会自动创建安装一个实例数据库默认前面的orcl名称的数据库。如图：15、实例数据库创建完成了，系统 默认是把所有账户都锁定不可用了(除sys和system账户可用外)，建议点右边的口令管理，将常用的scott账户解锁并输入密码。 如图：16、解锁scott账户和HR账户， 去掉前面的绿色小勾，输入密码。同样可以输入平常用的短小的密码，不必非得按oracle建议的8位以上大小写加数字，麻烦。如图：（题外话，scott是oracle起初团队的一个员工这个账户下能看到一些视图，HR是测试账号，一定要记住这两个账号名和密码：Scott密码设置成tiger，HR密码设置成hr）这里没有标出HR账号，需要自行找到并同样方式解锁17、安装成功，完成即可部分引用自该博客，感谢：https://www.cnblogs.com/hoobey/p/6010804.html 七、在虚拟机上测试oracle11是否安装成功1、在虚拟机上以管理员身份运行dos，2、输入指令sqlplus3、输入用户名：4、输入口令这里对应的用户名和密码有四个，我列举出三个：system——口令是在刚开始安装数据库的时候设置的scott——口令是tigerHR——口令是hr这样表示已经安装成功 八、本机通过和InstantClient工具连接到虚拟机数据库1、在虚拟机上设置相关参数1）修改listener和tnsnames的配置信息这里我将oracle11安装在了C盘下的oracle下的root目录下2）依次点击找到这个目录：C:\oracle\root\product\11.2.0\dbhome_1\NETWORK\ADMIN分别用记事本打开将localhost修改成虚拟机的IP地址并将修改后的tnsnames配置文件进行拷贝，这个配置文件需要拷贝到InstantClient工具包的一个目录下2、分别安装PLSQLDeveloper和InstantClient工具到本机上PLSQLDeveloper下载地址： InstantClient下载地址： 3、注意：这两个工具安装需要安装的目录不能有空格和中文，建议不要放在C盘下面4、找到instantclient_11_2下的目录instantclient_11_2——NETWORK——ADMIN——tnsnames.ora将tnsnames.ora删除，并将在虚拟机上拷贝的tnsnames.ora放进去5、本机环境变量的配置新建系统环境变量，变量名为TNS_ADMIN，变量值为tnsnames.ora在本机的目录（就是刚才拷贝的地方目录）6、PLSQLDeveloper工具连接数据库PLSQLDeveloper是基于InstantClient下进行的，所以一定按照我的步骤进行1、将PLSQLDeveloper安装在和InstantClient一级目录下，并创建桌面快捷方式，点击快捷方式先不管用户名和密码进入到PLSQLDeveloper图形化界面2、设置这两个地方的值分别是：instantclient_11_2的安装路径和instantclient_11_2下的oci.dll的安装路径3、重启PLSQLDeveloper客户端输入用户名和密码用户名和密码是在虚拟机上安装的oracle11的设置的用户名，system、scott、HR，输入队形的密码，点击确定这时该工具会去虚拟机寻找对应的数据库并寻找对应的用户名和密码左上角代表登录状态，显示已登录成功，这个时候查看一下数据库运行后： 终于完成、查到啦！该奖励自己一个鸡腿了，哈哈哈，想通了过程就不难！希望共同进步。。。。———————————————————————————————— 九、所有资源下载地址：1、虚拟机下载：2、运行在虚拟机上的操作系统下载3、oracle11g下载4、InstantClient下载5、PLSQLDeveloper下载 十、最后说明码字不易，需要支持，感谢，此文同步我的GitHub和微信公众号，欢迎关注和点赞。1、GitHub所有文章均以同步我的GitHub仓库，欢迎pull requests ，并期待你的star（即点赞）https://github.com/freestylefly/javaStudy2、微信公众号：苍何之旅微信搜索：苍何之旅，或者扫码即可关注 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>云服务器</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse 中配置XML提示]]></title>
    <url>%2F2019%2F04%2F13%2Feclipse%E4%B8%AD%E9%85%8D%E7%BD%AEXML%E6%8F%90%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(ru)中，欢迎有兴趣的童鞋们关注。 一、问题原油当我们在eclipse中编写XML时，需要出来提示信息（前提是没有联网），那么就需要进行用户自定义配置相关信息、 二、步骤这里我以配置Hibernate框架 中的XML为例子 1、将网络地址复制 2、打开windows下的个性设置profenrencese如图，依次找到用户自定义设置点击add 3、add页面配置将刚复制的网络URI地址放入keys中，type类型选择URI，location路径选择对应的路径，比如我这里对应的是hibernate-mapping-3.0的路径，需要在hibernate的jar包中找到该配置文件 4、完成配置 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>eclipse</category>
      </categories>
      <tags>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webstorm 上导入文件中文乱码问题解决]]></title>
    <url>%2F2019%2F04%2F13%2Fwebstorm%E4%B8%8A%E5%AF%BC%E5%85%A5%E6%96%87%E4%BB%B6%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(ru)中，欢迎有兴趣的童鞋们关注。 一、出现如下错误乱码 解决办法1、右键——file encoding2、 3、 3、再右键选择GBK 4、 5、完成 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>JavaWeb前端基础</category>
      </categories>
      <tags>
        <tag>乱码</tag>
        <tag>webstorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML 和 CSS 基础]]></title>
    <url>%2F2019%2F04%2F13%2FHTML%E5%92%8CCSS%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(huan)续(ying)更(jia)新(入)中，欢迎有兴趣的童鞋们关注。 一、HTML5基础1、HTML概述HTML: Hyper Text Markup Language 超文本标记语言 超文本: 比普通文本功能更加强大,可以添加各种样式 标记语言: 通过一组标签.来对内容进行描述. &lt;关键字&gt; , 是由浏览器来解释执行 2、HTML语法规范标签：不区分大小写，但是建议用小写 12345678910&lt;!-- 1. 上面是一个文档声明 &lt;meta charset=&quot;UTF-8&quot;/&gt;设置字符集编码 2. 根标签 html 3. html文件主要包含两部分. 头部分和体部分 头部分 : 主要是用来放置一些页面信息 体部分 : 主要来放置我们的HTML页面内容 4. 通过标签来对内容进行描述,标签通常都是由开始标签和结束标签组成 5. 标签不区分大小写, 官方建议使用小写--&gt; 3、基本标签12345&lt;p&gt;&lt;/p&gt;:标题标签&lt;br/&gt;换行&lt;hr/&gt;水平线&lt;strong&gt;&lt;/strong&gt;加粗&lt;en&gt;&lt;/en&gt;倾斜 4、特殊符号转义 空格 大于号 大于号 引号 版权符号（&copy;） &amp;nbsp; &amp;gt; &amp;lt; &amp;quot; &amp;copy 5、图像标签1&lt;img src=&quot;&quot; alt=&quot;&quot;/&gt; ​ 常用的属性; ​ width : 宽度 ​ height: 高度 ​ src : 指定文件路径 ​ alt: 图片加载失败时的提示内容 注意：img标签是块集标签，但是可以设置行高和宽高 6、文件路径​ ./ 代表的是当前路径​ ../ 代表的上一级路径​ ../../ 上上一级路径 7、超链接标签1&lt;a href=&quot;超链接路径&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt; 其中target为在哪个窗口打开：_self为默认在本页面打开 _blank在新窗口打开 去除超链接下划线：text-decoration：none href=#表示链接到当前页面 超链接的应用场合 页面间链接：A页到B页 锚链接 同页面内容的相互跳转： 在页面乙位置放置标记，可以设置name或者id用a标签包裹，然后在需要超链接的位置放上#加name的值即可 12&lt;a name="login"&gt;登录&lt;/a&gt;&lt;a href="#register"&gt;[新用户注册帮助]&lt;/a&gt; 在不同页面的锚链接 12&lt;a href="help.html#register"&gt;[新用户注册帮助]&lt;/a&gt;&lt;a name="login"&gt;登录&lt;/a&gt; 功能性链接 加上mailto：邮箱地址 8、行内元素和块级元素 行内元素除了img无法设置宽高：span、a、img、strong 款即元素前后有空行独占一行：h、p、div、列表 9、去除网页中所有的默认样式 *{padding:0;margin:0;} a{text-decoration:none;color:#fff;} 10、HTML5的结构元素 header footer section aside nav article 标题头部的内容 脚部区域的内容 web页面中间大区域 侧边栏 导航类辅助内容 独立的文章内容 11、内部框架标签iframesrc属性，指定容器默认显示内容 name指定框架的名称 hight：高 在a标签中的target可以选择iframe的name，这样会将内容放入iframe容器中显示，不再跳转到其他地方 12、框架标签:frameset：注意: 使用了frameset必须将body删掉,否则页面会有问题 二、列表1、是块级元素2、分类 无序列表ul无序列表定义 li列表内容 type: 实心圆（默认）：disc ,空心圆circle 小方块square 去掉项目符号：null 有序列表ol有序列表定义 li列表内容 type: 1,a ,A,I, ​ start : 指定是起始索引 自定义列表 dl——声明定义列表 dt——声明列表项 dd——定义列表项内容 3、列表样式 list-style list-style-type list-style-image list-style-position 三、表格1、基本概念 table： tr：行 td列（th代表第一行是定义行会加粗） 2、常用属性 table里属性： ​ cellspacing：单元格外边距 ​ cellpadding：单元格内边距 ​ align：水平对齐方式（left、right、center） ​ 不能加垂直对齐 ​ bgcolor : 背景色 单元格对齐： 垂直对齐：valign：（top、middle、bottom） 水平对齐（left、right、center） 2、表格跨行和跨列colspan：跨列 rowspan：跨行 三、表单1、基本定义123&lt;form action="#" method="post"&gt; &lt;input type="text" name="name" value="请输入姓名：" id=""&lt;/form&gt; 2、form标签内属性 method：提交方式：post/get 区别： 安全性、长度限制、URL中信息量是否拼接 action: 提交到哪里，#代表当前页面 3、input标签A、type类型 text、password、radio（单选框）、CheckBox（复选框）、 按钮（有提交功能）：button（普通按钮） ​ reset（重置按钮） ​ image（图片按钮） ​ submit（提交按钮） file文本域 单独的一种提交方式，需要在form中添加 enctype=“multipart/form=data” hidden隐藏域 通过指定的value属性，可用作后台处理数据，但是不需用显示出来 不常用的：email、url、rang（范围，可设置max、min和步长step）、number （数量）、datetime-local（时间日期） B、name最好加name，否则值可能获取不到 C、value在框中提示的词，需要删除替换的 D、size输入框长度 E、maxlength最大输入长度 F、readenly只读 G、disable禁用 H、checked默认值，设置此项为默认选项，在、radio（单选框）、CheckBox（复选框）的时候常用 I、placeholder提示信息（表单验证） J、required不能为空，必填（表单验证） K、patterrnpatterrn=“正则表达式”（表单验证） 4、select下拉列表123&lt;select name="a" id="c" size=3&gt; &lt;option value="2001" selected&gt;&lt;/option&gt;&lt;/select&gt; selected是默认选择的是哪一个 size为列表有几行 5、textarea条款，条约 可以设置cols和rows设置显示列和行数 条款试着默认值，只需要在两个textarea标签中加值即可 如何设置滚动条 https://www.cnblogs.com/hao-1234-1234/p/6971165.html 6、label标注表单标注，语法为： 1&lt;label for=""&gt;&lt;/label&gt; for里面加上id 常用于单选、复选为文字添加标注，目的是为了通过点击文字就可以到达对应的框里面 四、CSS浮动 定义：浮动的元素会脱离正常的文档流,在正常的文档流中不占空间 float属性:​ left​ right style的clear属性: 清除浮动​ both : 两边都不允许浮动​ left: 左边不允许浮动​ right : 右边不允许浮动 ​ 当下面div受到上面浮动影响加一个空的div清除浮动 设置元素的高和行高一样的就可以让文字居中清除浮动，防止父级边框塌陷的四种方法​ 1、浮动元素后面加空div ​ 需要将空div清除浮动both ​ 简单，空div会造成HTML代码冗余 ​ 2、设置父元素的高度 ​ 简单，元素固定高会降低扩展性 ​ 3、父级添加overflow属性（hidden） ​ 简单，下拉列表框的场景不能用 ​ 4、父级添加伪类after 12345#father：after&#123; content：“”； display：block； clear：both&#125; ​ 写法比上面稍微复杂一点，但是没有副作用，推荐使用 设置浮动一定记得扩展盒子高度 五、CSS选择器1、css选择器 元素（标签）选择器: 标签的名称{}——n标签选择器直接应用于HTML标签，不遵循就近原则 类选择器: 以. 开头 .类的名称——n类选择器可在页面中多次使用 ID选择器: 以#开头 , #ID的名称 (ID必须是页面上面唯一) ——nID选择器在同一个页面中只能使用一次 ​ �{�� 2、选择器优先级 按照选择器搜索精确度来编写: 就近原则: 哪个离得近,就选用哪个的样式 行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 元素选择器 3、css高级选择器 并集选择器（选择器分组） : 选择器1,选择器2{ 属性的名称:属性的值} 多个选择器通过逗号连接而成 属性选择器: 1234567a[title] ——title为属性名a[titile='aaa'] ——aaa属性值a[href][title] ——两个属性名a[href][title='aaa'] ——两个属性名，一个属性值a[title^=“val”] ——属性值是以val开头的a[title$=“val”] ———属性值是以val结尾的a[title`=“val”] _属性值中包含以val字段的 层次选择器包括：后代选择器、子元素选择器、相邻兄弟选择器、通用兄弟选择器 后代选择器: E F 爷爷选择器 孙子选择器 找出所有的后代，中间以空格隔开 子元素选择器: E&gt;F 父选择器 &gt; 儿子选择器 ：只能找到父元素的直接后代 相邻兄弟选择器：E+F 选择匹配的F元素，且匹配的F元素紧位于匹配的E元素后面 如： 12.active+p &#123; background: green; &#125;会找出在类名为active的类下的第一个p标签的元素 通用兄弟选择器:：E`F 选择匹配的F元素，且位于匹配的E元素后的所有匹配的F元素，如： 12.active~p&#123; background: yellow; &#125;会找出active类名下的所有含有p标签的元素 结构伪类选择器 E F:nth-child(n) 代表查找父元素E下面的弟n个叫做F的孩子，会按照顺序进行排序（不管亲兄弟还是堂兄弟，都是兄弟） E F:nth-of-type(n) 代表去除了类型之后的孩子，亲兄弟，在父元素E下面的所有亲的弟n个F（去除类型后再排序） 1234567891011121314151617181920212223242526272829303132333435&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;使用CSS3结构伪类选择器&lt;/title&gt; &lt;style&gt; /*p:first-child&#123;*/ /*background-color: #0000A8;*/ /*&#125;*/ /*body&gt;p:first-child&#123;*/ /*background-color: #0000A8;*/ /*&#125;*/ body p:nth-of-type(odd)&#123; background-color: #0000A8; &#125; 在body下的所有p，并且都是奇数，注意li里面的p中的p计数是以li里面各自计数，odd奇数，even代表偶数*/ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;p1&lt;/p&gt; &lt;p&gt;p2&lt;/p&gt; &lt;p&gt;p3&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;li1&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;li2&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;li3&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 伪类选择器: 通常都是用在a标签上 a:link {color:black} 未单击访问的链接 a:hover{color:black} 鼠标悬浮其上的超链接样式 a:active {color:black} 鼠标单击未释放的超链接样式 a:visited {color:black} 已访问的链接 交集选择器 由两个选择器连接构成，，选中两者的交集，两个选择器之间不能有交集，第一个必须是标签选择器，第二个必须是类选择器或者id选择器 六、CSS的常见样式1、字体样式 font-family font-size font—style font-weight font 设置字体类型 设置字体大小 设置字体风格 设置字体粗细 在一个声明中设置所有字体属性 font简写，可以按顺序设置如下属性： font—style：字体风格，italic表示斜体 font—variant font-weight：粗细 font-size/：字体大小 line-height：行高 font-family：字体类型，多种字体用逗号隔开，中文字体放在后面，字体名称为多个字符的时候用引号引起来 一起写font：分（风格）出（粗细）大（大小）类（类型） 2、文本样式 color text-align text-indent text-height text-decoration vertical-align text-shadow 文本颜色 元素水平对齐方式 首行文本的缩进1em代表向右缩进1个字符 文本的行高 文本的装饰（去除超链接默认下划线用其none值）underline、line-through(删除线、中划线) 垂直对齐方式，设置文本和图片的居中对齐，在使得他的值为 文本阴影，三个值，阴影颜色、X位移、Y位移 3、div标签 网页布局 排版网页内容 属性：height、width 是块级元素，默认独占一行，两个div要想在一行显示就需要浮动 4、css设置鼠标形状 5、背景属性 背景颜色：background-color:#B70447 背景图像(背景图会覆盖背景颜色) 图像路径：background-image：url(图像路径) 重复方式：background-repeat:no-reqeat 背景定位：background-position:10px 15px 关键词： 水平方向：left center right 垂直方向：top ccenter bottom css3渐变 linear-gradinent（tobottom，颜色1，颜色2） 背景定位 10px,20px，代表的是向右，向下移动 背景属性简写（没有顺序要求）： background:url(背景图路径) no-repeat #f91f1 10px 15px 6、去除网页中所有的默认样式 *{padding:0;margin:0;} a{text-decoration:none;color:#fff;} 7、display属性 控制元素的显示和隐藏 块级元素与行内元素的转变 | none | inline | block | inline-block || :————————: | :——————————: | :—————————: | —————— || 设置元素不会被显示 | 元素会被显示为内联元素 | 元素被显示为块级元素 | 行内块元素 | 注意： block和none结合起来用，可以达到开始隐藏，当鼠标移上去的时候会显示图片或者相关的信息，如： ul li:hover div{ ​ display:block; } inline-block常用于将元素排列一排 七、网页中引用css样式1、行内样式就是在标签后直接写style属性如： 1&lt;p style="CSS样式"&gt;&lt;/p&gt; 2、内部样式表指在head上加style标签，写css样式 123&lt;style&gt; css样式&lt;/style&gt; 3、外部样式表css文件 在网页中导入或者引入外部样式文件即可 链接式 &lt;link/&gt;属于XHTML，使用其连接的css文件先加载到网页当中，再进行编译显示 123456&lt;link rel="stylesheet" href="css/first.css"/&gt;css文件样式h1&#123; color: #0000FF;&#125;不用写style 导入式式@import属于CSS2.1使用其导入的css文件，客户端显示HTML架构，再把css文件加载到网页众怒干，是属于CSS2.1特有的，对于不兼容CSS2.1的浏览器来说是无效的 123&lt;!--@import url("style.css");--&gt; 八、盒子模型 1、边框border 边框样式：border-style border-top-style：上边框样式 none无边框 border-right-style：右边框样式 solid实线边框 border-bottom-style：下边框样式 dashed虚线边框 border-left-style：左边框样式 dolted点边框 border-style：设置四个边框样式 double双线边框 边框颜色：border-color 边框粗细：border-width border-top-width（bottom、right、left） border-width 关键字：thin、medium、thick 像素值：px 边框简写 同时设置边框的颜色、粗细和样式 border-bottom：9px #F00 dashed； border：8px #F00 solid（常用） 2、外边框margin两个盒子之间的距离（都是内盒子） margin-top（right、left、top） margin：3px 3px 3px 3px（上、右、下、左） 大元素整体水平居中用margin：0px auto 3、内边距padding子盒子和父盒子之间的边距（比如手机的内部填充物 padding：10px——四个方向都是10px padding：10px 20px——上下10px，左右20px padding：10px 20px 30px——上10，右20、下30，左20 padding：10px 20px 30px 40px——上10，右20、下30，左40（按照左右上下） 4、计算盒子模型的尺寸盒子实际高度=上下外边距+上下边框+上下内边距+内容高度 盒子实际宽度=上下外边距+上下边框+上下内边距+内容宽度 5、box-sizing属性 content-box：盒子的实际宽度和高度仅适用于元素内容 ，不包括内边距和边框 border-box盒子的实际宽度和高度包括元素内容、边框和内边距 5、使用overflow属性扩展盒子高度 visible hidden scroll auto 默认值，内容不会被修建，会呈现在盒子之外 内容会被修建，并且其余内容是不可见的 内容会被修建，但是浏览器会显示滚动条以查看其余内容 如果内容被修建，则浏览器会显示滚动条以查看其余内容，自动加滚动条 两种扩展盒子高度的区别 使用overflow 属性扩展盒子高度减少代码量，也减少了空的HTML标签，使代码更加简洁、清晰，从而提高了代码的可读性和网页性能 如果页面中有定位元素，并且元素超出了父级的范围，就必须clear属性来清楚浮动来扩展盒子高度 6、box-sizing1234box-sizing：content-box | border-box | inherit三个值分别为：默认值，盒子的总尺度盒子的宽度或高度等于元素内容的宽度或高度元素继承父元素的盒子模型模式 7、圆角边框1border-radius: 20px 10px 50px 30px; 利用border-radius属性制作圆形的两个要点 Ø元素的宽度和高度必须相同 Ø圆角的半径为元素宽度的一半，或者直接设置圆角半径值为50% 123456div&#123; width: 100px; height: 100px; border: 4px solid red; border-radius: 50%; &#125; u利用border-radius属性制作半圆形的两个要点 Ø制作上半圆或下半圆时，元素的宽度是高度的2倍，而且圆角半径为元素的高度值 ​ Ø右半圆时，元素的高度是宽度的2倍，而且圆角半径为元素的宽度值 u利用border-radius属性制作扇形遵循“三同，一不同”原则 Ø“三同”是元素宽度、高度、圆角半径相同 Ø“一不同”是圆角取值位置不同 鼠标悬浮其上（鼠标悬浮变色，让其他变色： 注意的一点是：悬浮在A上改变B的状态，一定要是B是A的子元素 12a：hover span&#123;&#125;，代表鼠标悬浮在a上soan改变状态li：hover a&#123;&#125;：代表鼠标悬浮在li上，而对li里面的a标签进行改变样式 对齐方式： 水平对齐：text-align或者设置外边距上下为0，左右为auto 垂直对齐：设置行高和高度相等即可 8、盒子阴影123456789101112box-shadow:inset x-offset y-offset blur-radius color各个参数意义：阴影类型内阴影X轴位移，指定阴影水平位移量Y轴位移，用来指定阴影垂直位移量阴影模糊半径阴影向外模糊的模糊范围阴影颜色，定义绘制阴影时所使用的颜色例子：ul li:hover&#123; box-shadow: 0 0px 5px rgba(0, 0, 0, 0.1)&#125;ul li:hover&#123;box-shadow: 0 5px 5px rgba(0, 0, 0, 0.1), 0 0 10px 0 rgba(0,0,0,0.2); 九、定位position定位常用用法： 在需要定位元素加position：absolute ​ top：0px。。。 在直接父级加一个无改变位置的position：relative 1、position属性 static relative absolute fixed 默认值，没有定位 相对定位 绝对定位 固定定位 2、relative属性 相对自身原来位置进行偏移 偏移设置：top、left、right、bottom，单位px 设置相对定位的盒子会相对于它原来的位置，通过指定偏移，到达新的位置 设置了相对定位的网页元素，无论是在标准流中还是在浮动流中，都不会对他的父级元素和相邻元素有任何影响，他只是针对自身原来的位置进行偏移 设置相对定位的盒子仍在标准文档流中，它对父级盒子和相邻的盒子都没有任何影响 n设置相对定位的盒子原来的位置会被保留下来 相对定位一般情况下很少自己单独使用，都是配合绝对定位使用，为绝对定位创造定位父级而又不设置偏移量 3、absolute属性 绝对定位 决对定位是针对浏览器的，如果想要针对父容器定位则要将父容器设置为非static n使用了绝对定位的元素以它最近的一个“已经定位”的“祖先元素为基准进行偏移 如果没有已经定位的祖先元素，会以浏览器窗口为基准进行定位 绝对定位的元素从标准文档流中脱离，这意味着它们对其他元素的定位不会造成影响 元素位置发生偏移后，它原来的位置不会被保留下来 一般情况下，绝对定位用在下拉菜单、焦点图轮播、弹出数字气泡、特别花边等场景 4、fixed 固定定位 会像狗皮膏药一样，尽管网页上下左右滑动，但是元素在网页中位置不变 类似绝对定位，不过区别在于定位的基准不是祖先元素，而是浏览器窗口 一般在网页中被用在窗口左右两边的固定广告、返回顶部图标、吸顶导航栏等 5、z-index属性 用来调整元素定位时重叠层的上下位置 z-index属性值：整数，默认值是0 设置了position属性时，z-index属性可以设置各个元素之间的重叠高低关系 zi-index值大的层位于值小的层的上方 6、网页元素透明度 opacity:x filter:alpha(opacity=x) x值为0~1，值越小越透明 x值为0~100，值越小越透明 opacity:0.4; filter:alpha(opacity=40);  还有一种透明方式的控制就是利用rgba来控制，如： 1background: rgba(157,157,157,0.4); 其中的代表的就是透明度，这样做的好处是不会覆盖原有的背景填充 十、css3动画1、transform变形CSS3变形是一些效果的集合 如平移、旋转、缩放、倾斜效果 transform:[transform-function] *; 设置变形函数，可以是一个，也可以是多个，中间以空格分开 变形函数 translate()：平移函数，基于X、Y坐标重新定位元素的位置 scale()：缩放函数，可以使任意元素对象尺寸发生变化 rotate()：旋转函数，取值是一个度数值 skew()：倾斜函数，取值是一个度数值 案例：制作多彩照片墙： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div&#123; width: 800px; margin: 0 auto; position: relative; &#125; img&#123; padding: 10px; border: 1px solid lightgray; background-color: white; position: absolute; width: 45%; &#125; img:nth-child(1)&#123; top:150px; left: 50px; transform: rotate(-15deg); &#125; img:nth-child(2)&#123; top:130px; left: 200px; transform: rotate(30deg); &#125; img:nth-child(3)&#123; top:200px; left: 500px; transform: rotate(-20deg); &#125; img:hover&#123; transform: rotate(0deg) scale(1.3); z-index: 1; box-shadow: 0 0 5px rgba(0,0,0,0.4); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;img src="image/1.jpg" title="1"/&gt; &lt;img src="image/2.jpg" title="2"/&gt; &lt;img src="image/3.jpg" title="3"/&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2、transition在初识状态添加，那么鼠标移入和移出都会有动画效果，最好在初始状态中添加 实现步骤： 设置开始状态，可不写 设置结束状态 添加transition属性 transition呈现的是一种过渡，是一种动画转换的过程，如渐现、渐弱、动画快慢等 CSS3 transition的过渡功能更像是一种“黄油”，通过一些CSS的简单动作触发样式平滑过渡 语法： transition:[transition-property transition-duration transition-timing-function transition-delay ] 分别代表含义：过渡或动态模拟的CSS属性、完成过渡所需要的时间、指定过渡函数、过渡开始出现的延迟时间 过渡属性（ transition-property ） 定义转换动画的CSS属性名称 IDENT：指定的CSS属性（width、height、background-color属性等） all：指定所有元素支持transition-property属性的样式，一般为了方便都会使用all n过渡所需的时间（ transition-duration ） u定义转换动画的时间长度，即从设置旧属性到换新属性所花费的时间，单位为秒（s） n过渡动画函数（ transition-timing-function ） u指定浏览器的过渡速度，以及过渡期间的操作进展情况，通过给过渡添加一个函数来指定动画的快慢方式 Øease：速度由快到慢（默认值） Ølinear：速度恒速（匀速运动） Øease-in：速度越来越快（渐显效果） Øease-out：速度越来越慢（渐隐效果） Øease-in-out：速度先加速再减速（渐显渐隐效果） 过渡延迟时间（ transition-delay ） 指定一个动画开始执行的时间，当改变元素属性值后多长时间去执行过渡效果 Ø正值：元素过渡效果不会立即触发，当过了设置的时间值后才会被触发 Ø负值：元素过渡效果会从该时间点开始显示，之前的动作被截断 Ø0：默认值，元素过渡效果立即执行 过渡的触发机制 n伪类触发 u：hover u：active u：focus u：checked u n媒体查询：通过@media属性判断设备的尺寸，方向等 nJavaScript触发：用JavaScript脚本触发 演示案例：旋转按钮： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; ul&#123; overflow: hidden; border: 1px solid red; &#125; li&#123; list-style: none; float: left; margin-left: 10px; height: 100px; line-height: 100px; /*1.设置开始的状态*/ /*3.添加transition*/ transition: all 3s ease-in-out -1s ; &#125; li:hover&#123; /*2.设置结束的状态*/ transform: rotate(1080deg) scale(1.3); &#125; li img&#123; vertical-align: middle; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;&lt;img src="images/delicious.png"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="images/facebook.png"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="images/rss.png"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="images/twitter.png"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="images/yahoo.png"/&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 3、animation动画animation实现动画主要由两个部分组成 Ø通过类似Flash动画的关键帧来声明一个动画 Ø在animation属性中调用关键帧声明的动画实现一个更为复杂的动画效果 语法： animation:animation-name animation–duration animation-timing-function animation-delay animation-iteration-count animation-direction animation-play-state animation-fill-mode; ​ ;mso-ascL n动画的播放次数（animation-iteration-count） u值通常为整数，默认值为1 u特殊值infinite，表示动画无限次播放 n动画的播放方向（animation-direction） unormal，动画每次都是循环向前播放 ualternate，动画播放为偶数次则向前播放 n动画的播放状态（animation-play-state） urunning将暂停的动画重新播放 upaused将正在播放的元素动画停下来 n动画发生的操作（animation-fill-mode） uforwards表示动画在结束后继续应用最后关键帧的位置 ubackwards表示会在向元素应用动画样式时迅速应用动画的初始帧 uboth表示元素动画同时具有forwards和backwards的效果 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>JavaWeb前端基础</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 网络编程技术]]></title>
    <url>%2F2019%2F04%2F11%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(jing)续(chang)更(duan)新(geng)中，欢迎有兴趣的童鞋们关注。 1、查看本机的IP地址和网络相关概念config查看本机的IP地址ping命令测试网络是否通畅网络是连接在一起共享数据和资源的计算机按照覆盖范围可以分为：局域网、城域网、广域网ping 127.0.0.1检查TCP/IP协议安装是否正确 2、基于TCP协议的网络编程①建立连接②打开socket关联的输入/输出流③从流中读取信息④关闭流和socket 注意点：1、先写服务器，再写客户端2、在客户端输出部分要加socket.shutdownOutput()（相当于告诉服务器我说的话说完了），若用字符流写，需要在socket.shutdownOutput()前面加上flash方法，清空缓存3、本机localhost4、端口号不低于1024 三、实例1、客户端发送的请求为String字符串 123456789101112131415161718192021222324252627282930313233343536373839404142package demo1;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;/* * 服务器 */public class LoginServece &#123; public static void main(String[] args) throws Exception &#123; //建立连接 ServerSocket serverSocket= new ServerSocket(8000); Socket socket =serverSocket.accept(); //打开输入流 InputStream is=socket.getInputStream(); //读 BufferedReader br = new BufferedReader(new InputStreamReader(is)); String info=null; while((info=br.readLine())!=null) &#123; System.out.println("我是服务器，客户端说："+info); &#125; // 给回应 String reply ="我是服务器，欢迎登陆"; OutputStream os=socket.getOutputStream(); os.write(reply.getBytes()); //关闭资源 os.close(); br.close(); is.close(); socket.close(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435package demo1;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.net.Socket;import java.net.UnknownHostException;/* * 客户端 */public class LoginClient &#123; public static void main(String[] args) throws Exception, IOException &#123; Socket socket = new Socket("localhost", 8000); // 发送请求 OutputStream os = socket.getOutputStream(); String info = "姓名：jim 密码12345"; os.write(info.getBytes()); socket.shutdownOutput(); // 读回应 InputStream is = socket.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(is)); String replu = null; while ((replu = br.readLine()) != null) &#123; System.out.println("我是客户端，服务器说：" + replu); &#125; br.close(); is.close(); os.close(); socket.close(); &#125;&#125; 2、客户端传出的是一个对象的情况需要将对象序列化，注意要实现Serializable接口 1234567891011121314151617181920212223242526272829303132333435package demo2;import java.io.Serializable;public class User implements Serializable&#123; private String name; private String psd; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPsd() &#123; return psd; &#125; public void setPsd(String psd) &#123; this.psd = psd; &#125; public User() &#123; super(); // TODO Auto-generated constructor stub &#125; public User(String name, String psd) &#123; super(); this.name = name; this.psd = psd; &#125; @Override public String toString() &#123; return "用户名："+this.getName()+"\t"+"密码："+this.getPsd(); &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940package demo2;import java.io.InputStream;import java.io.ObjectInputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;/* * 服务器 */public class LoginServece &#123; public static void main(String[] args) throws Exception &#123; //建立连接 ServerSocket serverSocket= new ServerSocket(8000); Socket socket =serverSocket.accept(); //打开输入流 InputStream is=socket.getInputStream(); //读 ObjectInputStream ois = new ObjectInputStream(is); User user=(User) ois.readObject(); System.out.println(user); // 给回应 OutputStream os=socket.getOutputStream(); String reply ="我是服务器，欢迎登陆"; os.write(reply.getBytes()); //关闭资源 os.close(); ois.close(); is.close(); socket.close(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435package demo2;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.ObjectOutputStream;import java.io.OutputStream;import java.net.Socket;/* * 客户端 */public class LoginClient &#123; public static void main(String[] args) throws Exception, IOException &#123; Socket socket = new Socket("localhost", 8000); // 发送请求 OutputStream os = socket.getOutputStream(); ObjectOutputStream oos =new ObjectOutputStream(os); User user =new User("Jack", "123456"); oos.writeObject(user); // 读回应 InputStream is = socket.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(is)); String replu = null; while ((replu = br.readLine()) != null) &#123; System.out.println("我是客户端，服务器说：" + replu); &#125; os.close(); oos.close(); socket.close(); &#125;&#125; 3、利用多线程实现多个客户端发出请求情况①创建服务器线程类，run（）方法实现对一个请求的响应处理②死循环让服务器一直处于监听状态③服务器每监听一个线程，创建一个线程对象并启动 123456789101112131415161718192021package demo3;import java.net.ServerSocket;import java.net.Socket;/* * 服务器 */public class LoginServece &#123; public static void main(String[] args) throws Exception &#123; //建立连接 ServerSocket serverSocket= new ServerSocket(8000); Socket socket; while(true) &#123; socket=serverSocket.accept(); MyThread thread =new MyThread(socket); thread.start(); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package demo3;import java.io.IOException;import java.io.InputStream;import java.io.ObjectInputStream;import java.io.OutputStream;import java.net.Socket;public class MyThread extends Thread&#123; private Socket socket; public MyThread(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; //打开输入流 InputStream is=null; ObjectInputStream ois=null; OutputStream os=null; try &#123; is = socket.getInputStream(); //读 ois = new ObjectInputStream(is); User user=(User) ois.readObject(); System.out.println(user); // 给回应 os=socket.getOutputStream(); String reply ="我是服务器，欢迎登陆"; os.write(reply.getBytes()); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; //关闭资源 try &#123; os.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; try &#123; ois.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; try &#123; is.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; try &#123; socket.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536package demo3;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.ObjectOutputStream;import java.io.OutputStream;import java.net.Socket;import java.net.UnknownHostException;/* * 客户端 */public class LoginClient22 &#123; public static void main(String[] args) throws Exception, IOException &#123; Socket socket = new Socket("localhost", 8000); // 发送请求 OutputStream os = socket.getOutputStream(); ObjectOutputStream oos =new ObjectOutputStream(os); User user =new User("good", "111111"); oos.writeObject(user); // 读回应 InputStream is = socket.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(is)); String replu = null; while ((replu = br.readLine()) != null) &#123; System.out.println("我是客户端，服务器说：" + replu); &#125; os.close(); oos.close(); socket.close(); &#125;&#125; 四、InetAddress类位于java.net包中，常用于封装IP地址和DNS静态方法InetAddress.getByName(String hostName)返回指定主机名的InetAddress对象 五、基于UDP协议的socket编程四个步骤1、DatagramPacket对象封装数据包2、DatagramSocket发送数据包3、DatagramSocket接收数据包4、DatagramPacket处理数据包TCP和UDP协议的异同实现实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package socket4;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;import java.net.SocketException;/* * 基于UDP协议的网络编程 */public class LoginnServerce &#123; public static void main(String[] args) &#123; DatagramSocket socket=null; try &#123; //接收客户端发过来的请求 //1、建立一个空包用来收 byte[] b =new byte[1024]; DatagramPacket dp = new DatagramPacket(b, b.length); //2、创建DatagramSocket，（快递点） socket =new DatagramSocket(8000); //3、收数据 socket.receive(dp); //读取数据 String info = new String(dp.getData(),0,dp.getData().length); System.out.println("客户端说："+info); //给客户端一个响应 String reply = "我是服务器，你好，客户端！"; DatagramPacket dp1=new DatagramPacket(reply.getBytes(), reply.getBytes().length, InetAddress.getByName("localhost"), 8000); //不用再创建socket socket.send(dp1); &#125; catch (SocketException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; if(null!=socket) &#123; socket.close(); &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package socket4;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.Inet4Address;import java.net.InetAddress;import java.net.SocketException;import java.net.UnknownHostException;/* * 客户端 */public class LoginClient &#123; public static void main(String[] args) &#123; String info="你好啊，服务器！"; byte[] infos=info.getBytes(); //获得一个InetAddress InetAddress address; DatagramSocket socket=null; try &#123; address = Inet4Address.getByName("localhost"); //建立一个包裹封装数据 DatagramPacket dp =new DatagramPacket(infos,infos.length,address,8000); //建立快递点 socket =new DatagramSocket(); //通过快递点发送数据 socket.send(dp); //接收服务器发来的信息 //创建一个空包接收 byte[] b = new byte[1024]; DatagramPacket dp1 =new DatagramPacket(b, b.length); socket.receive(dp1); // 读取信息 String reply = new String(dp1.getData(), 0, dp1.getData().length); System.out.println(reply); &#125; catch (UnknownHostException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (SocketException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; socket.close(); &#125; &#125;&#125; 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>Java语言核心</category>
      </categories>
      <tags>
        <tag>internit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 中的流和反射]]></title>
    <url>%2F2019%2F04%2F11%2Fjava%E4%B8%AD%E7%9A%84%E6%B5%81%E5%92%8C%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(jing)续(chang)更(duan)新(geng)中，欢迎有兴趣的童鞋们关注。 一、定义流是指一连串流动的字符，是以先进先出的方式发送信息的通道。程序和数据之间是通过流进行关联的。 二、分类1、按流向分输出流：OutputStream和Writer作为基类输入流：InputStream和Reader作为基类2、按处理数据的单元划分字节流：nputStream/OutputStream作为基类字符流：Reader/Writer作为基类 三、流之间的层级关系上层为基类1、输入ReaderInputStreamReader(可设置字符编码) Bufferendreader(带有缓冲区)InputStreamFileInputStream objecInputStream（反序列化） DateInputStream（读二进制文件）2、输出WriterOuputStreamWriterr(可设置字符编码) BufferendWriterr(带有缓冲区)InputStreamFileOutputStream objecOutputStream（序列化） DateIOutputStream（读二进制文件） 四、流的正确使用1、File类操作文件 1234567891011121314151617181920package demo1;import java.io.File;import java.io.IOException;/* * 使用File类创建文件,并实现更删除、显示文件名和路径操作 */public class Test1 &#123; public static void main(String[] args) throws IOException &#123; File file = new File("D:\\test1.txt"); if(!file.exists()) &#123; file.createNewFile();//不存在创建 &#125;else &#123; file.delete();//存在删除 &#125; System.out.println("该文件的绝对路径名为"+file.getAbsolutePath()); System.out.println("该文件名为："+file.getName()); &#125;&#125; 特别注意：创建File对象的时候可以放决相对路径也可以放决对路径直接写test.txt代表的是在该项目底下的文件而如果携程D:\test.txt的话是代表此文件 在D盘下的文件 File类常用方法：| 方法 | 说明 ||—|—|| boolean exisit() | 判断文件是否存在 || String getName() | 获得文件名 || boolean creatNewFile() | 创建文件（创建前要判断文件是否存在 ） | 2、使用字节流FileInputStream读文本文件 1234567891011121314151617181920212223package demo2;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;/* * 字节流FileInputStream读取文件 */public class Test1 &#123; public static void main(String[] args) throws Exception &#123; File file =new File("demo2.txt"); FileInputStream fis = new FileInputStream(file); byte[] b = new byte[fis.available()]; int data=-1; while((data=fis.read(b))!=-1) &#123; &#125; String str = new String(b);//将字节数组变为字符串 System.out.println(str); fis.close(); &#125;&#125; FileInputStream 常用方法| 方法 | 说明 ||—|—|| inr read((byte[] b) | 将数据缓存在字节数组中最后通过String的构造方法将字节数组转换成字符串输出 ||int read() | 一个字节一个字节的读 |3、使用字节流FileInputStream和FileOutputStream复制文本文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package demo2;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;/* * 复制文件 */public class Test2 &#123; public static void main(String[] args) &#123; FileInputStream fis =null; FileOutputStream fos=null; try &#123; fis= new FileInputStream("D:\\demo1.txt"); byte[] b = new byte[fis.available()]; int date =-1; while((date=fis.read(b))!=-1)&#123; &#125; fos = new FileOutputStream("E:\\Java\\java学习\\代码\\demo1.txt"); fos.write(b); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; if(null!=fos)&#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; if(null!=fis)&#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 4、使用DataInputStream和DataOutputStream读写二进制文件 12345678910111213141516171819202122232425package demo3;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;/* * 复制图片,二进制流的应用 */public class Test1 &#123; public static void main(String[] args) throws Exception &#123; DataInputStream dis = new DataInputStream(new FileInputStream("D:\\1.jpg")); DataOutputStream dos =new DataOutputStream(new FileOutputStream("E:\\Java\\java学习\\代码\\t.jpg")); int date=-1; while((date=dis.read())!=-1)&#123; dos.write(date); &#125; dos.close(); dis.close(); &#125;&#125; 5、字符流FileReader &amp; FileWriter 1234567891011121314151617181920212223242526272829303132333435package demo4;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.FileWriter;/* * 字符流FileReader &amp; FileWriter */public class Test1 &#123; public static void main(String[] args) throws Exception &#123; FileReader fr = new FileReader("demo2.txt"); //方式一、一个字符一个字符的读// int date=-1;// while((date=fr.read())!=-1) &#123;// System.out.print((char)date);// &#125; //方式二：字符数组读文件 char[] c = new char[1024]; int data =-1; while((data=fr.read(c))!=-1) &#123; &#125; System.out.println(c); //为读出的文本文件追加字符 FileWriter fw = new FileWriter("demo2.txt",true); fw.write("我做主"); //关闭流 fw.close(); fr.close(); &#125;&#125; 6、使用带有缓冲区的流输入输出，异常处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package demo5;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileWriter;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.UnsupportedEncodingException;/* * 使用带有缓冲区的流输入输出，异常处理 */public class Test1 &#123; public static void main(String[] args) &#123; InputStream is = null; InputStreamReader isr = null; BufferedReader br = null; BufferedWriter bw = null; try &#123; // 读取文件 is = new FileInputStream("demo5.txt"); isr = new InputStreamReader(is, "GBK"); br = new BufferedReader(isr); String info = null; while ((info = br.readLine()) != null) &#123; System.out.println(info); &#125; // 写入新的文本 bw = new BufferedWriter(new FileWriter("demo5.txt", true));//熟悉之后都可以采用这种方式进行简写 bw.newLine(); bw.write("今天也要元气满满哦！"); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123;//注意如果不管流的话会导致很多东西出现bug，如果有bug先找是否正确的关闭流了 if (null != bw) &#123; try &#123; bw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (null != br) &#123; try &#123; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (null != isr) &#123; try &#123; isr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (null != is) &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 注意指定字符编码，请确认是GBK还是UTF-8 五、一个重要综合性利用流的例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.io.OutputStreamWriter;import java.io.UnsupportedEncodingException;public class IoDemo1 &#123; public static void main(String[] args) &#123; InputStream is = null; InputStreamReader isr = null; BufferedReader br = null; OutputStream os = null; OutputStreamWriter osw = null; BufferedWriter bw = null; try &#123; // 读 is = new FileInputStream("t1.txt"); isr = new InputStreamReader(is, "GBK"); br = new BufferedReader(isr); String info = br.readLine(); System.out.println(info); // 写 os = new FileOutputStream("t2.txt",true); osw = new OutputStreamWriter(os, "GBK"); bw = new BufferedWriter(osw); bw.newLine(); bw.write(info); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; try &#123; bw.close(); osw.close(); os.close(); br.close(); isr.close(); is.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 特别注意：一定要关闭流，有时候没关闭会出现很多的错误 六、序列化和反序列化1、使用序列化保存对象信息（写出 objecOutputStream） 2、使用反序列化获取对象信息（写出 objecInputStream） 3、例子： 12345678910111213141516171819202122232425262728293031323334353637383940package Demo1;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.ArrayList;/* * 序列化和反序列化 */public class Test1 &#123; public static void main(String[] args) throws Exception, IOException &#123; ArrayList&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); Student stu1 =new Student("jck",12,"男"); Student stu2 =new Student("lick",13,"男"); Student stu3 =new Student("as",12,"女"); list.add(stu1); list.add(stu2); list.add(stu3); //反序列化储存 ObjectOutputStream oos =new ObjectOutputStream(new FileOutputStream("demo1.txt")); oos.writeObject(list); //反序列化 ObjectInputStream ois =new ObjectInputStream(new FileInputStream("demo1.txt")); Object obj=ois.readObject(); ArrayList&lt;Student&gt; stuList = (ArrayList&lt;Student&gt; )obj; for(int i =0;i&lt;stuList.size();i++) &#123; Student stu=stuList.get(i); System.out.println(stu); &#125; &#125;&#125; 七、反射12345678910111213141516171819202122232425262728293031323334353637383940package Demo2;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;public class Test1 &#123; public static void main(String[] args) &#123; //先获取Student类对应的Class对象 Class cla=Student.class; //获取所有构造方法 Constructor[] cons=cla.getConstructors(); //获取所有构造方法的个数 System.out.println(cons.length); //获取所有构造方法名字 for (int i = 0; i &lt; cons.length; i++) &#123; System.out.println(cons[i].getName()); &#125; //获取共有的属性(只能是public修饰的) Field[] fields=cla.getFields(); for (int i = 0; i &lt; fields.length; i++) &#123; System.out.println(fields[i].getName()); &#125; //获取所有的属性 Field[] fis=cla.getDeclaredFields(); for (int i = 0; i&lt; fis.length; i++) &#123; System.out.println(fis[i].getType()); &#125; //获取类的方法 Method[] methods=cla.getMethods(); for (int i = 0; i &lt; methods.length; i++) &#123; System.out.println(methods[i].getName()); &#125; &#125;&#125; 123456789101112131415161718192021package Demo2;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;/** * 通过反射使用有参构造方法构造Student对象 * @author Administrator * */public class Test2 &#123; public static void main(String[] args) throws NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123; //获取Student对应的Class对象 Class&lt;Student&gt; cla=Student.class; //获取Class对象中的构造方法 Constructor&lt;Student&gt; cons=cla.getConstructor(String.class,int.class,String.class); //为构造方法传递参数 Student stu=cons.newInstance("jack",100,"123456"); System.out.println(stu); &#125;&#125; 12345678910111213141516171819202122232425262728package Demo2;import java.lang.reflect.Constructor;import java.lang.reflect.Method;/* * 通过反射使用有参构造方法构造Student对象 */public class Test3 &#123; public static void main(String[] args) throws Exception, SecurityException &#123; //获取Student的class对象 Class cla = Student.class; //获取Class对象中的构造方法 Constructor&lt;Student&gt; cons=cla.getConstructor(); Student stu=cons.newInstance(); //获得指定set方法为属性赋值 Method setNameMethod=cla.getDeclaredMethod("setName", String.class); setNameMethod.invoke(stu, "jack"); Method setAgeMethod=cla.getDeclaredMethod("setAge", int.class); setAgeMethod.invoke(stu, 18); Method setSexMethod=cla.getDeclaredMethod("setSex", String.class); setSexMethod.invoke(stu, "男"); System.out.println(stu); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536package Demo2;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;/* *通过反射直接为私有属性赋值 */public class Test4 &#123; public static void main(String[] args) throws Exception, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123; // 获取Student的class对象 Class cla = Student.class; // 获取Class对象中的构造方法 Constructor&lt;Student&gt; cons = cla.getConstructor(); Student stu = cons.newInstance(); //访问私有成员 Field nameField=cla.getDeclaredField("name"); //获取私有属性的操作权限 nameField.setAccessible(true); nameField.set(stu, "张三"); Field ageField=cla.getDeclaredField("age"); //获取私有属性的操作权限 ageField.setAccessible(true); ageField.set(stu, 30); Field sexField=cla.getDeclaredField("sex"); //获取私有属性的操作权限 sexField.setAccessible(true); sexField.set(stu, "男"); System.out.println(stu); &#125;&#125; 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:&gt;]]></content>
      <categories>
        <category>Java-basic</category>
      </categories>
      <tags>
        <tag>流</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 多线程技术]]></title>
    <url>%2F2019%2F04%2F11%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[较为详细扩展的文章可参见这篇博客：https://blog.csdn.net/qq_34337272/article/details/79640870 一、线程定义线程是进程中执行运算的最小单位，是进程内部的一个执行单元1、多个线程同时进行，采用枪占的机制，单核计算机一个时间只有一个线程执行，采用枪占资源的方式 二、多线程的优势1、最大限度的提高计算机系统的利用效率2、充分利用网络和系统资源 三、主线程main方法为主线程入口主线程必须最后执行 四、创建线程1、继承Thread类重写run方法测试中只需要创建线程对象即可2、实现Runnable接口测试诶中创建线程时候，需要Thread thread=new Thread（m，name）；m为线程类的实例name为此线程的名字 两种方法的区别Thread方法较简单，适用于单继承Runnable很好的避免了java中的单根继承，并且使用这种方法可以共享数据资源。 五、线程的状态1、新生（创建）new但是还没调用start方法2、就绪调用了start方法，但是未抢到CPU的资源3、运行执行run方法4、阻塞是一种不可运行状态，造成阻塞的原因：执行Thread.sleep()方法 IO操作时，IO操作未完成*需要得到琐，但是琐被占用5、死亡退出main方法 六、线程调度1、线程优先级①设置优先级setPriority(int guid)②1-10表示优先级，10最高，5为默认，每一个优先级对应Thread的一个公用静态常量NORM_PRIORITY=5MIN_PRIORITY=1MAX_PRIORITY=10线程的优先级只是表示一个抢到资源的概率，不一定每次优先级高的都先运行，只是表示有这种可能性2、实现线程调度的方法①sleep静态方法要用Thread.sleep(1000);括号内为毫秒数强制让线程休眠②join非静态方法线程名.join();谁调用join方法，该线程就先执行完，也有可能出现要加入的线程在未达到join条件时就已执行完毕，这时候join就不起作用了。③yield静态方法Thread.yield线程的礼让可以让当前线程暂停执行，允许其他线程执行，但该线程任然可运行状态，此时，系统选择其他或更高优先级的线程执行，如无其他，则该线程继续执行， 七、线程同步高并发安全性问题：马上双十一了，很多多人同一时间点会访问同一数据，这时候线程安全就很重要了线程同步：所谓线程同步就是当两个或多个线程要访问同一资源时，需要以某种顺序来确保某一时刻只能一个线程使用的方式1、同步代码块在访问修饰符前或后加synchronized，比如这个例子 12345678910111213141516171819202122232425262728293031package demo4;/* * 线程同步测试 * 1、同步代码块 */public class MyThread implements Runnable &#123; private int count=10;//显示余票 private int piao;//显示抢到几张票 @Override public void run() &#123; while(true) &#123; synchronized (this) &#123; if (count &lt;= 0) &#123; break; &#125; count--; piao++; //模拟网络延迟 try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "抢到弟" + piao + "张票,剩余" + count + "张票!"); &#125; &#125; &#125; &#125; 注意：eclipse自动生成同步代码块的快捷键右键——Surround with——synchronized…2、同步方法 1234567891011121314151617181920212223242526272829303132333435package demo5;/* * 线程同步测试 * 2、同步方法 */public class MyThread implements Runnable &#123; private int count=10;//显示余票 private int piao;//显示抢到几张票 boolean flag=true; @Override public void run() &#123; while(flag) &#123; buy(); &#125; &#125; synchronized public void buy() &#123; if (count &lt;= 0) &#123; flag=false; return; &#125; //模拟网络延迟 try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; count--; piao++; System.out.println(Thread.currentThread().getName() + "抢到弟" + this.piao + "张票,剩余" + this.count + "张票!"); &#125; &#125; 注意：并不是同步的代码越多越好，容易出现死锁现象 线程同步涉及的类和方法（重要）1、ArryLit类的add方法：是非线程同步，不安全的2、StringBuffer同步安全 StringBuilder非同步，不安全3、线程安全的：能同步，共享资源，安全非线程安全：效率高4、HashMap：建只能有一个为空，值不能为空，不安全 Hashtable：键值都不允许为空，安全 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>Java-basic</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>multithreading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML 技术]]></title>
    <url>%2F2019%2F04%2F11%2FXML%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[本系列文章在 https://github.com/freestylefly/javaStudy 持(jing)续(chang)更(duan)新(geng)中，欢迎有兴趣的童鞋们关注。 Ⅰ Ⅱ Ⅲ Ⅳ Ⅴ Ⅵ Ⅶ XML简介 XML文档结构 XML编写注意事项 XML命名空间 验证XML文档 DOM解析XML dom4j XML简介 XML文档结构 XML编写注意事项 XML命名空间 验证XML文档 DOM解析XML dom4j XML简介1、XML是可扩展标记语言2、与操作系统和操作平台均无关3、规范统一，支持异构系统 XML文档结构 1、XML声明&lt;?xml version=”1.0” encoding=”UTF-8” ?&gt; 注意：这里需要修改的encoding，如果出现乱码，需要改成GBK 2、标签元素名 元素属性名=“属性值” 元素内容 3、根元素写在声明下面的标签元素，有且只有一个根元素 4、属性一个元素可以有多个属性，多个属性之间用空格分开 注意：属性可以加在任何一个元素的其实标签上，但不能加在结束标签上，且不能包含特殊字符&lt; “ .&amp; 5、特殊字符的处理 XML编写注意事项 XML命名空间命名空间是在解析XML文档时，对于重名的元素，可能出现解析冲突，他们用来标识来自特定域（标准组织、公司、行业）的名称除非带有前缀，否则属性属于他们的元素所在的命名空间 验证XML文档DTD验证 DOM解析XML1、步骤 （1）创建解析器工厂1DocumentBuilderFactory factory =DocumentBuilderFactory.newInstance(); （2）创建解析器1DocumentBuilder builder =factory.newDocumentBuilder(); （3）获得Document1document=builder.parse("src/info.xml"); （4）创建解析器工厂 以Document对象为起点对DOM树的节点进行增加、删除、修改查询等操作 2、关键代码（包含增删该查操作）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137package demo1;import java.io.FileOutputStream;import java.io.IOException;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.transform.OutputKeys;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerFactory;import javax.xml.transform.dom.DOMSource;import javax.xml.transform.stream.StreamResult;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;public class Test1 &#123; private Document document; /** * 创建Document对象 * @throws IOException * @throws Exception */ public void getDoc() throws Exception, IOException &#123; //解析器工厂 DocumentBuilderFactory factory =DocumentBuilderFactory.newInstance(); //创建解析器 DocumentBuilder builder =factory.newDocumentBuilder(); //获得Document document=builder.parse("src/info.xml"); &#125; /** * 保存XM * @throws Exception */ public void save() throws Exception &#123; TransformerFactory factory =TransformerFactory.newInstance(); factory.setAttribute("indent-number", 4);//天假空白 Transformer transformer=factory.newTransformer(); //设置格式 transformer.setOutputProperty(OutputKeys.ENCODING, "UTF-8"); transformer.setOutputProperty(OutputKeys.INDENT, "YES"); DOMSource xmlSource =new DOMSource(document); StreamResult outputTarget =new StreamResult(new FileOutputStream("src/info.xml")); transformer.transform(xmlSource, outputTarget); &#125; /** * 增加新手机节点 * @throws Exception */ public void add() throws Exception &#123; getDoc(); Element eleBrand=document.createElement("Brand"); eleBrand.setAttribute("name", "小米手机"); //获得根元素 Element root=(Element) document.getElementsByTagName("PhoneInfo").item(0); root.appendChild(eleBrand); save(); &#125; /** * 修改 * @throws Exception * @throws IOException */ public void change() throws IOException, Exception &#123; getDoc(); NodeList brands = document.getElementsByTagName("Brand"); for (int i = 0; i &lt; brands.getLength(); i++) &#123; Node brandNode=brands.item(i); Element eleBrand =(Element) brandNode; String brandName = eleBrand.getAttribute("name"); if(brandName.equals("苹果")) &#123; eleBrand.setAttribute("name", "apple"); save(); &#125; &#125; &#125; /** * 删除 * @throws Exception * @throws IOException */ public void delate() throws Exception, Exception &#123; getDoc(); NodeList brands = document.getElementsByTagName("Brand"); for (int i = 0; i &lt; brands.getLength(); i++) &#123; Node brandNode=brands.item(i); Element eleBrand =(Element) brandNode; String brandName = eleBrand.getAttribute("name"); if(brandName.equals("苹果")) &#123; eleBrand.getParentNode().removeChild(eleBrand); save(); &#125; &#125; &#125; /** * 显示 * @throws Exception * @throws IOException */ public void show() throws IOException, Exception &#123; getDoc(); //获得brand节点 NodeList brands=document.getElementsByTagName("Brand"); for (int i = 0; i &lt; brands.getLength(); i++) &#123; Node brandNode =brands.item(i); Element eleBrand =(Element) brandNode; System.out.println(eleBrand.getAttribute("name")); //获得brand下的子节点 NodeList types=eleBrand.getChildNodes(); for (int j = 0; j &lt; types.getLength(); j++) &#123; Node typeNode=types.item(j); if(typeNode.getNodeType()==Node.ELEMENT_NODE) &#123; Element eleType = (Element) typeNode; System.out.println("\t"+eleType.getAttribute("name")); &#125; &#125; &#125; &#125; public static void main(String[] args) throws IOException, Exception &#123; Test1 t = new Test1(); t.show(); t.add(); t.change(); t.delate(); &#125;&#125; 3、注意区别这几个关键词Document: 可操作整个DOM树 Node 代表节点（节点又分为元素节点、文本节点），其中元素节点又叫标签节点，是带有尖括号的，换行在XML中也被认为是节点 Element 元素节点，是Node的一个子类 Atteabute 凡是对属性进行操作的 item 从NodeList中获得Node，要通过循环遍历 dom4j1、方法：百度dom4j，看官方帮助文档，里面会有一系列的方法。 2、显示xml信息123456789101112131415161718192021222324public class Test1 &#123; public static void main(String[] args) throws Exception &#123; //获取domcument对象 SAXReader reader = new SAXReader(); Document doc =reader.read("src//info.xml"); //获取根元素 Element root =doc.getRootElement(); //循环遍历输出子节点 Iterator&lt;Element&gt; it=root.elementIterator(); while(it.hasNext()) &#123; Element brandEle = it.next(); String strBrand=brandEle.attributeValue("name"); Iterator&lt;Element&gt; it2=brandEle.elementIterator(); while(it2.hasNext())&#123; Element typeEle=it2.next(); String strType=typeEle.attributeValue("name"); System.out.println("品牌："+strBrand+"\t"+"型号："+strType); &#125; &#125; &#125;&#125; 3、保存xml文件12345//保存 OutputFormat format =OutputFormat.createPrettyPrint(); XMLWriter writer = new XMLWriter(new FileWriter("src//info.xml"),format); writer.write( doc ); writer.close(); 4、添加信息1234//添加 Element eleBrand = root.addElement("Brand"); eleBrand.addAttribute("name", "小米"); eleBrand.addText("这是小米手机"); 5、修改&amp;删除12345678910111213// 修改 Iterator&lt;Element&gt; it = root.elementIterator(); while (it.hasNext()) &#123; Element brandEle = it.next(); Attribute att = brandEle.attribute("name"); if (att.getValue().equals("三星")) &#123; //修改// att.setValue("sanxing"); //删除属性对象（包括属性名和属性值）// brandEle.remove(att); //删除整个brand三星 brandEle.getParent().remove(brandEle); &#125; 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>Java-basic</category>
      </categories>
      <tags>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一份简明的 Markdown 笔记与教程]]></title>
    <url>%2F2018%2F09%2F06%2Fmarkdown-intro%2F</url>
    <content type="text"><![CDATA[此文章摘自： https://github.com/mzlogin/markdown-intro 自从 2014 年左右接触到 Markdown 以来，对它的使用就一发而不可收拾。从最开始使用它在 GitHub Pages 里写博客，到用它编辑项目的 README 文件，再到撰写开发文档，编辑微信公众号文章和邮件内容等等，这期间也见证了它在各类平台和网站上的普及和被原生支持，可以说，Markdown 如今已经渗透了我在技术和网络活动的方方面面，成为了我撰写文本文档的首选。 那么首先我们一起来看一下它的「定义」： Markdown 是一种轻量级标记语言，创始人为 John Gruber。它允许人们「使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者 HTML）文档」。——维基百科 本文档的目的不在于面面俱到地介绍 Markdown，只是作为我对其理解的笔记整理，希望能同时帮助一些对 Markdown 感兴趣的人快速上手，或是作为一个工具，供对其已经有所了解的人在需要时参考。 接下来请随我一起深入了解这门并不神秘的实用标记语言。 目录 TOC{:toc} 背景优点 专注于文字内容； 纯文本，易读易写，可以方便地纳入版本控制； 语法简单，没有什么学习成本，能轻松在码字的同时做出美观大方的排版。 使用场景 各类代码托管平台 主流的代码托管平台，如 GitHub、GitLab、BitBucket、Coding、Gitee 等等，都支持 Markdown 语法，很多开源项目的 README、开发文档、帮助文档、Wiki 等都用 Markdown 写作。 技术社区和写作平台 StackOverflow、CSDN、掘金、简书、GitBook、有道云笔记 论坛 V2EX、光谷社区 个人感觉比较遗憾的一点是各平台可能采用不同语言实现的 Markdown 解析引擎，或采用同一解析引擎的不同版本，而且可能有不同程度的定制与扩展，这导致在不同平台上使用 Markdown 写作时体验并不完全一致。不过幸好对于大家公认的一些标准语法，各家都是支持的。 编辑工具理论上任何一款文本编辑器都能用于编辑 Markdown 文档，它们分别提供了不同程度的语法高亮、预览等功能，以下只是列举其中一部分，选择自己称手的即可。 现代编辑器 VSCode / Atom 传统编辑器 Vim / Emacs / Sublime Text / Notepad++ IDE 自带编辑器 IntelliJ IDEA / Android Studio / WebStorm 专用编辑器 Ulysses / Mou / Typora / Markpad 在线编辑器 各种支持 Markdown 的网站都提供了在线编辑器 语法标题Markdown： 1234567891011# atx-style 一级标题## 二级标题###### 六级标题Setext-style 一级标题===二级标题--- 预览效果： atx-style 一级标题二级标题六级标题Setext-style 一级标题二级标题 对应 HTML： 123456789&lt;h1&gt;atx-style 一级标题&lt;/h1&gt;&lt;h2&gt;二级标题&lt;/h2&gt;&lt;h6&gt;六级标题&lt;/h6&gt;&lt;h1&gt;Setext-style 一级标题&lt;/h1&gt;&lt;h2&gt;二级标题&lt;/h2&gt; 段落中间没有空行的连续不断的几行文字被视为一个段落。 Markdown： 123456789白日依山尽，黄河入海流。（句号后面没空格）欲穷千里目，更上一层楼。 （句号后面有俩空格） 预览效果： 白日依山尽， 黄河入海流。（句号后面没空格） 欲穷千里目， 更上一层楼。（句号后面有俩空格） 对应 HTML： 123456789101112&lt;p&gt;白日依山尽，&lt;/p&gt;&lt;p&gt;黄河入海流。（句号后面没有空格）&lt;/p&gt;&lt;p&gt;欲穷千里目，&lt;/p&gt;&lt;p&gt; 更上一层楼。 &lt;br&gt; （句号后面有俩空格）&lt;/p&gt; 行内格式对段落或者部分文本的强调效果。 Markdown： 123后面俩字**加黑**后面俩字*斜体* 预览效果： 后面俩字加黑 后面俩字斜体 对应 HTML： 12345678&lt;p&gt; 后面俩字 &lt;strong&gt;加黑&lt;/strong&gt;&lt;/p&gt;&lt;p&gt; 后面俩字 &lt;em&gt;斜体&lt;/em&gt;&lt;/p&gt; 引用块Markdown： 123456&gt; 引用块段落一。&gt;&gt; 引用块段落二。&gt;&gt; 内嵌引用块段落一。&gt;&gt; ### 引用块内的标题 预览效果： 引用块段落一。 引用块段落二。 内嵌引用块段落一。 引用块内的标题 对应 HTML： 12345678&lt;blockquote&gt; &lt;p&gt;引用块段落一。&lt;/p&gt; &lt;p&gt;引用块段落二。&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;内嵌引用块段落一。&lt;/p&gt; &lt;/blockquote&gt; &lt;h3 id="引用块内的标题"&gt;引用块内的标题&lt;/h3&gt;&lt;/blockquote&gt; 超链接Markdown 支持行内式链接和引用式链接。 Markdown： 12345678910行内式 [博客](https://mazhuang.org &quot;我的个人博客&quot;) 链接，带 title。行内式 [GitHub](https://github.com/mzlogin) 链接。引用式 [博客][1] 链接。引用式 [GitHub][2] 链接，带 title。[1]: https://mazhuang.org[2]: https://github.com/mzlogin &quot;我的 GitHub 主页&quot; 预览效果： 行内式 博客 链接，带 title。 行内式 GitHub 链接。 引用式 博客 链接。 引用式 GitHub 链接，带 title。 对应 HTML： 1234567&lt;p&gt;行内式 &lt;a href="https://mazhuang.org" title="我的个人博客"&gt;博客&lt;/a&gt; 链接，带 title。&lt;/p&gt;&lt;p&gt;行内式 &lt;a href="https://github.com/mzlogin"&gt;GitHub&lt;/a&gt; 链接。&lt;/p&gt;&lt;p&gt;引用式 &lt;a href="https://mazhuang.org"&gt;博客&lt;/a&gt; 链接。&lt;/p&gt;&lt;p&gt;引用式 &lt;a href="https://github.com/mzlogin" title="我的 GitHub 主页"&gt;GitHub&lt;/a&gt; 链接，带 title。&lt;/p&gt; 图片在超链接的写法前加一个 !，就是引用图片的方法。 Markdown： 1![Alt text](https://mazhuang.org/favicon.ico &quot;favicon&quot;) 预览效果： 对应 HTML： 1&lt;img src="https://mazhuang.org/favicon.ico" alt="Alt text" title="favicon"&gt; 列表包括有序列表和无序列表。 Markdown： 1234567- 苹果- 葡萄- 榴莲1. 苹果2. 葡萄3. 榴莲 预览效果： 苹果 葡萄 榴莲 苹果 葡萄 榴莲 对应 HTML： 12345678910&lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;葡萄&lt;/li&gt; &lt;li&gt;榴莲&lt;/li&gt;&lt;/ul&gt;&lt;ol&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;葡萄&lt;/li&gt; &lt;li&gt;榴莲&lt;/li&gt;&lt;/ol&gt; 其中无序列表的标记可以使用 +、- 或 *，有序列表前的数字可以是乱序的。 代码块支持行内代码和代码块。 Markdown： Android 里使用 `TextUtils` 类的 `isEmpty` 方法来判断字符串是否为空。 123if (TextUtils.isEmpty(text)) &#123; return null;&#125; 预览效果： Android 里使用 TextUtils 类的 isEmpty 方法来判断字符串是否为空。 123if (TextUtils.isEmpty(text)) &#123; return null;&#125; 对应 HTML： 12345&lt;p&gt;Android 里使用 &lt;code&gt;TextUtils&lt;/code&gt; 类的 &lt;code&gt;isEmpty&lt;/code&gt; 方法来判断字符串是否为空。&lt;/p&gt;&lt;div class="highlight highlight-source-java"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;if&lt;/span&gt; (&lt;span class="pl-smi"&gt;TextUtils&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;isEmpty(text)) &#123; &lt;span class="pl-k"&gt;return&lt;/span&gt; &lt;span class="pl-c1"&gt;null&lt;/span&gt;;&#125;&lt;/pre&gt;&lt;/div&gt; 上例中的语言标记 java 可选填，可用于在编辑器和渲染后的效果里添加语法高亮。 块式代码也可以对整个代码段缩进四个空格，或一个 Tab 来实现。 水平分割线使用一个单独行里的三个或以上 *、- 来生产一条水平分割线，它们之间可以有空格。 Markdown： 12345***------ - - 预览效果： 对应 HTML： 12345&lt;hr /&gt;&lt;hr /&gt;&lt;hr /&gt; 嵌入 HTMLMarkdown 标记语言的目的不是替代 HTML，也不是发明一种更便捷的插入 HTML 标签的方式。它对应的只是 HTML 标签的一个很小的子集。 对于那些没有办法用 Markdown 语法来对应的 HTML 标签，直接使用 HTML 来写就好了。 扩展语法本节的内容是介绍一些受到广泛支持的 Markdown 扩展语法。 表格Markdown： | 编号 | 姓名（左） | 年龄（右） | 性别（中） | | ----- | :-------- | ---------: | :------: | | 0 | 张三 | 28 | 男 | | 1 | 李四 | 29 | 男 | 预览效果： 编号 姓名（左） 年龄（右） 性别（中） 0 张三 28 男 1 李四 29 男 对应 HTML： 123456789101112131415161718192021222324&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th align="left"&gt;姓名（左）&lt;/th&gt; &lt;th align="right"&gt;年龄（右）&lt;/th&gt; &lt;th align="center"&gt;性别（中）&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;0&lt;/td&gt; &lt;td align="left"&gt;张三&lt;/td&gt; &lt;td align="right"&gt;28&lt;/td&gt; &lt;td align="center"&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td align="left"&gt;李四&lt;/td&gt; &lt;td align="right"&gt;29&lt;/td&gt; &lt;td align="center"&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 任务列表在 GitHub / GitLab 里有较好的支持。 Markdown： 123- [x] 洗碗- [ ] 清洗油烟机- [ ] 拖地 预览效果： [x] 洗碗 [ ] 清洗油烟机 [ ] 拖地 对应 HTML： 12345&lt;ul class="contains-task-list"&gt; &lt;li class="task-list-item"&gt;&lt;input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""&gt; 洗碗&lt;/li&gt; &lt;li class="task-list-item"&gt;&lt;input type="checkbox" id="" disabled="" class="task-list-item-checkbox"&gt; 清洗油烟机&lt;/li&gt; &lt;li class="task-list-item"&gt;&lt;input type="checkbox" id="" disabled="" class="task-list-item-checkbox"&gt; 拖地&lt;/li&gt;&lt;/ul&gt; 如果是在 GitHub / GitLab 的 Issue 里，会附赠任务完成比例提示效果： 还可以直接在网页上拖动调整顺序，勾选和取消勾选。 删除线Markdown： 1后面三个字打上~~删除线~~。 预览效果： 后面三个字打上删除线。 对应 HTML： 1&lt;p&gt;后面三个字打上&lt;del&gt;删除线&lt;/del&gt;。&lt;/p&gt; 自动链接自动链接扩展，即：当识别到 URL，或用 &lt;、&gt; 包括的 URL 时，会自动为其生成 a 标签。 Markdown： 123https://github.com&lt;example@gmail.com&gt; 预览效果： https://github.com &#x65;&#x78;&#97;&#109;&#112;&#x6c;&#x65;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109; 对应 HTML： 123&lt;p&gt;&lt;a href="https://github.com"&gt;https://github.com&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="mailto:example@gmail.com"&gt;example@gmail.com&lt;/a&gt;&lt;/p&gt; emoji以 GitHub Pages 为例。 Markdown： 1:camel: :blush: :smile: 预览效果： :camel: :blush: :smile: 对应 HTML： 12345&lt;p&gt; &lt;img class="emoji" title=":camel:" alt=":camel:" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f42b.png" height="20" width="20"&gt; &lt;img class="emoji" title=":blush:" alt=":blush:" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f60a.png" height="20" width="20"&gt; &lt;img class="emoji" title=":smile:" alt=":smile:" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f604.png" height="20" width="20"&gt;&lt;/p&gt; 奇技淫巧脑洞清奇的工程师们还发掘了很多使用 Markdown 的方法，大部分都是引入第三方 JavaScript 插件来实现。对这部分我只做简述，对其中的部分功能比如作图等，还是推荐用专门的可视化工具去做。 画流程图和时序图有部分网站和编辑器实现了对 Markdown 里流程图和时序图的支持，比如我们使用的项目管理工具 TAPD 的在线编辑器，还有 VSCode + 插件 Markdown Preview Enhanced 等。 以我们使用的项目管理工具 TAPD 的在线编辑器为例： 插入数学公式仍然以 TAPD 为例： 应该是利用 JavaScript 支持了 LaTeX 公式语法。 用 Markdown 做 PPT有专门的工具 Marp，另外使用 VSCode + 插件 Markdown Preview Enhanced 也可以实现。 用 Markdown 写微信公众号可以将公众号素材用 Markdown 编辑好后，贴到在线排版工具以后，复制到公众号编辑器里即可。有多种页面主题和代码主题可选择。 我维护的工具地址：https://md.mazhuang.org 更多想象力丰富的工程师们还扩展了很多基于 Markdown 的玩法，包括但不限于： 自动生成 / 更新 Table of Contents 流程图 / 时序图 制作幻灯片 集成 PlantUML / GraphViz 的能力 导出 HTML / PDF / 电子书 … 以上功能基本都可以用 VSCode + 插件 Markdown Preview Enhanced 实现。 另外可以参考我以前的一篇博客 关于 Markdown 的一些奇技淫巧。 参考 Markdown: Syntax - DARING FIREBALL Markdown - 维基百科 GitHub Flavored Markdown Spec 关于 Markdown 的一些奇技淫巧 本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决两个 Android 模拟器之间无法网络通信的问题]]></title>
    <url>%2F2017%2F12%2F03%2Ftcp-connect-between-android-emulators%2F</url>
    <content type="text"><![CDATA[本文解决的是一个小众场景的问题： 出差在外，需要调试局域网内的两台 Android 设备之间通过 TCP 通信的情况，可手边又不是随时有多台可用的设备，于是想在笔记本上同时跑两台 Android 模拟器来构造调试环境，但是发现它俩的 IP 地址竟然都是 10.0.2.15，场面一度十分尴尬…… 谷狗之后，众多相关的博客和问答贴将我引向了官方文档页面： Interconnecting emulator instances 原来官方指南上解释过相关的知识，现将我关心和以前迷惑的部分翻译摘录如下，如果希望对此有个更全面的了解，还是推荐完整阅读 Android 官方文档里有关 Emulator 的章节 https://developer.android.com/studio/run/emulator.html 首先讲一点预备知识，再说解决方案。 模拟器的网络地址空间每个模拟器都运行在一个虚拟路由/防火墙服务后面，这个服务将模拟器和宿主机器的网络接口、配置以及 Internet 隔离开来。对模拟器而言，宿主机器和其它模拟器对它是不可见的，它只知道自己是通过以太网连接到路由/防火墙。 每个模拟器的虚拟路由管理 10.0.2/24 的网络地址空间，所有地址都是 10.0.2.xx 格式。地址预分配的情况如下： 网络地址 描述 10.0.2.1 路由/网络地址 10.0.2.2 宿主机器的 loopback interface，相当于电脑上的 127.0.0.1 10.0.2.3 首选 DNS Server 10.0.2.4 10.0.2.5 10.0.2.6 可选的第二、第三、第四 DNS Server 10.0.2.15 模拟器的网络地址 127.0.0.1 模拟器的 loopback interface 需要注意的是所有模拟器的网络地址分配都是一样的，这样一来，如果有两个模拟器同时运行在一台电脑上，它们都会有各自的路由，并且给两个模拟器分配的 IP 都是 10.0.2.15。它们被路由隔离，相互不可见。 另外一点就是模拟器上的 127.0.0.1 是指它自己，所以如果想访问宿主机器上运行的服务，要使用 10.0.2.2。 实现两台模拟器之间的通信现在来解决标题和文首提到的问题，主要用到了网络重定向。 假设开发环境是： PC 是指运行模拟器的宿主电脑 emulator-5554 是模拟器 1，将在 TCP 通信中作为 server 端 emulator-5556 是模拟器 2，将在 TCP 通信中作为 client 端 配置步骤： 在 emulator-5554 上运行 server，侦听 10.0.2.15:58080 在 PC 上运行 cat ~/.emulator_console_auth_token，得到一个 token 在 PC 上运行 123telnet localhost 5554auth &lt;token&gt;redir add tcp:51212:58080 &lt;token&gt; 是指第 2 步中得到的 token。 51212 是 PC 端口，58080 是 5554 模拟器的端口。 在 emulator-5556 上运行 client 程序，连接 10.0.2.2:51212 至此，两台模拟器之间已经可以通过 TCP 愉快地通信了。 它们之间的网络连接和通信示意图如下： 注： 以上步骤中用到的端口号都是可以根据你的需求替换的 Windows 下 telnet 命令默认没有启用，具体启用方法请搜狗一下 模拟器的网络限制 模拟器上运行的 Apps 可以连接到宿主电脑上的网络，但这是通过模拟器间接实现，不是直接连到宿主电脑的网卡。模拟器可以看作是宿主电脑上运行的一个普通程序。 因为模拟器的特殊网络配置，可能无法支持一些网络协议，比如 ping 命令使用的 ICMP 协议。目前，模拟器不支持 IGMP 和 multicast。 试验了一下，模拟器的 shell 里 ping www.sogou.com 一直卡在那，在手机的 shell 里就可以。 额外的发现在阅读 Android 官方文档里关于模拟器的章节时，意外地发现有一节 [Sending a voice call or SMS to another emulator instance][2] 就是说模拟器可以给另外的模拟器打电话和发短信，电话号码就是端口号，比如 emulator-5554 模拟器，电话号码就是 5554，这个号码也可以从模拟器的窗口标题栏上找到，比如 Android Emulator - Nexus_5X_API_19:5554，里面那个 5554 就是。 后话天下博文，大部分都逃不出官方文档与公开源码的范畴（比如本文就是），而且都是选定文档里讲的某一小部分来进行讲解演绎，这在作为扩展视野、快速上手、快速解决问题等用途时还是比较实用的，但如果想系统、全面地学习，官方文档一般是更好的选择。 [2]: https://developer.android.com/studio/run/emulator-networking.html#calling本文章已同步至我的GitHub仓库：Javastudy,期待您的加入:blush: 本文章已同步至苍何的个人博客,可以直接在博客上留言哦:blush: 来我的微信公众号玩耍呗:blush: 扫码无套路关注我的CSDN博客:blush:]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>Emulator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jestem]]></title>
    <url>%2F2014%2F11%2F25%2Fjestem%2F</url>
    <content type="text"><![CDATA[知道这部电影是从一个名叫「容易忽视的豆瓣高分电影」的豆列里，从豆列的名字我就知道它注定不热闹，果然在剧情结束后屏幕上出现了这行字： 谨以此献给每一个孤独的灵魂。 这恐怕是该片的豆瓣影评里出现频率最高的一个句子了，我觉得它配得起这句话。 注：以下内容有剧透，介意慎读。 这部电影最令我感到特别的地方是当我看完后试图去用里面人物的名字去帮助描述一些事情的时候，发现貌似整部电影都没有出现过几个主要人物的名字，好吧就用小正太、萝莉和御姐来分别代表男、女主和她的女神姐姐吧。 不管是否是导演本意，不得不说最先感受到的还是这世界满满的恶意。小正太被妈妈的驱逐，在孤儿院遭受的嘲笑，大人们有意或者无意的「小杂种」的称呼，同龄小孩们起哄的追打欺负，无不透露出一阵阵的绝望。幸而小正太不是玻璃心，才没有在这各种摧残下自暴自弃走向堕落，即使必须一个人藏身在废弃的船里，每天靠捡破烂维持生活，即使只能每天偷偷地看着不远处萝莉一家人的幸福暗自羡慕。萝莉虽生活在一个正常的家庭，但是生活在御姐的光环下，自卑敏感，觉得不会有人想吻自己这样「又丑又笨」的人，以后想干的事情就是「当一名老处女」，听到这个「理想」笑过之后一阵心酸，欧洲人的黑色幽默真的是让我又爱又恨…… 当然人间有真情，人间有真爱。萝莉和小正太之间被这些阴暗所催生出来的感情（原谅我不想称之为爱情）——即使只是两个小孩子想相互依偎取暖，但它可以代表人与人之间纯粹的关系和跳出原有生活的可能性。御姐最后为了保护萝莉拨给警察的电话——尽管我也像豆瓣影评里的大多数人那样，一厢情愿地希望这个天使脸孔的女子能成全萝莉和小正太来个童话式结局，但是转头又清醒地知道童话里都是骗人的。船夫，回收站的老头，萝莉爸爸，不经意间流露出来的一丝关怀也能让人心生一丝暖意。 特别是萝莉，作为小正太生活中光亮的象征，我更愿意给她一个幻化的寓意： 123456789每当你身陷黑暗记住心存渴望总会有一束光为你指引方向即使它偶尔被遮挡请坚定地走深渊禁锢不了心的自由请坚定地走骄傲地昂着头 挥起手 不知道有多少人会从小正太和萝莉身上会看到自己曾经的影子，对这世界认知过程中逐渐意识到不公平，自卑，质疑为何是自己要去遭受这些苦难，感觉不被需要，渴望的东西得不到，太美，太丑……即使学会抽离地旁观这喧嚣的世界，也还是发现，有一些黑暗，只能独自穿过；有一些问题无人能答，只能自己挣扎着去寻找生存方式和存在价值。 用于点题的电影开头与结尾实际是同一段对白： - 你叫什么名字？- 我叫什么名字，有什么关系吗？- 人生在世所为何来？- 我是。 最终小正太还是被带回了充满嘲笑与冷漠的孤儿院，但我对他未来的生活并不担心，因为即使生活如此不堪，他依然拥有一颗善良、坚韧和渴望爱的心，很多我们认为的苦难在这个承受过这个年经里不该承受的东西的孩子眼里不过浮云，他已经懂得存在的意义就是自己本身。 对现实里那些企图绊倒他的东西，他会做出这个手势，然后抬起头，继续向前走。 在如此不诗意的现实里，他终将成为一名真的诗人。]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Jestem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[习惯成就高效能]]></title>
    <url>%2F2014%2F10%2F28%2Fsevenhabits%2F</url>
    <content type="text"><![CDATA[首先需要说明的是，我并不相信成功有什么方法论，不过生活中很多的事情确是有套路可以遵循借鉴的，正如公元前两三百年的时候，亚里士多德就说过的话： 人的行为总是一再重复，因此卓越不是单一的举动，而是习惯。 这应该就是之前我引用到说说而被某人说矫情的一句话的源头——优秀是一种习惯。 两个自身条件、机遇等等差不多的人，随着时间的流逝逐渐拉开差距，也许只是其中一个有意识地让自己形成了一些良好的习惯与套路，而另一个迷迷糊糊地就将自己也不知道为什么这么做、是对是错的动作坚持了很多年。 如下内容是根据前几天参加的培训总结的笔记，是我认为比较实用的套路和惯例，迄今为止我尚未拜读过史蒂芬.柯维的大作《高效能人士的七个习惯》。 目录 TOC{:toc} 有鹅才能有金蛋据说一篇有趣的文章都应该以讲故事开头： 一天，一个很穷的农夫在鹅窝里发现了一个金光闪闪的蛋，更让他喜出望外的是这个蛋是纯金的。这之后，农夫每天都可以从鹅窝里拿到一个金蛋。然而，当他日益富有的时候，他也越来越贪婪，以至于没有耐心等待每天只有一个金蛋，他想一次拿到鹅身体里的所有金子，于是他杀了这只鹅，但结果却是什么都没得到。 ——伊索寓言《鹅和金蛋》 这听起来真是一个悲伤的故事啊！但是坑爹的他已经凭白无故拿到好多金蛋可以幸福地生活下半辈子了鹅没了也就没了为毛我连彩票都没中过十块以上的所以人生还是不公平的啊！ 好吧寓言应该不是告诉我这样去想问题的，还是听老师的话，这样来理解吧：杀鹅取卵的做法当然不可取，但是想想这样的事情自己却也没少干，随意举几个： 熬夜，少运动——慢性扼杀身体这只鹅 晚上一不留神就熬到夜深，虽然一周打一两次羽毛球但是相对整天地坐着还是太不够…… 偷懒，少学习——慢性扼杀智慧这只鹅 大多数时候还是功利地学习，遇到什么问题只是针对地去解决，事后主动地寻求系统地补充相关知识的时候容易偷懒进度慢…… 死宅，少沟通——慢性扼杀感情这只鹅 跟好多人一样，朋友见面好不容易能交流的时光被消磨在了手机屏幕上…… …… 想要源源不断地收获金蛋，那就要用心去养好自己的几只鹅，让它们心情愉悦精力充沛，远离死亡的威胁。据说这是一份相对合理的每天养身体、智慧和感情这三只鹅的一天二十四小时时间分配图，可以以此为基础根据自己实际情况稍作修改做一份适合自己的作息计划： 反射弧里加一环一般来讲，我们感觉遇到困难的处境后是这样的： 但是实际上发生的过程是这样的： 这就是为何同一件事情，不同的人会有不同的感受和回应方式的秘密。觉察到中间这一环，就能自由选择以什么样的心情和方式来回应。 解决问题三部曲 定义问题 发现问题 有什么样的现象? 定义问题 我想要什么，如何 XXX？ 不能仅停留在发现问题的层面然后就去想对策，让自己用「如何XXX」的句式找出真正的诉求。 分析问题 遇到问题画个圈，弄明白哪些因素是关注就可以的，哪些因素是自己真正能影响的。 关注圈 包括所有关切和担心的因素。比如可能有别人的理解能力、性格等等。 影响圈 包括所有可以影响的因素。比如可能有别人的意愿、自己的沟通技能技巧、第三方的力量和证明材料等等。 主动积极的人会努力扩大影响圈，而消极的人则可能会在困难面前畏缩而导致影响圈里的一些东西被关注圈吞噬。 解决问题 选择影响圈里的项目——计划和实践——总结、确认、重复 时间管理的建议 不能管理时间，便什么都不能管理。 ——彼德.德鲁克 据说努力让手上的事务主要集中在II区域会让你成为一个下面这样的神人： 有远见、有理想 平衡、纪律性强、自制 少有危机、身体健康 工作生活和谐、人际关系良好 良性的团队发展 三个实用小惯例 事情已经如此了，我（们）能做些什么呢？ 问题本身不是问题，如何解决才是问题。 与别人沟通时遇到不同的看法，记得用「好，很好，说说看！」和「好，很好，还有吗？」，多问、多听、少说。 追求卓越模式图好吧扯了半天貌似跟原书关系不大，说的都是些野路子，那么下面干货来了，据说这张图是《高效能人士的七个习惯》这本书的核心。 主要理念： 成长分三个层次：依赖型、独立型和互赖型。依赖心重的人靠别人来完成愿望，独立自主的人自己打天下，互赖的人集思广益以达成功。 依赖型的人能通过主动积极、以终为始、要事第一三个习惯逐渐成长为独立型的人，独立型的人能通过双赢思维、知彼解己、集思广益三个习惯逐渐成长为互赖型的人，不断更新的习惯则是要求能将前面说的六个习惯不断运用，常用常新。 个人成功的要点是自我掌控和自律，公众成功的核心是深入、持久、高效的人际关系。]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>高效能</tag>
        <tag>习惯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[眼中的自己]]></title>
    <url>%2F2014%2F09%2F27%2Fmyself%2F</url>
    <content type="text"><![CDATA[人的一生最大的敌人是自己，最难看清的也是自己。 借对自己的审视，借别人口中的评价，更好地了解自己，做更好的自己。 优点 可以信任 一般来讲，一件事情如果我应下来，那就会尽力去朝着想要的结果而努力。 热爱阅读 不管有用的没用的，我总是在阅读着，也在进行着一些相应的思考。 缺点 拖延症 任由事情在自己手上堆积，找各种借口不去开始，即使那件事情只需要两分钟就能处理完。 必须症 对自己身上客观存在的一些东西没有无条件地接受；对别人的行为和这个世界的样子存在期待，一旦不符合期待便会焦虑和自我挫败。 含糊症 别人来问我什么问题的时候总是回答得很快，有时候给出的并不是经过思考后最合理最确定的回答，后来反应和发觉过来只好再去补救。其实别人没那么急，略等几秒在脑海里找到确定的答案再答复相对是效率更高的方式，这并不会显得我没有准备和欠思考，实际上它比我立即给出一个不准确的答案而后来再推翻或补充要好。]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>优点</tag>
        <tag>缺点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我所理解的生活]]></title>
    <url>%2F2014%2F08%2F30%2Faboutlife%2F</url>
    <content type="text"><![CDATA[每一次「嘴笨」的背后，都有平时疏于思考的懒惰。——写在最前面。 我想要什么这个可以分两个方面来讲：物质和精神。 从物质上来讲，我期望能够尽快地拥有世俗眼光里大家认为这个年纪的生活里应该拥有的东西，直白点讲就是车子房子票子妹子（排名不分先后）。 从精神上来讲，我目前比较想的是不久后的某一天，我能惊喜地发现自己已经克服了「必须症」。 急功近利，焦虑不安，是现状。除了特别年幼的那几年，从小到大，一直在学也没学好玩也没玩好的怪圈里挣扎，到如今自认为是循规蹈矩，个性全无。但其实细想一下，我们到底在急什么？大学毕业参加工作才几年时光，就迫不及待地想拥有一切。我们一直在匆忙前行，其实最急迫的可能不是快点往前走，而是偶尔停下来想一想为何这样，调整好前进的方向。 关于爱情一个人的时候其实是很无畏很能凑合的，是爱让我懂得害怕，害怕失去，害怕在她面前表现得不够好，害怕不能给她好的生活。 两个人免不了要彼此包容，想要在所有事情上都观点相同是不现实的；两个人应该也要能彼此成就，能有一些促进对方做更好的自己的特质。 当然最重要的，我们首先还是自己的自己，然后才会是彼此的彼此，每个人都应该活出一个丰满充实的人生，不应把自己的愉悦与幸福过度地寄托在别人身上，幸福是自己感觉出来的。 任何事情说得太多了就廉价了，比如说爱，比如表白。 关于承诺一直以来都认为爱情里的承诺是一种很苍白的语言。双方足够信任的时候，不需要承诺，因为会笃定地相信两个人会为了共同的目标去努力。在不得不需要承诺来令对方相信的时候，相信两个人心里都会有一丝悲情和哀伤。 如果必须要承诺，我承诺我会持续不断地努力让自己和爱的人生活得更好。 关于欲望欲望是无止境的，很多东西，够用舒适就行，在这样的前提下，容易满足的人更容易得到更多的幸福感吧。]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>自我</tag>
        <tag>改进</tag>
      </tags>
  </entry>
</search>
